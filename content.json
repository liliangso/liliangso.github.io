{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2022-01-31T10:37:45.000Z","updated":"2022-01-31T10:37:45.195Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-31T08:54:22.000Z","updated":"2022-01-31T09:33:06.311Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"设计模式","date":"2022-02-01T01:21:39.000Z","updated":"2022-02-01T01:21:39.064Z","comments":true,"path":"设计模式/index.html","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html","excerpt":"","text":""}],"posts":[{"title":"UML","slug":"设计模式-UML","date":"2022-01-31T08:19:09.025Z","updated":"2022-02-01T06:19:18.128Z","comments":false,"path":"2022/01/31/设计模式-UML/","link":"","permalink":"http://example.com/2022/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML/","excerpt":"","text":"一 UML图中的六种关系UML将事物之间的联系归纳为6种 分别是 关联关系、聚合关系、组合关系、泛化关系、实现关系、依赖关系 关联关系 关联关系 是对象之间的一种引用关系，表示一个类和另一个类之间的联系。关联关系有单向的也有双向的，在UML类图中 单向关联用一个带箭头的实线表示，双向关联用没有箭头的实线来表示 (一个类A的成员变量包含了另一个类B 则该A与B之间是关联关系 类A与类B在同一个层次) 聚合关系 聚合关系其实也是关联关系的一种 即它也满足 (一个类A的成员变量包含了另一个类B) 聚合关系与关联关系最大的区别是 类A与类B不是同一个层次 这是一个逻辑上的概念 代码中无法呈现。成员是整体的一部分，成员也可以脱离整体而存在。在UML类图中，用带空心菱形的实线来表示聚合关系，菱形指向整体。 组合关系 组合关系首先也是关联关系的一种 同时也是聚合关系的一种 即它满足(一个类A的成员变量包含了另一个类B 且 A 与 B不是同一个层次) 它与聚合关系最大的区别是聚合关系中类B是可以单独存在的 而组合关系中类B不能单独存在(能否单独存在 也是一个逻辑上的概念 代码无法区分) 在UML类图中，用带实心菱形的实线来表示组合关系，菱形指向整体 下图中 大脑是身体的一个组成部分 且大脑 不能脱离身体而存在 泛化关系 泛化关系表示的就是类与类之间的继承关系，在UML类图中，用带空心三角箭头的实线来表示泛化关系，箭头从子类指向父类 依赖关系 依赖关系通常表现为一个类(A)的某个方法的参数或者方法中的局部变量使用了另外一个类的对象，注意关联关系讲的是成员变量 而 依赖关系讲的是 局部变量或者方法参数。在UML类图中，依赖关系用带箭头的虚线表示，箭头从使用类指向被依赖的类 实现关系 实现关系就是接口和实现类之间的关系，在UML类图中，用带空心三角箭头的虚线来表示实现关系，箭头从实现类指向接口。 二 时序图时序图是用来描述对象之间消息的发送顺序，横轴表示对象，纵轴表示时间，消息(行为的说明)在各个对象之间横向传递，按照时间顺序排列。时序图的组成元素主要包括 角色(Actor)、对象(Object)、生命线(Lifeline)、控制焦点和消息。 角色 时序图的角色 可以是人、机器、其他系统、子系统 对象 可以理解为执行的主体 他可以是java中的对象 也可以是某个组件、平台、机构等等 消息 消息有同步调用、异步调用、方法返回 同步调用 用实心箭头实线来表示 方法返回 用空心箭头虚线来表示 异步调用 用空心箭头实线来表示 时序图还有一个很重要的概念就是组合片段，组合片段是用来解决交互执行的条件和方式，它允许在时序图中直接表示某段逻辑，时序图的组合片段一共有13种 常用的有如下几种 抉择(Alt) 相当于if else的逻辑 选项(Opt) 仅当提供的条件为真时才执行片段。 相当于只有一条迹线的alt 循环(Loop) 片段可以执行多次，并且防护指示迭代的基础 并行(Par) 每个片段并行运行 时序图常用图例 同步调用 方法返回 异步调用 抉择 选项 选项就是一个单次的Alt 相当于没有else的Alt 满足条件就进来 不满足条件 不做任何处理 走后续的流程 循环","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理","slug":"设计模式-代理模式","date":"2022-01-26T14:49:18.927Z","updated":"2022-02-01T06:28:00.705Z","comments":false,"path":"2022/01/26/设计模式-代理模式/","link":"","permalink":"http://example.com/2022/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式主要是在用户端与目标对象中间 产生一个代理对象，通过代理对象来保护目标对象或者对目标对象的功能进行增强。 一 静态代理通用写法所谓静态代理 就是代理类是固定存在的(在编译期就已经生成了的) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//目标对象需要被代理的接口public interface ISubject &#123; //目标对象(被代理对象)核心方法 void execute(String request);&#125;//目标对象public class RealSubject implements ISubject &#123; @Override public void execute(String request) &#123; System.out.println(&quot;目标对象执行request请求&quot;); &#125;&#125;//代理对象public class Proxy implements ISubject&#123; private ISubject target; //静态代理的第二种写法就是将目标对象直接在代理类中实例化 这样可以避免客户端直接访问真实对象 private Proxy(ISubject target)&#123; this.target = target; &#125; public static Proxy getInstance(ISubject subject) &#123; return new Proxy(subject); &#125; @Override public void execute(String request) &#123; before(target); target.execute(request); //目标对象执行execute方法 after(target); &#125; private void before(ISubject subject) &#123; System.out.println(&quot;前置处理&quot;); &#125; private void after(ISubject subject) &#123; System.out.println(&quot;后置处理&quot;); &#125;&#125;//测试public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = Proxy.getInstance(new RealSubject()); proxy.execute(&quot;测试&quot;); &#125;&#125; 二 JDK动态代理示例动态代理是指代理类是在运行期动态生成的 JDK动态代理核心是要创建一个代理类(代理类必须实现InvocationHandler接口) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//要代理的接口public interface IPerson &#123; //相亲 void findLove(String name);&#125;//真实对象public class Person implements IPerson &#123; private String name; public Person(String name)&#123; this.name = name; &#125; @Override public void findLove(String miss) &#123; System.out.println(name + &quot;和&quot; + miss + &quot;相亲&quot;); &#125;&#125;//通用的代理类public class Proxy implements InvocationHandler &#123; private Object target; private Proxy(Object target) &#123; this.target = target; &#125; //这里对jdk动态代理做了一点变动 本来是应该放在场景内中去使用的 被抽离道理代理类中 public static Object getInstance(Object target, Class&lt;?&gt;[] interfaces) &#123; Proxy proxy = new Proxy(target); return java.lang.reflect.Proxy.newProxyInstance(target。getClass().getClassLoader(), interfaces, proxy); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); after(); return result; &#125; public void before() &#123; System.out.println(&quot;前置处理&quot;); &#125; public void after()&#123; System.out.println(&quot;后置处理&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; IPerson person = (IPerson) Proxy.getInstance(new Person(&quot;张三&quot;), new Class[]&#123;IPerson.class&#125;); person.findLove(&quot;李四&quot;); &#125;&#125; 三 Cglib动态代理导入cglib依赖 123456&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Person &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void findLove(String miss) &#123; System.out.println(name + &quot;和&quot; + miss + &quot;相亲&quot;); &#125;&#125;public class Proxy implements MethodInterceptor &#123; public Person getPerson() &#123; //Enhancer 类似于JDK动态代理的Proxy类 它负责创建代理类 Enhancer enhancer = new Enhancer(); //设置代理类的父类(就是真实/目标对象) enhancer.setSuperclass(Person.class); //设置回调函数 这个类似于JDK动态代理的InvocationHandler接口的实现 enhancer.setCallback(this); return (Person)enhancer.create(); &#125; /** * * @param o 这个参数是Cglib代理类的实例 类似于JDK的InvocationHandler接口的proxy参数 * @param method method为正在被调用的方法 * @param args args为方法参数 * @param proxy proxy 为生成的代理类对方法的代理引用 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; before(); proxy.invokeSuper(o, args); after(); return null; &#125; private void before()&#123; System.out.println(&quot;执行前置处理&quot;); &#125; private void after()&#123; System.out.println(&quot;执行后置处理&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); Person person = proxy.getPerson(); person.setName(&quot;李四&quot;); person.findLove(&quot;张三&quot;); &#125;&#125; 四 三种代理的对比在JDK1.6、JDK1.7、JDK1.8逐步对JDK进行动态代理优化之后，在调用次数较少的情况下, JDK代理的效率比Cglib效率高，当大量调用的时候,JDK1.6、JDK1.7的效率比Cglib效率低。但是JDK1.8的时候，JDK代理效率高于Cglib代理，所以如果有接口使用JDK动态代理，没有接口用Cglib代理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者","slug":"设计模式-建造者模式","date":"2022-01-25T15:44:06.884Z","updated":"2022-02-01T06:27:57.522Z","comments":false,"path":"2022/01/25/设计模式-建造者模式/","link":"","permalink":"http://example.com/2022/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式和工厂模式很像，建造者模式主要偏重于创建复杂对象，它一般被设计为链式调用，一般会在复杂对象中创建一个builder的静态内部类，同时提供一个build方法 示例如下 建造者模式还有一个重要的作用是控制对象变量设值的顺序 在某些需要控制对象属性构建的顺序的场景下比较适用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//测试类public class Client &#123; public static void main(String[] args) &#123; Course.CourseBuilder builder = new Course.CourseBuilder(); Course course = builder.addName(&quot;java&quot;).addNote(new Note(&quot;java笔记&quot;)).addVideo(new Video(&quot;java视频&quot;)).build(); System.out.println(course); &#125;&#125;@Data@ToStringclass Course &#123; private String courseName; private Note note; private Video video; private Course()&#123; &#125; //在建造者模式中builder类一般设计为静态内部类 public static class CourseBuilder &#123; Course course = new Course(); //builder类被设计为允许链式调用 public CourseBuilder addName(String name)&#123; course.setCourseName(name); return this; &#125; public CourseBuilder addNote(Note note)&#123; course.setNote(note); return this; &#125; public CourseBuilder addVideo(Video video) &#123; course.setVideo(video); return this; &#125; public Course build() &#123; return course; &#125; &#125;&#125;@Data@AllArgsConstructor@ToStringclass Note &#123; private String name;&#125;@Data@AllArgsConstructor@ToStringclass Video &#123; private String name;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂","slug":"设计模式-抽象工厂","date":"2022-01-23T15:17:16.828Z","updated":"2022-02-01T06:22:26.229Z","comments":false,"path":"2022/01/23/设计模式-抽象工厂/","link":"","permalink":"http://example.com/2022/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","excerpt":"","text":"抽象工厂可以看做是工厂方法的集合 工厂方法中 一个工厂只能生产一种产品 而抽象工厂中 一个具体的工厂则可以生产多个产品 所谓的产品可以理解为一个接口 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//抽象工厂public interface Course &#123; Note getNote(); //如果抽象工厂中 只包含一个产品(接口)的创建 那么它就是工厂方法 Video getVideo();&#125;//抽象产品Apublic interface Note &#123; void note();&#125;//抽象产品Bpublic interface Video &#123; void play();&#125;//A产品族public class JavaCourse implements Course&#123; @Override public Note getNote() &#123; return new JavaNote(); &#125; @Override public Video getVideo() &#123; return new JavaVideo(); &#125;&#125;//B产品族public class PythonCourse implements Course&#123; @Override public Note getNote() &#123; return new PythonNote(); &#125; @Override public Video getVideo() &#123; return new PythonVideo(); &#125;&#125;//A产品族中的A产品public class JavaNote implements Note&#123; @Override public void note() &#123; System.out.println(&quot;java课堂笔记&quot;); &#125;&#125;//A产品族中的B产品public class JavaVideo implements Video&#123; @Override public void play() &#123; System.out.println(&quot;java课堂视频&quot;); &#125;&#125;//B产品族中的A产品public class PythonNote implements Note&#123; @Override public void note() &#123; System.out.println(&quot;python课堂笔记&quot;); &#125;&#125;//B产品族中的B产品public class PythonVideo implements Video&#123; @Override public void play() &#123; System.out.println(&quot;python课堂视频&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; JavaCourse javaCourse = new JavaCourse(); javaCourse.getVideo().play(); javaCourse.getNote().note(); PythonCourse pythonCourse = new PythonCourse(); pythonCourse.getNote().note(); pythonCourse.getVideo().play(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法","slug":"设计模式-工厂方法","date":"2022-01-23T09:43:37.149Z","updated":"2022-02-01T06:21:08.350Z","comments":false,"path":"2022/01/23/设计模式-工厂方法/","link":"","permalink":"http://example.com/2022/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/","excerpt":"","text":"工厂方法模式区别于简单工厂，最主要的区别是简单工厂只有一个工厂类，而在工厂方法中，会有一个抽象的工厂(接口/抽象类) 同时会有若干个具体的工厂 但是抽象的产品只会有一个。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//抽象的工厂接口public interface IFactory &#123; IProduct createProduct();&#125;//抽象的产品接口public interface IProduct &#123; void productInfo();&#125;//产品Apublic class ProductA implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//产品Bpublic class ProductB implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//工厂Apublic class FactoryA implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductA(); &#125;&#125;//工厂Bpublic class FactoryB implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductB(); &#125;&#125;//这个可以理解为工厂的工厂 实际它不算在工厂方法设计模式中public class FactoryHelper &#123; private static final Map&lt;Class&lt;? extends IFactory&gt;, IFactory&gt; factories = new ConcurrentHashMap&lt;&gt;(); static &#123; registry(FactoryA.class, new FactoryA()); registry(FactoryB.class, new FactoryB()); &#125; public static IFactory getFactory(Class&lt;? extends IFactory&gt; clazz)&#123; return factories.get(clazz); &#125; public static void registry(Class&lt;? extends IFactory&gt; clazz, IFactory factory) &#123; factories.put(clazz, factory); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; IProduct productA = FactoryHelper.getFactory(FactoryA.class).createProduct(); productA.productInfo(); IProduct productB = FactoryHelper.getFactory(FactoryB.class).createProduct(); productB.productInfo(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计原则","slug":"设计模式-设计原则","date":"2022-01-22T13:40:18.206Z","updated":"2022-02-01T06:20:03.272Z","comments":false,"path":"2022/01/22/设计模式-设计原则/","link":"","permalink":"http://example.com/2022/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"开闭原则 是指一个软件实体 如类、模块、函数应该对扩展开放，对修改关闭。 依赖倒置原则 是指代码之间的发生依赖的时候 应该依赖其抽象(接口) 这样可以降低类与类之间的耦合性，提高系统稳定性 单一职责原则 是指一个类只能拥有一个变动的因素 也就是一个类只负责一个职责 单一职责其实就是告诉我们 类和方法都要设计的足够的小 接口隔离原则 一个类对另一个类的依赖应该建立在最小接口上；建立单一的接口 不要建立过于庞大的接口 迪米特法则 又叫最少知道原则 是指一个对象应该尽量降低与其他类的耦合；迪米特法则其实也是告诉我们要依赖最小接口 而不是实现 里氏替换原则 它强调的是对父类与子类的一个约束 简单来说就是在声明变量(成员变量、局部变量、方法参数)的时候 应该要用父类引用指向子类对象 里氏替换原则要求 1、子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法 2、子类可以增加自己特有的方法，3、子类在重载父类方法的时候 方法的参数要比父类更宽松 4、当子类实现父类方法的时候 方法的返回要比父类更加的严格。 合成复用原则 强调的是我们应该尽量减少通过继承的方式来进行代码的复用 更多的应该通过聚合或者组合的形式来进行代码复用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"简单工厂","slug":"设计模式-简单工厂","date":"2022-01-05T13:37:32.895Z","updated":"2022-02-01T06:20:27.635Z","comments":false,"path":"2022/01/05/设计模式-简单工厂/","link":"","permalink":"http://example.com/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/","excerpt":"","text":"简单工厂区别于其他工厂最主要的特征就是有一个具体的工厂类 下面是简单工厂的类图 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//产品接口public interface Product &#123; void display();&#125;//具体产品Apublic class ProductA implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//具体产品Bpublic class ProductB implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//具体产品Cpublic class ProductC implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品C&quot;); &#125;&#125;//简单工厂public class Factory &#123; private Factory() &#123; &#125; public static Factory getInstance() &#123; return Inner.instance; &#125; public Product createProduct(Class&lt;? extends Product&gt; clazz) throws Exception&#123; if (clazz == null) &#123; return null; &#125; Product product = clazz.newInstance(); //此处省略若干创建对象时的所需要的操作 因为一般工厂模式创建对象都是创建复杂对象 return product; &#125; private static class Inner &#123; private static final Factory instance = new Factory(); &#125;&#125;//测试类public class FactoryTest &#123; public static void main(String[] args) throws Exception &#123; Factory factory = Factory.getInstance(); Product product = factory.createProduct(ProductA.class); product.display(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例","slug":"设计模式-单例","date":"2021-12-19T08:02:05.637Z","updated":"2022-02-01T06:27:54.297Z","comments":false,"path":"2021/12/19/设计模式-单例/","link":"","permalink":"http://example.com/2021/12/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/","excerpt":"","text":"单例模式的核心点是构造器私有化 并提供一个全局访问点 一 饿汉式123456789101112public class Singleton01 &#123; private static final Singleton01 instance = new Singleton01(); private Singleton01() &#123; &#125; public static Singleton01 getInstance() &#123; return instance; &#125;&#125; 二 懒汉式 双重检测锁的实现12345678910111213141516171819public class Singleton02 &#123; private static volatile Singleton02 instance; private Singleton02 ()&#123; &#125; public static Singleton02 getInstance()&#123; if (instance == null) &#123; synchronized (Singleton02.class) &#123; if (instance == null) &#123; instance = new Singleton02(); &#125; &#125; &#125; return instance; &#125;&#125; 三 懒汉式 静态内部类实现1234567891011121314public class Singleton03 &#123; private Singleton03() &#123; &#125; public static Singleton03 getInstance()&#123; return Singleton03Holder.instance; &#125; private static class Singleton03Holder &#123; static Singleton03 instance = new Singleton03(); &#125;&#125; 四 枚举实现单例java规范规定 枚举类是没有构造方法 所以这种写法可以防止通过java反射 利用构造器去创建对象 上面的三种方式都无法防止 但是枚举单例可以 12345678public enum Singleton04 &#123; INSTANCE; //其他业务方法 public void sayHello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 枚举单例序列化测试 1234567891011121314151617181920212223242526272829303132333435363738//枚举默认是实现了序列化接口的 不需要单独的实现序列化接口了public enum Singleton &#123; INSTANCE;&#125;public class Client &#123; public static void main(String[] args) throws Exception&#123; String path = &quot;/Users/liliang/code/test/comon-test/src/main/java/com/liliang/test/test/Singleton02.java&quot;; FileOutputStream fos = null; ObjectOutputStream oos = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fos = new FileOutputStream(path); oos = new ObjectOutputStream(fos); oos.writeObject(Singleton.INSTANCE); fis = new FileInputStream(path); ois = new ObjectInputStream(fis); Object object = ois.readObject(); System.out.println(object.hashCode()); //测试结果 hashcode 与 下面的hashcode是一样的 System.out.println(Singleton.INSTANCE.hashCode()); &#125;finally &#123; //文件流的关闭顺序 后用先关 如果用了处理流 则只需要关闭处理流就行了 节点流不需要关闭。 if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125;&#125; 五 通用防止序列化破坏单例的解决办法上述的的单例实现方式除了枚举 都不能再单例类实现序列化接口后 还保证单例 要想在单例类实现序列化接口后还能保证单例 需要增加一个readResolve()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Singleton implements Serializable &#123; private static final long serialVersionUID = 7518189569602396628L; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return Inner.instance; &#125; //必须要加readResolve方法 方法名和返回值都不能错 private Object readResolve() &#123; return Inner.instance; &#125; private static class Inner&#123; private static final Singleton instance = new Singleton(); &#125;&#125;public class Client &#123; public static void main(String[] args) throws Exception&#123; String path = &quot;/Users/liliang/code/test/comon-test/src/main/java/com/liliang/test/test/Singleton02.txt&quot;; FileOutputStream fos = null; ObjectOutputStream oos = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fos = new FileOutputStream(path); oos = new ObjectOutputStream(fos); oos.writeObject(Singleton.getInstance()); fis = new FileInputStream(path); ois = new ObjectInputStream(fis); Object object = ois.readObject(); System.out.println(object.hashCode()); System.out.println(Singleton.getInstance().hashCode()); &#125;finally &#123; //文件流的关闭顺序 后用先关 如果用了处理流 则只需要关闭处理流就行了 节点流不需要关闭。 if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}