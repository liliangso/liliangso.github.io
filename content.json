{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"设计模式","date":"2022-02-01T01:21:39.000Z","updated":"2022-02-01T01:21:39.064Z","comments":true,"path":"设计模式/index.html","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-31T08:54:22.000Z","updated":"2022-01-31T09:33:06.311Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-31T10:37:45.000Z","updated":"2022-01-31T10:37:45.195Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"UML","slug":"设计模式-UML","date":"2022-01-31T08:19:09.025Z","updated":"2022-02-01T01:21:59.350Z","comments":false,"path":"2022/01/31/设计模式-UML/","link":"","permalink":"http://example.com/2022/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML/","excerpt":"","text":"一 UML图中的六种关系UML将事物之间的联系归纳为6种 分别是 关联关系、聚合关系、组合关系、泛化关系、实现关系、依赖关系 关联关系 关联关系 是对象之间的一种引用关系，表示一个类和另一个类之间的联系。关联关系有单向的也有双向的，在UML类图中 单向关联用一个带箭头的实线表示，双向关联用没有箭头的实线来表示 (一个类A的成员变量包含了另一个类B 则该A与B之间是关联关系 类A与类B在同一个层次) 聚合关系 聚合关系其实也是关联关系的一种 即它也满足 (一个类A的成员变量包含了另一个类B) 聚合关系与关联关系最大的区别是 类A与类B不是同一个层次 这是一个逻辑上的概念 代码中无法呈现。成员是整体的一部分，成员也可以脱离整体而存在。在UML类图中，用带空心菱形的实线来表示聚合关系，菱形指向整体。 组合关系 组合关系首先也是关联关系的一种 同时也是聚合关系的一种 即它满足(一个类A的成员变量包含了另一个类B 且 A 与 B不是同一个层次) 它与聚合关系最大的区别是聚合关系中类B是可以单独存在的 而组合关系中类B不能单独存在(能否单独存在 也是一个逻辑上的概念 代码无法区分) 在UML类图中，用带实心菱形的实线来表示组合关系，菱形指向整体 下图中 大脑是身体的一个组成部分 且大脑 不能脱离身体而存在 泛化关系 泛化关系表示的就是类与类之间的继承关系，在UML类图中，用带空心三角箭头的实线来表示泛化关系，箭头从子类指向父类 依赖关系 依赖关系通常表现为一个类(A)的某个方法的参数或者方法中的局部变量使用了另外一个类的对象，注意关联关系讲的是成员变量 而 依赖关系讲的是 局部变量或者方法参数。在UML类图中，依赖关系用带箭头的虚线表示，箭头从使用类指向被依赖的类 实现关系 实现关系就是接口和实现类之间的关系，在UML类图中，用带空心三角箭头的虚线来表示实现关系，箭头从实现类指向接口。 二 时序图时序图是用来描述对象之间消息的发送顺序，横轴表示对象，纵轴表示时间，消息(行为的说明)在各个对象之间横向传递，按照时间顺序排列。时序图的组成元素主要包括 角色(Actor)、对象(Object)、生命线(Lifeline)、控制焦点和消息。 角色 时序图的角色 可以是人、机器、其他系统、子系统 对象 可以理解为执行的主体 他可以是java中的对象 也可以是某个组件、平台、机构等等 消息 消息有同步调用、异步调用、方法返回 同步调用 用实心箭头实线来表示 方法返回 用空心箭头虚线来表示 异步调用 用空心箭头实线来表示 时序图还有一个很重要的概念就是组合片段，组合片段是用来解决交互执行的条件和方式，它允许在时序图中直接表示某段逻辑，时序图的组合片段一共有13种 常用的有如下几种 抉择(Alt) 相当于if else的逻辑 选项(Opt) 仅当提供的条件为真时才执行片段。 相当于只有一条迹线的alt 循环(Loop) 片段可以执行多次，并且防护指示迭代的基础 并行(Par) 每个片段并行运行 时序图常用图例 同步调用 方法返回 异步调用 抉择 选项 选项就是一个单次的Alt 相当于没有else的Alt 满足条件就进来 不满足条件 不做任何处理 走后续的流程 循环","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法","slug":"工厂方法","date":"2022-01-23T09:43:37.149Z","updated":"2022-02-01T02:20:16.632Z","comments":false,"path":"2022/01/23/工厂方法/","link":"","permalink":"http://example.com/2022/01/23/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/","excerpt":"","text":"工厂方法模式区别于简单工厂，最主要的区别是简单工厂只有一个工厂类，而在工厂方法中，会有一个抽象的工厂(接口/抽象类) 同时会有若干个具体的工厂 但是抽象的产品只会有一个。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//抽象的工厂接口public interface IFactory &#123; IProduct createProduct();&#125;//抽象的产品接口public interface IProduct &#123; void productInfo();&#125;//产品Apublic class ProductA implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//产品Bpublic class ProductB implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//工厂Apublic class FactoryA implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductA(); &#125;&#125;//工厂Bpublic class FactoryB implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductB(); &#125;&#125;//这个可以理解为工厂的工厂 实际它不算在工厂方法设计模式中public class FactoryHelper &#123; private static final Map&lt;Class&lt;? extends IFactory&gt;, IFactory&gt; factories = new ConcurrentHashMap&lt;&gt;(); static &#123; registry(FactoryA.class, new FactoryA()); registry(FactoryB.class, new FactoryB()); &#125; public static IFactory getFactory(Class&lt;? extends IFactory&gt; clazz)&#123; return factories.get(clazz); &#125; public static void registry(Class&lt;? extends IFactory&gt; clazz, IFactory factory) &#123; factories.put(clazz, factory); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; IProduct productA = FactoryHelper.getFactory(FactoryA.class).createProduct(); productA.productInfo(); IProduct productB = FactoryHelper.getFactory(FactoryB.class).createProduct(); productB.productInfo(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计原则","slug":"设计原则","date":"2022-01-22T13:40:18.206Z","updated":"2022-02-01T01:56:08.022Z","comments":false,"path":"2022/01/22/设计原则/","link":"","permalink":"http://example.com/2022/01/22/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"开闭原则 是指一个软件实体 如类、模块、函数应该对扩展开放，对修改关闭。 依赖倒置原则 是指代码之间的发生依赖的时候 应该依赖其抽象(接口) 这样可以降低类与类之间的耦合性，提高系统稳定性 单一职责原则 是指一个类只能拥有一个变动的因素 也就是一个类只负责一个职责 单一职责其实就是告诉我们 类和方法都要设计的足够的小 接口隔离原则 一个类对另一个类的依赖应该建立在最小接口上；建立单一的接口 不要建立过于庞大的接口 迪米特法则 又叫最少知道原则 是指一个对象应该尽量降低与其他类的耦合；迪米特法则其实也是告诉我们要依赖最小接口 而不是实现 里氏替换原则 它强调的是对父类与子类的一个约束 简单来说就是在声明变量(成员变量、局部变量、方法参数)的时候 应该要用父类引用指向子类对象 里氏替换原则要求 1、子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法 2、子类可以增加自己特有的方法，3、子类在重载父类方法的时候 方法的参数要比父类更宽松 4、当子类实现父类方法的时候 方法的返回要比父类更加的严格。 合成复用原则 强调的是我们应该尽量减少通过继承的方式来进行代码的复用 更多的应该通过聚合或者组合的形式来进行代码复用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"简单工厂","slug":"简单工厂","date":"2022-01-05T13:37:32.895Z","updated":"2022-02-01T02:17:42.854Z","comments":false,"path":"2022/01/05/简单工厂/","link":"","permalink":"http://example.com/2022/01/05/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/","excerpt":"","text":"简单工厂区别于其他工厂最主要的特征就是有一个具体的工厂类 下面是简单工厂的类图 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//产品接口public interface Product &#123; void display();&#125;//具体产品Apublic class ProductA implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//具体产品Bpublic class ProductB implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//具体产品Cpublic class ProductC implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品C&quot;); &#125;&#125;//简单工厂public class Factory &#123; private Factory() &#123; &#125; public static Factory getInstance() &#123; return Inner.instance; &#125; public Product createProduct(Class&lt;? extends Product&gt; clazz) throws Exception&#123; if (clazz == null) &#123; return null; &#125; Product product = clazz.newInstance(); //此处省略若干创建对象时的所需要的操作 因为一般工厂模式创建对象都是创建复杂对象 return product; &#125; private static class Inner &#123; private static final Factory instance = new Factory(); &#125;&#125;//测试类public class FactoryTest &#123; public static void main(String[] args) throws Exception &#123; Factory factory = Factory.getInstance(); Product product = factory.createProduct(ProductA.class); product.display(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}