{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"FAQ","date":"2022-02-01T12:07:35.000Z","updated":"2022-02-01T12:07:35.327Z","comments":true,"path":"FAQ/index.html","permalink":"http://example.com/FAQ/index.html","excerpt":"","text":""},{"title":"SpringBoot","date":"2022-03-10T15:14:19.000Z","updated":"2022-03-10T15:14:19.482Z","comments":true,"path":"SpringBoot/index.html","permalink":"http://example.com/SpringBoot/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-31T08:54:22.000Z","updated":"2022-01-31T09:33:06.311Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"数据结构与算法","date":"2022-04-11T12:39:25.000Z","updated":"2022-04-11T12:39:25.496Z","comments":true,"path":"数据结构与算法/index.html","permalink":"http://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html","excerpt":"","text":""},{"title":"设计模式","date":"2022-02-01T01:21:39.000Z","updated":"2022-02-01T01:21:39.064Z","comments":true,"path":"设计模式/index.html","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html","excerpt":"","text":""},{"title":"高并发","date":"2022-03-24T15:47:06.000Z","updated":"2022-03-24T15:47:06.196Z","comments":true,"path":"高并发/index.html","permalink":"http://example.com/%E9%AB%98%E5%B9%B6%E5%8F%91/index.html","excerpt":"","text":""},{"title":"JVM","date":"2022-04-19T13:04:44.000Z","updated":"2022-04-19T13:04:44.831Z","comments":true,"path":"JVM/index.html","permalink":"http://example.com/JVM/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-31T10:37:45.000Z","updated":"2022-01-31T10:37:45.195Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM调优(二)","slug":"JVM-JVM调优02","date":"2022-04-21T14:37:57.758Z","updated":"2022-04-23T09:03:17.988Z","comments":false,"path":"2022/04/21/JVM-JVM调优02/","link":"","permalink":"http://example.com/2022/04/21/JVM-JVM%E8%B0%83%E4%BC%9802/","excerpt":"","text":"一 关于16进制数占半个字节的说明一个16进制数最多能表示 0~15 用二进制表示就是4个bit位 所以两个16进制数 用二进制表示就会占8个bit位 也就是一个字节 所以一个16进制数占半个字节 但是为了方便计算会进行高位补0的填充 所以单个16进制数占1个字节 6a 6b这种16进制数也是占一个字节 二 类加载过程 Loading(加载) 将class文件load到内存 Linking(链接) Verification(校验) 校验class文件是否符合class文件的标准 Preparation(准备) 准备阶段会为类的静态变量赋默认值 Resolution(解析) 解析阶段是将符号引用转变成真实地址 没有这一步 声明的成员变量是没办法访问到内存中具体的对象的 Inittializing(初始化) 调用静态代码块、为静态变量赋初值 三 类加载器 Bootstrap ClassLoader(根类加载器) 最顶层的类加载器 是由C++实现的 负责加载lib/rt.jar charset.jar 等核心类 Extension ClassLoader(扩展类加载器) 负责加载扩展jar包 jre/lib/ext/*.jar 或者由-Djava.ext.dirs指定的jar App ClassLoader(应用类加载器) 加载classpath指定内容 Custom ClassLoader自定义类加载器 JVM是按需动态加载的 类的加载采用的是双亲委派机制 Custom ClassLoader的父加载器是App ClassLoader App ClassLoader 的父加载器是Extension ClassLoader Extension ClassLoader的父类Bootstrap ClassLoader(根类加载器) 它们之间并不是java中的继承关系！！ 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; //返回null 表示由根类加载(Bootstrap ClassLoader) 来加载 System.out.println(String.class.getClassLoader()); //返回null 表示由根类加载(Bootstrap ClassLoader) 来加载 System.out.println(sun.awt.HKSCS.class.getClassLoader()); //返回ExtClassLoader 表示是由扩展类加载器加载的 System.out.println(sun.net.spi.nameservice.dns.DNSNameService.class.getClassLoader()); //返回的是AppClassLoader 表示这是应用类加载器加载的 System.out.println(Test_Inner.class.getClassLoader()); &#125;&#125;class Test_Inner &#123;&#125; classLoader部分源码 他们之间并不是继承关系 1234567891011121314151617181920//都在sun.misc.Launcher.class下 static class AppClassLoader extends URLClassLoader &#123; //省略若干代码 &#125;static class ExtClassLoader extends URLClassLoader &#123; //省略若干代码&#125;public class URLClassLoader extends SecureClassLoader implements Closeable &#123; //省略若干代码&#125;public class SecureClassLoader extends ClassLoader &#123; //省略若干代码&#125;public abstract class ClassLoader &#123; //省略若干代码&#125; 四 双亲委派 父加载器 一个类的父加载器不是这个类的父类！！！ 双亲委派 说的是一个类被加载的时候 首先会去自己的缓存中去找这个类是否被加载了 如果没找到则去委托给它的父 类加载器去找这个类 如果父 类加载器的缓存中也没有找到这个类 则继续向上委托 一直到根类加载器 如果根类加载器也没有找到这个类 且根类加载器发现这个类不属于它的加载范围 则委托给它的子 类加载器(ExtClassLoader) ExtClassLoader没有找到的话 且也不属于它的加载范围的话 择会继续向下 委托给AppClassLoader进行加载 LoadClass源码 之所以需要用双亲委派的机制 主要是为了安全性的考虑 让用户自定义的类加载器 无法去加载java的核心类 123456789101112131415161718192021222324252627282930313233343536protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; Class&lt;?&gt; c = findLoadedClass(name); //在本类加载器中找已经加载的类 if (c == null) &#123; //没找到 找父类 long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; //父类没找到 // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); //子类加载器自己去解析 // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 五 自定义类加载器自定义类加载器只需要重写findClass方法即可 不需要重写LoadClass() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CustomClassLoader extends ClassLoader&#123; private String dir; public CustomClassLoader(String dir) &#123; this.dir = dir; &#125; @SneakyThrows @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; File f = new File(dir, name.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;).concat(&quot;.class&quot;)); FileInputStream fis = null; ByteArrayOutputStream bos = null; try &#123; fis = new FileInputStream(f); bos = new ByteArrayOutputStream(); int len = 0; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; bytes = bos.toByteArray(); //defineClass 这个方法是classLoader自己默认实现的 return defineClass(name, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if (bos != null) &#123; bos.close(); &#125; if (fis != null) &#123; fis.close(); &#125; &#125; throw new ClassNotFoundException(name); &#125; public static void main(String[] args) throws Exception&#123; CustomClassLoader loader = new CustomClassLoader(&quot;/Users/xxx/code/test/poi-tl-test/target/classes&quot;); Class&lt;?&gt; board = loader.loadClass(&quot;com.poi.tl.test.Board&quot;); System.out.println(board.getName()); &#125;&#125; 测试 下面这个示例程序说明一个问题在不破坏类加载的双亲委派机制下 一个类被重复加载N次 生成的class对象都是一样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CustomClassLoader extends ClassLoader&#123; private String dir; public CustomClassLoader(String dir) &#123; this.dir = dir; &#125; @SneakyThrows @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; File f = new File(dir, name.replaceAll(&quot;\\\\.&quot;, &quot;/&quot;).concat(&quot;.class&quot;)); FileInputStream fis = null; ByteArrayOutputStream bos = null; try &#123; fis = new FileInputStream(f); bos = new ByteArrayOutputStream(); int len = 0; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; bytes = bos.toByteArray(); //defineClass 这个方法是classLoader自己默认实现的 return defineClass(name, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if (bos != null) &#123; bos.close(); &#125; if (fis != null) &#123; fis.close(); &#125; &#125; throw new ClassNotFoundException(name); &#125; public static void main(String[] args) throws Exception&#123; CustomClassLoader loader = new CustomClassLoader(&quot;/Users/liliang/code/test/poi-tl-test/test&quot;); loader = new CustomClassLoader(&quot;/Users/liliang/code/test/poi-tl-test/test&quot;); Class&lt;?&gt; board = loader.loadClass(&quot;com.poi.tl.test.Board&quot;); Class&lt;?&gt; board2 = loader.loadClass(&quot;com.poi.tl.test.Board&quot;); System.out.println(board == board2); //返回true &#125;&#125; 六 java编译器和解释器现在的jvm执行代码其实是混合执行的 并不是单纯的解释执行 也有一些是通过JIT(just in time complier 也叫java即时编译器)编译成为本地代码执行的。可以通过jvm参数来指定 -Xmixed 如果指定 -Xmixed 则表示使用混合模式来执行 这也是jvm 默认的模式 开始是解释执行的 启动速度较快 对热点代码进行检测和编译(jvm 执行java代码是懒加载的方式) 混合模式下启动较快 -Xint 使用纯解释模式 启动很快 执行稍慢 -Xcomp 使用纯编译模式 执行很快 启动很慢 关于混合执行的说明 混合执行模式下 会混合执行解释器和JIT 对热点代码会使用JIT 在项目启动阶段采用解释执行 同时对热点代码进行检测 多次被调用的方法(可以通过方法计数器来监测方法执行频率)以及多次被调用的循环(循环计数器 来监测循环执行的频率) java程序执行过程 首先.java文件需要被编译为.class文件 jvm负责把.class文件(字节码)load到内存 放到JVM方法区(元空间) 然后通过调用解释器 将字节码翻译成为本地代码执行 JIT将一段代码编译成本地代码直接保存到内存中(windows系统本地代码是exe文件 linux系统本地代码是elf文件)也是这个道理 当class文件的某一段代码频次很高的时候就会将这段代码翻译成本地代码后直接存起来 下次再执行的时候就不需要在通过解释器翻译了 测试三种执行模式的效率 将下面的代码分别添加jvm参数-Xmixed -Xint -Xcomp 实测结果如下 123-Xmixed 372-Xcomp 394-Xint 26789 测试代码 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; //先模拟某个方法被频繁调用的情况 如果是Xmixed 那么在执行的时候就会被编译成本地代码执行 for(int i = 0; i &lt; 10_0000; i++)&#123; m(); &#125; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10_0000; i++) &#123; m(); &#125; long end = System.currentTimeMillis(); System.out.println(end - start); &#125; private static void m() &#123; for (long i = 0; i &lt; 10000L; i++) &#123; long n = i % 3; &#125; &#125;&#125; 七 类的初始化 主动使用 JAVA中对类的使用有两种方式 分别是主动使用和被动使用 第一次主动使用才进行初始化,之后就不再初始化 主动使用包含7种情况 创建类的实例 new 操作符 (new 操作分两步 一个是先给类对象分配内存空间 然后在给类的成员变量分配默认值 最后调用构造方法给成员变量赋初值) 访问某个类或接口的静态变量 或者对静态变量进行赋值 静态常量是不会触发类的初始化的 调用类的静态方法 反射 Class.forName(“com.xxx.xxx”) 初始化一个类的子类 父类会初始化 Java虚拟机启动时被标明为启动类的类 包含main方法的类 JDK7开始提供的动态语言支持,java.lang.invoke.MethodHandle 被动使用 除了主动使用的7种情况,其他使用Java类的方式都被看作是对类的被动使用,都不会导致类的初始化,但是依然会对类进行装载和连接 面试题 下面的打印的count会是几 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; //打印的是3 原因是调用一个类的静态变量会触发对这个类的初始化 //类的初始化的时候 会为静态变量赋初值 同时也会调用静态代码块 //下面调用T.count的时候 会先执行 public static int count = 2; //再执行 private static T t = new T(); System.out.println(T.count); &#125;&#125;class T &#123; public static int count = 2; private static T t = new T(); public T() &#123; count++; &#125;&#125; 对上面的代码调换一下顺序 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; //打印的是2 原因是调用一个类的静态变量会触发对这个类的初始化 //类的初始化的时候 会为静态变量赋初值 同时也会调用静态代码块 //下面调用T.count的时候 会先执行 private static T t = new T(); 此时count是1 //public static int count = 2; System.out.println(T.count); &#125;&#125;class T &#123; private static T t = new T(); public static int count = 2; public T() &#123; count++; &#125;&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"JVM调优(一)","slug":"JVM-JVM调优01","date":"2022-04-19T13:04:08.398Z","updated":"2022-04-20T15:29:59.452Z","comments":false,"path":"2022/04/19/JVM-JVM调优01/","link":"","permalink":"http://example.com/2022/04/19/JVM-JVM%E8%B0%83%E4%BC%9801/","excerpt":"","text":"一 JVM基础JVM只是一个规范 具体会有很多类型的JVM实现 比如Hotspot、J9、Microsoft VM、TaobaoVM等等 JDK JRE JVM的关系 JDK &gt; JRE &gt; JVM java文件从编码到执行的顺序 二 Class 文件格式123456789101112131415161718ClassFile &#123; u4 magic; //魔数 占4个字节 u4表示4个字节 内容统一为 CA FE BA BE u2 minor_version; //小版本号 JDK的小版本 2个字节 u2 major_version; //大版本号 JDK的大版本 2个字节 u2 constant_pool_count; //常量池中常量的数量 2个字节 cp_info constant_pool[constant_pool_count-1]; //常量池的具体内容 u2 access_flags; //class文件的权限修饰符 public final 这些修饰符 等等 u2 this_class; //class文件的全限定名 u2 super_class; //父类的全限定名 u2 interfaces_count; //这个类实现/继承的接口的数量 u2 interfaces[interfaces_count]; // 接口的具体内容 u2 fields_count; //全局变量的数量 field_info fields[fields_count]; u2 methods_count; //方法的数量 method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];&#125; 反编译clas文件 1javap -v xxx.class jclasslib Bytecode Viewer 这是idea的插件 安装好这个插件后 可以用来分析class文件的构成 如下图 首先光标选择某个class文件 然后邮件 常量池的具体内容 对应class文件中的 cp_info 具体常量池信息看下图 三 JVM指令集 操作数栈相关指令 指令 说明 iload 将指定的int型本地变量推送至栈顶 iload_x 将第x个int型本地变量推送至栈顶，x范围：[0, 3] lload 将指定的long型本地变量推送至栈顶 lload_x 将第x个long型本地变量推送至栈顶，x范围：[0, 3] fload 将指定的float型本地变量推送至栈顶 fload_x 将第x个flaot型本地变量推送至栈顶，x范围：[0, 3] dload 将指定的double型本地变量推送至栈顶 dload_x 将第x个double型本地变量推送至栈顶，x范围：[0, 3] aload 将指定的引用类型本地变量推送至栈顶 aload_x 将第x个引用类型本地变量推送至栈顶，x范围：[0, 3] istore 将栈顶int型数值存入指定本地变量 istore_x 将栈顶int型数值存入第x个本地变量，x范围：[0, 3] lstore 将栈顶long型数值存入指定本地变量 lstore_x 将栈顶long型数值存入第x个本地变量，x范围：[0, 3] fstore 将栈顶float型数值存入指定本地变量 fstore_x 将栈顶float型数值存入第x个本地变量，x范围：[0, 3] dstore 将栈顶double型数值存入指定本地变量 dstore_x 将栈顶double型数值存入第x个本地变量，x范围：[0, 3] astore 将栈顶引用类型存入指定本地变量 astore_x 将栈顶引用类型存入第x个本地变量，x范围：[0, 3] 可以看到：i开头的指令操作数类型是integer类型，l开头的指令操作数类型是long类型，f开头的指令操作数类型是float类型，d开头的指令操作数类型是double，a开头的指令操作数类型是引用类型(reference) 常数操作相关指令 指令 说明 bipush 将单字节的常量值(-128~127)推送至栈顶 sipush 将一个短整型常量值(-32768~32767)推送至栈顶 ldc 将int, float或String型常量值从常量池中推送至栈顶 ldc_w 将int, float或String型常量值从常量池中推送至栈顶（宽索引） aconst_null 将null推送至栈顶 iconst_m1 将int型-1推送至栈顶 iconst_x 将int型x推送至栈顶，x范围：[0, 5] lconst_x 将long型x推送至栈顶，x范围：[0, 1] fconst_x 将float型x推送至栈顶，x范围：[0, 1] dconst_x 将double型x推送至栈顶，x范围：[0, 1] 数组操作相关指令 指令 说明 iaload 将int型数组指定索引的值推送至栈顶 laload 将long型数组指定索引的值推送至栈顶 faload 将float型数组指定索引的值推送至栈顶 daload 将double型数组指定索引的值推送至栈顶 aaload 将引用型数组指定索引的值推送至栈顶 baload 将boolean或byte型数组指定索引的值推送至栈顶 caload 将char型数组指定索引的值推送至栈顶 saload 将short型数组指定索引的值推送至栈顶 iastore 将栈顶int型数值存入指定数组的指定索引位置 lastore 将栈顶long型数值存入指定数组的指定索引位置 fastore 将栈顶float型数值存入指定数组的指定索引位置 dastore 将栈顶double型数值存入指定数组的指定索引位置 aastore 将栈顶引用型数值存入指定数组的指定索引位置 bastore 将栈顶boolean或byte型数值存入指定数组的指定索引位置 castore 将栈顶char型数值存入指定数组的指定索引位置 sastore 将栈顶short型数值存入指定数组的指定索引位置 操作数栈其他常用指令 指令 说明 pop 将栈顶数值弹出 (数值不能是long或double类型的) pop2 将栈顶的一个（long或double类型的)或两个数值弹出（其它） dup 复制栈顶数值并将复制值压入栈顶 dup_x1 复制栈顶数值并将两个复制值压入栈顶 dup_x2 复制栈顶数值并将三个（或两个）复制值压入栈顶 dup2 复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶 dup2_x1 复制栈顶2个数值，并压入栈顶2次 dup2_x2 复制栈顶2个数值，并压入栈顶3次 swap 将栈最顶端的两个数值互换(数值不能是long或double类型的) 运算相关 功能 指令 加 iadd,ladd,fadd,dadd 减 is,ls,fs,ds 乘 imul,lmul,fmul,dmul 除 idiv,ldiv,fdiv,ddiv 余数 irem,lrem,frem,drem 取负 ineg,lneg,fneg,dneg 移位 ishl,lshr,iushr,lshl,lshr,lushr 按位或 ior,lor 按位与 iand,land 按位异或 ixor,lxor 类型转换 i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换)；i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换) 条件转移 功能 指令 有条件转移 ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene, if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl,fcmpg,dcmpl,dcmpg 复合条件转移 tableswitch,lookupswitch 无条件转移 goto,goto_w,jsr,jsr_w,ret 类和数组 功能 指令 创建类 new 创建新数组 newarray,anewarray,multianwarray 访问类的域和类实例域 getfield,putfield,getstatic,putstatic 获取数组长度 arraylength 检相类实例或数组属性 instanceof,checkcast 其他指令 功能 指令 调度对象的实便方法 invokevirtual 调用由接口实现的方法 invokeinterface 调用需要特殊处理的实例方法 invokespecial 调用命名类中的静态方法 invokestatic 方法返回 ireturn,lreturn,freturn,dreturn,areturn,return 异常 athrow finally关键字的实现使用 jsr,jsr_w,ret synchronized锁 monitorenter,monitorexit 全部指令集 指令码(16进制) 助记符 说明 0×00 nop 什么都不做 0×01 aconst_null 将null推送至栈顶 0×02 iconst_m1 将int型-1推送至栈顶 0×03 iconst_0 将int型0推送至栈顶 0×04 iconst_1 将int型1推送至栈顶 0×05 iconst_2 将int型2推送至栈顶 0×06 iconst_3 将int型3推送至栈顶 0×07 iconst_4 将int型4推送至栈顶 0×08 iconst_5 将int型5推送至栈顶 0×09 lconst_0 将long型0推送至栈顶 0x0a lconst_1 将long型1推送至栈顶 0x0b fconst_0 将float型0推送至栈顶 0x0c fconst_1 将float型1推送至栈顶 0x0d fconst_2 将float型2推送至栈顶 0x0e dconst_0 将double型0推送至栈顶 0x0f dconst_1 将double型1推送至栈顶 0×10 bipush 将单字节的常量值(-128~127)推送至栈顶 0×11 sipush 将一个短整型常量值(-32768~32767)推送至栈顶 0×12 ldc 将int, float或String型常量值从常量池中推送至栈顶 0×13 ldc_w 将int, float或String型常量值从常量池中推送至栈顶（宽索引） 0×14 ldc2_w 将long或double型常量值从常量池中推送至栈顶（宽索引） 0×15 iload 将指定的int型本地变量推送至栈顶 0×16 lload 将指定的long型本地变量推送至栈顶 0×17 fload 将指定的float型本地变量推送至栈顶 0×18 dload 将指定的double型本地变量推送至栈顶 0×19 aload 将指定的引用类型本地变量推送至栈顶 0x1a iload_0 将第0个int型本地变量推送至栈顶 0x1b iload_1 将第1个int型本地变量推送至栈顶 0x1c iload_2 将第2个int型本地变量推送至栈顶 0x1d iload_3 将第3个int型本地变量推送至栈顶 0x1e lload_0 将第0个long型本地变量推送至栈顶 0x1f lload_1 将第1个long型本地变量推送至栈顶 0×20 lload_2 将第2个long型本地变量推送至栈顶 0×21 lload_3 将第3个long型本地变量推送至栈顶 0×22 fload_0 将第0个float型本地变量推送至栈顶 0×23 fload_1 将第1个float型本地变量推送至栈顶 0×24 fload_2 将第2个float型本地变量推送至栈顶 0×25 fload_3 将第3个float型本地变量推送至栈顶 0×26 dload_0 将第0个double型本地变量推送至栈顶 0×27 dload_1 将第1个double型本地变量推送至栈顶 0×28 dload_2 将第2个double型本地变量推送至栈顶 0×29 dload_3 将第3个double型本地变量推送至栈顶 0x2a aload_0 将第0个引用类型本地变量推送至栈顶 0x2b aload_1 将第1个引用类型本地变量推送至栈顶 0x2c aload_2 将第2个引用类型本地变量推送至栈顶 0x2d aload_3 将第3个引用类型本地变量推送至栈顶 0x2e iaload 将int型数组指定索引的值推送至栈顶 0x2f laload 将long型数组指定索引的值推送至栈顶 0×30 faload 将float型数组指定索引的值推送至栈顶 0×31 daload 将double型数组指定索引的值推送至栈顶 0×32 aaload 将引用型数组指定索引的值推送至栈顶 0×33 baload 将boolean或byte型数组指定索引的值推送至栈顶 0×34 caload 将char型数组指定索引的值推送至栈顶 0×35 saload 将short型数组指定索引的值推送至栈顶 0×36 istore 将栈顶int型数值存入指定本地变量 0×37 lstore 将栈顶long型数值存入指定本地变量 0×38 fstore 将栈顶float型数值存入指定本地变量 0×39 dstore 将栈顶double型数值存入指定本地变量 0x3a astore 将栈顶引用型数值存入指定本地变量 0x3b istore_0 将栈顶int型数值存入第0个本地变量 0x3c istore_1 将栈顶int型数值存入第1个本地变量 0x3d istore_2 将栈顶int型数值存入第2个本地变量 0x3e istore_3 将栈顶int型数值存入第3个本地变量 0x3f lstore_0 将栈顶long型数值存入第0个本地变量 0×40 lstore_1 将栈顶long型数值存入第1个本地变量 0×41 lstore_2 将栈顶long型数值存入第2个本地变量 0×42 lstore_3 将栈顶long型数值存入第3个本地变量 0×43 fstore_0 将栈顶float型数值存入第0个本地变量 0×44 fstore_1 将栈顶float型数值存入第1个本地变量 0×45 fstore_2 将栈顶float型数值存入第2个本地变量 0×46 fstore_3 将栈顶float型数值存入第3个本地变量 0×47 dstore_0 将栈顶double型数值存入第0个本地变量 0×48 dstore_1 将栈顶double型数值存入第1个本地变量 0×49 dstore_2 将栈顶double型数值存入第2个本地变量 0x4a dstore_3 将栈顶double型数值存入第3个本地变量 0x4b astore_0 将栈顶引用型数值存入第0个本地变量 0x4c astore_1 将栈顶引用型数值存入第1个本地变量 0x4d astore_2 将栈顶引用型数值存入第2个本地变量 0x4e astore_3 将栈顶引用型数值存入第3个本地变量 0x4f iastore 将栈顶int型数值存入指定数组的指定索引位置 0×50 lastore 将栈顶long型数值存入指定数组的指定索引位置 0×51 fastore 将栈顶float型数值存入指定数组的指定索引位置 0×52 dastore 将栈顶double型数值存入指定数组的指定索引位置 0×53 aastore 将栈顶引用型数值存入指定数组的指定索引位置 0×54 bastore 将栈顶boolean或byte型数值存入指定数组的指定索引位置 0×55 castore 将栈顶char型数值存入指定数组的指定索引位置 0×56 sastore 将栈顶short型数值存入指定数组的指定索引位置 0×57 pop 将栈顶数值弹出 (数值不能是long或double类型的) 0×58 pop2 将栈顶的一个（long或double类型的)或两个数值弹出（其它） 0×59 dup 复制栈顶数值并将复制值压入栈顶 0x5a dup_x1 复制栈顶数值并将两个复制值压入栈顶 0x5b dup_x2 复制栈顶数值并将三个（或两个）复制值压入栈顶 0x5c dup2 复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶 0x5d dup2_x1 复制栈顶2个数值，并压入栈顶2次 0x5e dup2_x2 复制栈顶2个数值，并压入栈顶3次 0x5f swap 将栈最顶端的两个数值互换(数值不能是long或double类型的) 0×60 iadd 将栈顶两int型数值相加并将结果压入栈顶 0×61 ladd 将栈顶两long型数值相加并将结果压入栈顶 0×62 fadd 将栈顶两float型数值相加并将结果压入栈顶 0×63 dadd 将栈顶两double型数值相加并将结果压入栈顶 0×64 isub 将栈顶两int型数值相减并将结果压入栈顶 0×65 lsub 将栈顶两long型数值相减并将结果压入栈顶 0×66 fsub 将栈顶两float型数值相减并将结果压入栈顶 0×67 dsub 将栈顶两double型数值相减并将结果压入栈顶 0×68 imul 将栈顶两int型数值相乘并将结果压入栈顶 0×69 lmul 将栈顶两long型数值相乘并将结果压入栈顶 0x6a fmul 将栈顶两float型数值相乘并将结果压入栈顶 0x6b dmul 将栈顶两double型数值相乘并将结果压入栈顶 0x6c idiv 将栈顶两int型数值相除并将结果压入栈顶 0x6d ldiv 将栈顶两long型数值相除并将结果压入栈顶 0x6e fdiv 将栈顶两float型数值相除并将结果压入栈顶 0x6f ddiv 将栈顶两double型数值相除并将结果压入栈顶 0×70 irem 将栈顶两int型数值作取模运算并将结果压入栈顶 0×71 lrem 将栈顶两long型数值作取模运算并将结果压入栈顶 0×72 frem 将栈顶两float型数值作取模运算并将结果压入栈顶 0×73 drem 将栈顶两double型数值作取模运算并将结果压入栈顶 0×74 ineg 将栈顶int型数值取负并将结果压入栈顶 0×75 lneg 将栈顶long型数值取负并将结果压入栈顶 0×76 fneg 将栈顶float型数值取负并将结果压入栈顶 0×77 dneg 将栈顶double型数值取负并将结果压入栈顶 0×78 ishl 将int型数值左移位指定位数并将结果压入栈顶 0×79 lshl 将long型数值左移位指定位数并将结果压入栈顶 0x7a ishr 将int型数值右（符号）移位指定位数并将结果压入栈顶 0x7b lshr 将long型数值右（符号）移位指定位数并将结果压入栈顶 0x7c iushr 将int型数值右（无符号）移位指定位数并将结果压入栈顶 0x7d lushr 将long型数值右（无符号）移位指定位数并将结果压入栈顶 0x7e iand 将栈顶两int型数值作“按位与”并将结果压入栈顶 0x7f land 将栈顶两long型数值作“按位与”并将结果压入栈顶 0×80 ior 将栈顶两int型数值作“按位或”并将结果压入栈顶 0×81 lor 将栈顶两long型数值作“按位或”并将结果压入栈顶 0×82 ixor 将栈顶两int型数值作“按位异或”并将结果压入栈顶 0×83 lxor 将栈顶两long型数值作“按位异或”并将结果压入栈顶 0×84 iinc 将指定int型变量增加指定值，可以有两个变量，分别表示index, const，index指第index个int型本地变量，const增加的值 0×85 i2l 将栈顶int型数值强制转换成long型数值并将结果压入栈顶 0×86 i2f 将栈顶int型数值强制转换成float型数值并将结果压入栈顶 0×87 i2d 将栈顶int型数值强制转换成double型数值并将结果压入栈顶 0×88 l2i 将栈顶long型数值强制转换成int型数值并将结果压入栈顶 0×89 l2f 将栈顶long型数值强制转换成float型数值并将结果压入栈顶 0x8a l2d 将栈顶long型数值强制转换成double型数值并将结果压入栈顶 0x8b f2i 将栈顶float型数值强制转换成int型数值并将结果压入栈顶 0x8c f2l 将栈顶float型数值强制转换成long型数值并将结果压入栈顶 0x8d f2d 将栈顶float型数值强制转换成double型数值并将结果压入栈顶 0x8e d2i 将栈顶double型数值强制转换成int型数值并将结果压入栈顶 0x8f d2l 将栈顶double型数值强制转换成long型数值并将结果压入栈顶 0×90 d2f 将栈顶double型数值强制转换成float型数值并将结果压入栈顶 0×91 i2b 将栈顶int型数值强制转换成byte型数值并将结果压入栈顶 0×92 i2c 将栈顶int型数值强制转换成char型数值并将结果压入栈顶 0×93 i2s 将栈顶int型数值强制转换成short型数值并将结果压入栈顶 0×94 lcmp 比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶 0×95 fcmpl 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶 0×96 fcmpg 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶 0×97 dcmpl 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶 0×98 dcmpg 比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶 0×99 ifeq 当栈顶int型数值等于0时跳转 0x9a ifne 当栈顶int型数值不等于0时跳转 0x9b iflt 当栈顶int型数值小于0时跳转 0x9c ifge 当栈顶int型数值大于等于0时跳转 0x9d ifgt 当栈顶int型数值大于0时跳转 0x9e ifle 当栈顶int型数值小于等于0时跳转 0x9f if_icmpeq 比较栈顶两int型数值大小，当结果等于0时跳转 0xa0 if_icmpne 比较栈顶两int型数值大小，当结果不等于0时跳转 0xa1 if_icmplt 比较栈顶两int型数值大小，当结果小于0时跳转 0xa2 if_icmpge 比较栈顶两int型数值大小，当结果大于等于0时跳转 0xa3 if_icmpgt 比较栈顶两int型数值大小，当结果大于0时跳转 0xa4 if_icmple 比较栈顶两int型数值大小，当结果小于等于0时跳转 0xa5 if_acmpeq 比较栈顶两引用型数值，当结果相等时跳转 0xa6 if_acmpne 比较栈顶两引用型数值，当结果不相等时跳转 0xa7 goto 无条件跳转 0xa8 jsr 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶 0xa9 ret 返回至本地变量指定的index的指令位置（一般与jsr, jsr_w联合使用） 0xaa tableswitch 用于switch条件跳转，case值连续（可变长度指令） 0xab lookupswitch 用于switch条件跳转，case值不连续（可变长度指令） 0xac ireturn 从当前方法返回int 0xad lreturn 从当前方法返回long 0xae freturn 从当前方法返回float 0xaf dreturn 从当前方法返回double 0xb0 areturn 从当前方法返回对象引用 0xb1 return 从当前方法返回void 0xb2 getstatic 获取指定类的静态域，并将其值压入栈顶 0xb3 putstatic 为指定的类的静态域赋值 0xb4 getfield 获取指定类的实例域，并将其值压入栈顶 0xb5 putfield 为指定的类的实例域赋值 0xb6 invokevirtual 调用实例方法 0xb7 invokespecial 调用超类构造方法，实例初始化方法，私有方法 0xb8 invokestatic 调用静态方法 0xb9 invokeinterface 调用接口方法 0xba – 0xbb new 创建一个对象，并将其引用值压入栈顶 0xbc newarray 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶 0xbd anewarray 创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶 0xbe arraylength 获得数组的长度值并压入栈顶 0xbf athrow 将栈顶的异常抛出 0xc0 checkcast 检验类型转换，检验未通过将抛出ClassCastException 0xc1 instanceof 检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶 0xc2 monitorenter 获得对象的锁，用于同步方法或同步块 0xc3 monitorexit 释放对象的锁，用于同步方法或同步块 0xc4 wide 当本地变量的索引超过255时使用该指令扩展索引宽度。 0xc5 multianewarray create a new array of dimensions dimensions with elements of type identified by class reference in constant pool index (indexbyte1 &lt;&lt; 8 + indexbyte2); the sizes of each dimension is identified by count1, [count2, etc.] 0xc6 ifnull if value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 + branchbyte2) 0xc7 ifnonnull if value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 &lt;&lt; 8 + branchbyte2) 0xc8 goto_w goes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 &lt;&lt; 24 + branchbyte2 &lt;&lt; 16 + branchbyte3 &lt;&lt; 8 + branchbyte4) 0xc9 jsr_w jump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 &lt;&lt; 24 + branchbyte2 &lt;&lt; 16 + branchbyte3 &lt;&lt; 8 + branchbyte4) and place the return address on the stack 0xca breakpoint reserved for breakpoints in Java debuggers; should not appear in any class file 0xcb-0xfd 未命名 these values are currently unassigned for opcodes and are reserved for future use 0xfe impdep1 reserved for implementation-dependent operations within debuggers; should not appear in any class file 0xff impdep2 reserved for implementation-dependent operations within debuggers; should not appear in any class file","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"多线程与高并发(六)","slug":"高并发-多线程与高并发六","date":"2022-04-17T08:39:30.404Z","updated":"2022-04-18T13:52:01.812Z","comments":false,"path":"2022/04/17/高并发-多线程与高并发六/","link":"","permalink":"http://example.com/2022/04/17/%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E5%85%AD/","excerpt":"","text":"一 JMH(Java Microbenchmark Harness)JMH是一个基准测试套件工具 JMH与JMeter侧重点不一样 JMeter更多的是对rest api进行压测 而JMH关注的粒度更细 它发现的更多的是某块性能糟点的代码 然后对优化方案进行基准测试对比。 12JMH官网地址http://openjdk.java.net/projects/code-tools/jmh/ 二 搭建JMH测试环境 引入JMH依赖 1234567891011 &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;1.34&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt; &lt;version&gt;1.34&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; idea中安装jmh的插件 由于测试过程中需要用到注解 所以请确保idea中打开了注解相关配置 Compiler –&gt; Annotation Processors —&gt; Enable annotation processing 业务类 123456789101112131415161718192021222324public class PS &#123; private static List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); static &#123; Random r = new Random(); for (int i = 0; i &lt; 1000; i++) &#123; nums.add(1000000 + r.nextInt(1000000)); &#125; &#125; public static void foreach() &#123; nums.forEach(v -&gt; isPrime(v)); &#125; public static void parallel() &#123; nums.stream().parallel().forEach(PS::isPrime); &#125; private static boolean isPrime(int num) &#123; for (int i = 2; i &lt;= num/2; i++) &#123; if (num % i == 0) return false; &#125; return true; &#125;&#125; 测试类 jmh的测试类一定要写在src/test目录下 不然是JMH的注解不会生效 另外jmh 的测试类需要放在某个包下 12345678910111213141516package test;import com.poi.tl.test.PS;import org.openjdk.jmh.annotations.*;public class PSTest &#123; @Benchmark //表示下面的方法要进行基准测试 @Warmup(iterations = 1, time = 3) //预热 由于JVM中对特定代码会存在优化 预热对测试结果很重要 iterations = 1 表示调用1次方法 time 表示下一次调用的时间间隔 单位(秒) @Fork(5) //指定线程数(多少个线程去调用下面的方式) @BenchmarkMode(Mode.Throughput) //基准测试的模式 Mode.Throughput 吞吐量 @Measurement(iterations = 1, time = 3) //总共测试多少次 public void testPS() &#123; PS.foreach(); &#125;&#125; 测试报告 ops/s 意思是说每秒可以执行多少个操作(调用多少个这样的方法) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# JMH version: 1.34# VM version: JDK 1.8.0_291, Java HotSpot(TM) 64-Bit Server VM, 25.291-b10# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home/jre/bin/java# VM options: -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=61645:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)# Warmup: 1 iterations, 3 s each# Measurement: 1 iterations, 3 s each# Timeout: 10 min per iteration# Threads: 1 thread, will synchronize iterations# Benchmark mode: Throughput, ops/time# Benchmark: test.PSTest.testPS# Run progress: 0.00% complete, ETA 00:00:30# Fork: 1 of 5# Warmup Iteration 1: 18.113 ops/sIteration 1: 18.699 ops/s# Run progress: 20.00% complete, ETA 00:00:28# Fork: 2 of 5# Warmup Iteration 1: 16.541 ops/sIteration 1: 16.696 ops/s# Run progress: 40.00% complete, ETA 00:00:21# Fork: 3 of 5# Warmup Iteration 1: 13.690 ops/sIteration 1: 13.818 ops/s# Run progress: 60.00% complete, ETA 00:00:14# Fork: 4 of 5# Warmup Iteration 1: 19.432 ops/sIteration 1: 19.370 ops/s# Run progress: 80.00% complete, ETA 00:00:07# Fork: 5 of 5# Warmup Iteration 1: 15.598 ops/sIteration 1: 15.824 ops/sResult &quot;test.PSTest.testPS&quot;: 16.881 ±(99.9%) 8.617 ops/s [Average] (min, avg, max) = (13.818, 16.881, 19.370), stdev = 2.238 CI (99.9%): [8.264, 25.499] (assumes normal distribution)# Run complete. Total time: 00:00:35REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up onwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorialexperiments, perform baseline and negative tests that provide experimental control, make surethe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.Do not assume the numbers tell you what you want them to tell.Benchmark Mode Cnt Score Error UnitsPSTest.testPS thrpt 5 16.881 ± 8.617 ops/sProcess finished with exit code 0 三 DisruptorDisruptor 性能极高 号称单机速度最快的MQ 12#disruptor主页https://lmax-exchange.github.io/disruptor/ Disruptor的特点 无锁，高并发，使用环形Buffer，直接覆盖(不用清除)旧的数据，降低GC频率，实现了基于事件的生产者消费者模式 RingBuffer 环形队列 RingBuffer的序号指向下一个可用的元素 采用数组实现 没有首尾指针 Disruptor开发步骤 1231、定义Event(队列中需要处理的元素)2、定义Event工厂(生产者 用于填充队列)3、定义EventHandler(消费者 用于处理容器中的元素) disruptor依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt;&lt;/dependency&gt; Event类 123456789101112131415public class LongEvent &#123; private long value; public void set(long value) &#123; this.value = value; &#125; @Override public String toString() &#123; return &quot;LogEvent&#123;&quot; + &quot;value=&quot; + value + &#x27;&#125;&#x27;; &#125;&#125; EventFactory类 12345678910public class LongEventFactory implements EventFactory&lt;LongEvent&gt; &#123; @Override public LongEvent newInstance() &#123; //之所以要用工厂去构建对象 而不是直接new对象 这里主要是考虑到效率问题 disruptor会在初始化的时候 会调用 // Event工厂 将整个环形队列给占满 这样 环形队列的内存基本就可以固定了，可以减少GC的频率 // 然后新来的值 只要覆盖原位置上的对象的属性即可 return new LongEvent(); &#125;&#125; EventHandler类 12345678910public class LongEventHandler implements EventHandler&lt;LongEvent&gt; &#123; public static long count = 0; @Override public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception &#123; count++; System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;]&quot; + event + &quot; 序号:&quot; + sequence); &#125;&#125; 测试类一 1234567891011121314151617181920212223242526public class Main01 &#123; public static void main(String[] args) &#123; //事件工厂 LongEventFactory factory = new LongEventFactory(); //环形队列的大小 环形队列的大小必须大于2 int bufferSize = 1024; //disruptor构造器 Disruptor&lt;LongEvent&gt; disruptor = new Disruptor&lt;LongEvent&gt;(factory, bufferSize, Executors.defaultThreadFactory()); //连接事件处理器 LongEventHandler 负责消费消息 disruptor.handleEventsWith(new LongEventHandler()); //启动disruptor disruptor.start(); //获取环形队列 RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer(); //获取序列号 long sequence = ringBuffer.next(); try &#123; //获取这个序列号上的元素 LongEvent event = ringBuffer.get(sequence); event.set(8888L); &#125;finally &#123; //发布消息到disruptor中 ringBuffer.publish(sequence); &#125; &#125;&#125; 测试类二 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Main02 &#123; public static void main(String[] args) &#123; //事件工厂 LongEventFactory factory = new LongEventFactory(); //环形队列的大小 环形队列的大小必须大于2 int bufferSize = 1024; //disruptor构造器 Disruptor&lt;LongEvent&gt; disruptor = new Disruptor&lt;LongEvent&gt;(factory, bufferSize, DaemonThreadFactory.INSTANCE); //连接事件处理器 disruptor.handleEventsWith(new LongEventHandler()); //启动disruptor disruptor.start(); //获取环形队列 RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer(); //发布消息 EventTranslator&lt;LongEvent&gt; translator = new EventTranslator&lt;LongEvent&gt;() &#123; @Override public void translateTo(LongEvent event, long sequence) &#123; event.set(8888L); &#125; &#125;; ringBuffer.publishEvent(translator); //这个其实就是允许你传一个参 将这个参数设置为event中的值 EventTranslatorOneArg&lt;LongEvent, Long&gt; translator_2 = new EventTranslatorOneArg&lt;LongEvent, Long&gt;() &#123; @Override public void translateTo(LongEvent event, long sequence, Long value) &#123; event.set(value); &#125; &#125;; ringBuffer.publishEvent(translator_2, 888L); //这个其实就是允许你传2个参 将这个参数设置为event中的值 EventTranslatorTwoArg&lt;LongEvent, Long, Long&gt; translator_3 = new EventTranslatorTwoArg&lt;LongEvent, Long, Long&gt;() &#123; @Override public void translateTo(LongEvent event, long sequence, Long arg0, Long arg1) &#123; event.set(arg0 + arg1); &#125; &#125;; ringBuffer.publishEvent(translator_3, 888L, 8882L); &#125;&#125; 测试类三 指定多个消费者 之前的测试类一和测试类2都是有一个消费者 另外还有就是消费者消费过程中的异常该如何去处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Main01 &#123; public static void main(String[] args) &#123; //事件工厂 LongEventFactory factory = new LongEventFactory(); //环形队列的大小 环形队列的大小必须大于2 int bufferSize = 1024; //disruptor构造器 Disruptor&lt;LongEvent&gt; disruptor = new Disruptor&lt;LongEvent&gt;(factory, bufferSize, Executors.defaultThreadFactory()); LongEventHandler h1 = new LongEventHandler(); LongEventHandler h2 = new LongEventHandler(); //为消费者指定异常处理器 disruptor.handleExceptionsFor(h1).with(new ExceptionHandler&lt;LongEvent&gt;() &#123; @Override //这个方法处理的是当消费消息的时候出了异常该如何处理 public void handleEventException(Throwable ex, long sequence, LongEvent event) &#123; ex.printStackTrace(); &#125; @Override //这个方法是用于当消费者线程启动的时候出现异常该如何处理 public void handleOnStartException(Throwable ex) &#123; System.out.println(&quot;Exception Start to Handle&quot;); &#125; @Override //这个方法是用于当消费者线程shutdown的时候出现异常该如何处理 public void handleOnShutdownException(Throwable ex) &#123; System.out.println(&quot;Exception Handle &quot;); &#125; &#125;); //连接事件处理器 disruptor.handleEventsWith(h1,h2); //启动disruptor disruptor.start(); //获取环形队列 RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer(); for (int i = 0; i &lt; 100; i ++) &#123; //获取序列号 long sequence = ringBuffer.next(); try &#123; //获取这个序列号上的元素 LongEvent event = ringBuffer.get(sequence); event.set(8888L); &#125;finally &#123; //发布消息到disruptor中 ringBuffer.publish(sequence); &#125; &#125; disruptor.shutdown(); &#125;&#125; Disruptor的生产者类型(ProducerType) ProducerType有两种模式 Producer.MULTI和Producer.SINGLE 默认是MULTI 表示多线程模式下生产sequence 如果确认是单线程生产者 可以指定为SINGLE WaitStrategy是disruptor的等待策略 默认有八种 支持自定义 BlockingWaitStrategy 通过线程阻塞的方式 等待生产者唤醒 被唤醒后 再循环检查依赖的sequence是否已被消费 BusySpinWaitStrategy 线程一直自旋等待 比较消耗CPU LiteBlockingWaitStrategy 轻量级的阻塞策略 也是通过线程阻塞的方式 等待生产者唤醒 与 BlockingWaitStrategy有些许差别 性能更好 LiteTimeoutBlockingWaitStrategy 与LiteBlockingWaitStrategy相比设置了线程阻塞的超时时间 超时后抛出异常 PhasedBackoffWaitStrategy 根据时间参数和传入的等待策略来决定使用哪种等待策略 TimeoutBlockingWaitStrategy 相对于BlockingWaitStrategy来说设置了等待时间 超过后抛异常 YieldingWaitStrategy 尝试100次然后线程调用Thread.yield()让出CPU SleepingWaitStrategy 线程先sleep 等待 下面是disruptor的构造器 123456public Disruptor( final EventFactory&lt;T&gt; eventFactory, final int ringBufferSize, final ThreadFactory threadFactory, final ProducerType producerType, //生产者类型 默认为MULTI final WaitStrategy waitStrategy)&#123;&#125; //WaitStrategy等待策略","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"算法入门(二)","slug":"算法-算法入门(二)","date":"2022-04-16T14:31:59.479Z","updated":"2022-04-21T13:53:13.028Z","comments":false,"path":"2022/04/16/算法-算法入门(二)/","link":"","permalink":"http://example.com/2022/04/16/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8(%E4%BA%8C)/","excerpt":"","text":"数据结构数据结构是存储、组织数据的方式 精心选择的数据结构可以带来更高的运行或者存储效率 数据结构是很多算法的载体 最基本的数据结构 数组 便于寻址(查找数据) 不便于增删数据 链表 便于增删数据 不便于寻址 数据结构设计的案例 假设有一个很大的数组需要很频繁的进行查询第i位置到第i+N位置的累加和 应该如何进行设计 来提高查询的效率 如果不进行数据结构的设计 那么就是每次都遍历一遍这个超大的数组 然后对其I位置和I+N位置进行求和，但是这样效率很低，不符合预期，这个时候我们可以进行数据结构的设计，通过合理的设计来提高查询的效率 有如下两个方案 方案一 准备一张表 表中有如下三个字段 left, right,value; left 是查询范围的左边位置的下标 right 则是右边位置的下标 value是left到right位置的累加和 eg:比如说有一个数组[1,0,-1,-2,3] 横轴代表right下标位置纵轴代表left下标位置 0 1 2 3 4 0 1 1 0 -2 1 1 – 0 -1 -3 0 2 – – -1 -3 0 3 – – – -2 1 4 – – – – 3 这张表最后持久化就需要存储大概n^2/2条记录 占的空间比较大 生成起来相对麻烦 方案二 其实用一个数组也可以实现类似的功能 可以再生成一个help数组 help的每个元素都是原数组从第0位置到第i位置的累加和 生成的help数组内容如下[1,1,0,-2,1] 着这样如果需要计算第2个位置到第4位置的累加和 只需要取help数的第4个位置(0~4位置的累加和) 1 减去help数组的第1个位置1 最后求得的和是0; 对比上面表格的结果发现也是正确的 方案二相比方案一所需的存储空间更少(N) 此外生成help数组也更简单 但是它的读取性能比方案一差(它需要做计算) 如果查询很频繁则不适用 面试题 我们知道Math.random() 能够等概率的返回01范围内的某个值 那么对于任何一个值x(x的取值范围为01 不包含1) Math.random()方法出现的随机数小于x的概率就是x 那么现在希望使得Math.random()出现随件小于x的概率变成x的平方 应该如何做 1234567891011121314151617181920212223242526272829303132//测试Math.random 出现的随机数小于x的概率 x取值0~1public class Client &#123; public static void main(String[] args) &#123; int testCount = 10000000; int count = 0; double x = 0.17; for (int i = 0; i&lt; testCount; i++) &#123; if (Math.random() &lt; x) &#123; count++; &#125; &#125; System.out.println((double) count / testCount); &#125;&#125;//测试Math.random 出现的随机数小于x的概率为x的平方 x取值0~1public class Client &#123; public static void main(String[] args) &#123; int testCount = 10000000; int count = 0; double x = 0.17; for (int i = 0; i&lt; testCount; i++) &#123; //Math.random() 执行两次取大值 其实就是说执行一次的时候概率是x 那么执行两次的结果都比x小的概率就是x的平方 double c = Math.max(Math.random(), Math.random()); if (c &lt; x) &#123; count++; &#125; &#125; System.out.println((double) count / testCount); System.out.println(x*x); &#125;&#125; 面试题 现在已知一个函数f1能够提供15之间整数的等概率的一个返回 需要提供一个能够在17之间整数等概率返回的函数 这种题目的解题思路都是利用给定函数构造出一个能提供0-1之间整数等概率返回的一个函数 这个函数只等概率返回0 和 1 然后利用二进制的思想构造出概率为0~N的等概率的函数 但是我们要求的是要能够得到1到N的等概率返回 所以还需要将0-N等概率返回的函数构造成0到N-1等概率返回的函数 然后再加1即可以得到1到N等概率返回的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Client &#123; public static void main(String[] args) &#123; //测试f1等概率 int[] array = new int[5]; for(int i = 0; i &lt; 10000; i++) &#123; int index = f1() - 1; array[index]++; &#125; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(i+1 + &quot;出现了&quot; + array[i] + &quot;次&quot;); &#125; System.out.println(); System.out.println(&quot;=======================================&quot;); System.out.println(); //测试f3等概率 array = new int[8]; for(int i = 0; i &lt; 10000; i++) &#123; int index = f3(); array[index]++; &#125; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(i + &quot;出现了&quot; + array[i] + &quot;次&quot;); &#125; System.out.println(); System.out.println(&quot;=======================================&quot;); System.out.println(); //测试1-7等概率返回 array = new int[7]; for(int i = 0; i &lt; 10000; i++) &#123; int index = f5(); array[index-1]++; &#125; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(i+1 + &quot;出现了&quot; + array[i] + &quot;次&quot;); &#125; &#125; //返回1到5等概率返回 public static int f1()&#123; return (int)(Math.random()*5 + 1); &#125; //构造出一个新的函数 等概率返回0和1 public static int f2() &#123; int num; do &#123; num = f1(); &#125;while (num == 3); //f1 只能取值1 2 3 4 5 小于3 则是1 和 2 大于 3 则是 4 和 5 return num &lt; 3 ? 0: 1; &#125; public static int f3() &#123; //f2() &lt;&lt; 2 只有两个可能的值 用二进制表示未100 和 000 //f2() &lt;&lt; 1 也只有两个可能的值 分别是 10 和00 //(f2() &lt;&lt; 2) + (f2() &lt;&lt; 1) + f2() 就可以等概率的返回000到111之间的数也就是等概率返回0-7 return (f2() &lt;&lt; 2) + (f2() &lt;&lt; 1) + f2(); &#125; //因为f3()只能等概率返回0-7的函数 这里需要先构造出等概率返回0-6的函数 public static int f4()&#123; int num; do&#123; num = f3(); &#125;while (num == 7); //等于7就重做 return num; &#125; //等概率返回1-7的函数 也就是最终的目标函数 public static int f5()&#123; return f4() + 1; &#125;&#125; 面试题 已知给定一个函数按固定概率返回0或1 (注意这里的0和1并不是等概率的) 现在需要设计一个函数等概率返回0和1 12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; int[] array = new int[2]; for(int i = 0; i &lt; 10000; i++) &#123; int count = f2(); array[count]++; &#125; System.out.println(array[0]); System.out.println(array[1]); &#125; //给定一个函数f() 以百分之84的概率返回0 百分之16的概率返回1 public static int f() &#123; return Math.random() &lt; 0.84 ? 0 : 1; &#125; //利用函数f()设计一个函数f2 等概率返回0和1 public static int f2() &#123; //设返回0的概率为P 那么返回1的概率应该是1-P //那么要想返回0与1的概率相等那么只能是调用两次f函数的时候 一次返回0一次返回1 那么他们的概率就是P*(1-P) int n1 = 0; int n2 = 0; do&#123; n1 = f(); n2 = f(); &#125;while (n1 == n2); if (n1 == 0) &#123; return 0; &#125; else &#123; return 1; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"}]},{"title":"多线程与高并发(五)","slug":"高并发-多线程与高并发五","date":"2022-04-14T13:28:34.456Z","updated":"2022-04-17T08:36:57.726Z","comments":false,"path":"2022/04/14/高并发-多线程与高并发五/","link":"","permalink":"http://example.com/2022/04/14/%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BA%94/","excerpt":"","text":"一 线程池java提供的线程池主要有两种 ThreadPoolExecutor ForkJoinPool 利用分治的思想 将一个大任务 拆成N个小任务放到线程池中进行处理 类似于CompletableFuture的allOf 二 ThreadPoolExecutor源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//构造器public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;&#125;//核心方法public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn&#x27;t, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; 线程拒绝策略 jdk默认提供了4种拒绝策略 AbortPolicy 线程池满了以后直接抛异常 CallerRunsPolicy 由调用者(调用pool.execute() 或者pool.submit()方法的线程)自己去执行 DiscardPolicy 丢弃这个任务 DiscardOldestPolicy 丢弃最老的任务 实际业务中 一般都会采用自定义的拒绝策略 而不用java自带的拒绝策略 常见的线程池 Executors.newSingleThreadExecutor() 只有一个线程的线程池 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; Executors.newCachedThreadPool() 这个实际上就相当于来一个任务 就创建一个线程 它的核心线程数是0 任务队列是SynchronousQueue 这个队列的容量是0 放不下任何数据 所以来一个任务 就会创建一个任务 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; Executors.newFixedThreadPool() 固定线程数的线程池 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; Executors.newScheduledThreadPool() 定时器的线程池 内部是用的DelayedWorkQueue 这个queue和DelayQueue效果是一样 1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 用法示例 123456789101112public class Client &#123; public static void main(String[] args) &#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(4); //这个表示每个5分钟执行下一个任务 第一个任务执行的时间向当前时间推后0秒(也就是立即执行) executorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;执行任务&quot;); &#125; &#125;, 0, 300, TimeUnit.SECONDS); &#125;&#125; 并发与并行的区别 并发强调的是多个任务同时提交 并行强调的是多个任务同时执行 并行是并发的一个子集 也可以说并行是真正的并发(多个CPU执行 每个CPU执行不同的任务) 而并发 一个CPU 不同时间片执行不同的任务 也可以称之为并发 自定义拒绝策略案例 12345678910111213141516171819public class Client &#123; public static void main(String[] args) &#123; ThreadPoolExecutor pool = new ThreadPoolExecutor(4, 10, 30, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(100), new MyRejectedPolicy()); &#125;&#125;//自定义拒绝策略class MyRejectedPolicy implements RejectedExecutionHandler &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; //打日志 log.into(xxx r xxx) //对被拒绝的任务进行转储 redis、kafka这些 //可以利用executor做重试操作等等 具体的要看具体的业务要求 &#125;&#125; 三 ThreadPoolExecutor 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175//1、ctl 可以看做一个int类型的数字 高三位表示线程池状态 低29位表示worker数量private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));//2、COUNT_BITS private static final int COUNT_BITS = Integer.SIZE - 3;//线程池允许的最大线程数 这个值不会变更了 2^29 - 1private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;//线程池的五种状态 //RUNNING 11100000000000000000000000000000 111 表示RUNNING状态 线程池正常运行private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;//SHUTDOWN 00000000000000000000000000000000 000 表示SHUTDOWN状态 调用线程池的shutDown方法private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//STOP 00100000000000000000000000000000 001 表示STOP状态 调用线程池shutdownNow方法private static final int STOP = 1 &lt;&lt; COUNT_BITS;//TIDYING 01000000000000000000000000000000 010 表示TIDYING状态private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//TERMINATED 01100000000000000000000000000000 011 表示TERMINATED状态 整个线程池生命周期结束了private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;//获取线程池的状态 ~CAPACITY = 11100000000000000000000000000000 低29位都为0 屏蔽worker的数量private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;//获取线程池worker的数量 CAPACITY = 00011111111111111111111111111111 高三位都是0 屏蔽线程池状态private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;//根据线程池的状态rs 和 worker的数量 生成新的ctl的值 所以用的是|运算 这样就能保证 高三位和低29位不会相互影响private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;//c 表示ctl s 表示线程池状态 线程池状态小于ctlprivate static boolean runStateLessThan(int c, int s) &#123; return c &lt; s;&#125;//c 表示ctl s 表示线程池状态 线程池状态大于等于ctlprivate static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s;&#125;//判断线程池的状态是不是Running状态 只有Running状态的ctl才是一个负数 最高位为1 其余的线程池状态都是正数(高位大于0)private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125;//构造方法 只是一些属性的设置public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125;//提交任务(核心方法)public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //获取ctl int c = ctl.get(); //获取线程池中worker的数量 如果小于核心线程数(核心线程不够) if (workerCountOf(c) &lt; corePoolSize) &#123; //表示要加一个worker 且是加的核心线程 如果加成功了返回 if (addWorker(command, true)) return; //核心线程未满 //核心线程没有加成功 重新获取最新的ctl c = ctl.get(); &#125; //判断线程池是否正处于RUNNING状态且任务正常的加入到任务队列中了 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //重新获取新的ctl值 if (!isRunning(recheck) &amp;&amp; remove(command)) //如果这个时候线程池状态不是RUNNING状态(证明执行过shutdown命令)需要先移除刚刚提交的任务 并且执行拒绝策略 //执行拒绝策略 reject(command); else if (workerCountOf(recheck) == 0) //这里之所以要判断线程数是否为0 主要是因为线程池的核心线程数是允许为0的 addWorker(null, false); //加一个空的任务进来 &#125; //如果线程池不是运行态 或者进入任务队列失败 则尝试创建worker 执行任务(这里就利用到最大线程数了) else if (!addWorker(command, false)) reject(command);//如果最大线程数没加成功 执行拒绝策略&#125;private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: //外层自旋 for (;;) &#123; //获取ctl int c = ctl.get(); //获取线程状态 int rs = runStateOf(c); //线程池状态大于SHUTDOWN时 直接返回false if (rs &gt;= SHUTDOWN &amp;&amp; //线程池状态等于SHUTDOWN时 且 firstTask不为null时直接返回false //线程池状态等于SHUTDOWN时 且队列为空 直接返回false ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; //内存自旋 for (;;) &#123; //计算worker数量 int wc = workerCountOf(c); //worker数量超过容量的时候 直接返回false 如果worker是核心线程 则比较核心线程数 大于等于核心线程数返回false //如果worker是非核心线程 则比较最大线程数 如果大于等于最大线程数 则返回false if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //线程数自增 if (compareAndIncrementWorkerCount(c)) //直接跳出外层循环 break retry; //如果没有加成功 则重新拿最新的ctl c = ctl.get(); // if (runStateOf(c) != rs) //计算线程的状态 如果发生改变了 continue retry; //继续外层循环 // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask);//包装一个woker Worker构造器底层会创建一个Thread final Thread t = w.thread; //firstTask对应的线程 if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; //获取锁 mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); //重新计算线程池的状态 //当线程池状态是RUNNING时或者 线程池状态是SHUTDOWN但是firstTask为空时 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; //worker已经调用过start方法了 抛出异常 if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //把worker加进来 workers.add(w); // private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); //计算线程池中线程的数量 int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; //证明worker加成功了 workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; //启动这个线程 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 四 ForkJoinPoolForkJoin线程池可以执行一种特殊的任务 它可以把一个大任务拆分成N个小任务并行执行 然后再将多个小任务的结果合并起来 组成大任务的执行结果，ForkJoin其实就是一种分治的思想，ForkJoin线程池是JDK1.7之后引入的。 ForkJoin框架提供了两个主要的子类用于实现ForkJoin任务 12RecursiveAction：用于没有返回结果的任务。RecursiveTask ：用于有返回结果的任务。 ForkJoin示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Client &#123; static int[] num = new int[1000000]; static final int MAX_NUM = 5000; static Random r = new Random(); static &#123; for (int i = 0; i &lt; num.length; i++) &#123; num[i] = r.nextInt(100); &#125; System.out.println(Arrays.stream(num).sum()); System.out.println(&quot;====================================&quot;); &#125; public static void main(String[] args) throws Exception &#123; ForkJoinPool pool = new ForkJoinPool(); AddTask task = new AddTask(0, num.length); pool.execute(task); // Long sum = task.get(); 都可以 Long sum = task.join(); //都可以 System.out.println(sum); &#125; static class AddTask extends RecursiveTask&lt;Long&gt; &#123; int start, end; AddTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; if (end - start &lt;= MAX_NUM) &#123; long sum = 0L; for (int i = start; i &lt; end; i++) &#123; sum += num[i]; &#125; System.out.println(&quot;from: &quot; + start + &quot; to:&quot; + end + &quot;=&quot; + sum); return sum; &#125; else &#123; int middle = start + (end - start) / 2; AddTask subTask_1 = new AddTask(start, middle); AddTask subTask_2 = new AddTask(middle, end); subTask_1.fork(); subTask_2.fork(); //子任务的结果合并 Long val_1 = subTask_1.join(); Long val_2 = subTask_2.join(); return val_1 + val_2; &#125; &#125; &#125;&#125;","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"算法入门(一)","slug":"算法-算法入门(一)","date":"2022-04-11T12:46:07.213Z","updated":"2022-04-16T14:39:58.895Z","comments":false,"path":"2022/04/11/算法-算法入门(一)/","link":"","permalink":"http://example.com/2022/04/11/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8(%E4%B8%80)/","excerpt":"","text":"一 位运算 &amp; 按位与 只有当操作符两边都是1的时候 &amp;的结果才为1 否则为0 0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1 | 按位或 表示有一个操作符两边有一个为1 |的结果为1 否则为0 0|0=0； 0|1=1； 1|0=1； 1|1=1 ^ 按位异或 值不同则为1 值相同则为0 0^0=0； 0^1=1； 1^0=1； 1^1=0 ~ 按位取反 即将0变成1 将1变成0 ~1=0； ~0=1； &gt;&gt; 右移 将一个数的二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃 每右移一位相当于除以2 &gt;&gt;&gt; 无符号右移 将一个数的二进制位全部右移若干位 高位全部补0 &lt;&lt; 将一个运算对象的各二进制位全部左移若干位左边的二进制位丢弃，右边补0 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2 java中负数的表示方法最高为是1 然后其他位由其正数按位取反 然后再加1 得到的就是相应负数的二进制表示 比如-1它的32位表达法应该是首先符号位为1 然后剩下的31位先取反 11111111111111111111111111111110 然后再加1 最后得到11111111111111111111111111111111 这个值 面试题 用32位二进制数表示一个int类型的数 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; int num = -1; String str2 = print(num); String str = Integer.toBinaryString(num); System.out.println(str2); System.out.println(str); &#125; private static String print(int num) &#123; StringBuilder sb = new StringBuilder(); for(int i = 31; i &gt;= 0; i--) &#123; String c = (num &amp; (1 &lt;&lt; i)) == 0 ? &quot;0&quot; : &quot;1&quot;; sb.append(c); &#125; return sb.toString(); &#125;&#125; 面试题 求1!+2!+3!+…+N! 123456789101112131415161718public static void main(String[] args) throws Exception&#123; System.out.println(sumFactorial(4));&#125;private static int sumFactorial(int num) &#123; int sum = 0; for (int i = 1; i&lt;= num; i++) &#123; sum = sum + factorial(i); &#125; return sum;&#125;private static int factorial(int num) &#123; if (num == 1) &#123; return 1; &#125; return num*factorial(num-1);&#125; 非递归实现 123456789private static int sumFactorial(int num) &#123; int sum = 0; int factorial = 1; for (int i = 1; i&lt;= num; i++) &#123; factorial = factorial*i; sum += factorial; &#125; return sum;&#125; 二 常见排序实现2.1 选择排序 算法描述 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 动图演示 代码实现 1234567891011121314151617181920212223public static void main(String[] args) throws Exception&#123; int[] array = &#123;1, 4,3, 5,2,9,8,6,2,0,-1,-3, 10&#125;; selectSort(array); for (int i = 0 ; i&lt; array.length; i++) &#123; System.out.print(array[i] + &quot;\\t&quot;); &#125;&#125;public static void selectSort(int[] array) &#123; if (array == null || array.length &lt;2) return; for (int i = 0; i &lt; array.length; i++) &#123; int minIndex = i; for (int j = i+1; j &lt; array.length; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; int tmp = array[i]; array[i] = array[minIndex]; array[minIndex] = tmp; &#125;&#125; 2.2 冒泡排序 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数 针对所有的元素重复以上的步骤，除了最后一个 重复步骤1~3，直到排序完成 动图演示 代码实现 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception&#123; int[] array = &#123;1, 4,3, 5,2,9,-5, 8,6,2,0,-1,-3, 10, 7&#125;; bubbleSort(array); for (int i = 0 ; i&lt; array.length; i++) &#123; System.out.print(array[i] + &quot;\\t&quot;); &#125;&#125;public static void bubbleSort(int[] array) &#123; if (array == null || array.length &lt; 2) return; boolean status = false; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j+1]) &#123; int tmp = array[j+1]; array[j+1] = array[j]; array[j] = tmp; status = true; &#125; &#125; if (!status)&#123; break; &#125; &#125;&#125; 2.3 插入排序 算法描述 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 动图演示 代码提示 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; int[] array = &#123;1, 5, -10, 8, 2, -5, 5, 9, 12, 3, -1&#125;; insertSort(array); System.out.println(Arrays.toString(array)); &#125; public static void insertSort(int[] array) &#123; if (array == null || array.length &lt; 2) return; for (int i = 1; i &lt; array.length; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; array[j+1]; j --) &#123; int tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; &#125; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"}]},{"title":"多线程与高并发(四)","slug":"高并发-多线程与高并发四","date":"2022-04-11T12:36:21.683Z","updated":"2022-04-14T14:13:50.653Z","comments":false,"path":"2022/04/11/高并发-多线程与高并发四/","link":"","permalink":"http://example.com/2022/04/11/%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9B%9B/","excerpt":"","text":"面试题一有两个线程 要求 一个线程依次打印1-26 另一个线程从A-Z 两个线程要交替输出 wait/notify 利用wait和notify来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) throws Exception&#123; Object lock = new Object(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; for (int i = 1; i &lt;= 26; i++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; :&quot; + i); lock.notify(); lock.wait(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; lock.notifyAll(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; for (int i = 65; i &lt;= 90; i++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; :&quot; + (char)i); lock.notify(); lock.wait(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; lock.notifyAll(); &#125; &#125; &#125;); t1.start(); Thread.sleep(10); t2.start(); t1.join(); t2.join();&#125; LockSupport 123456789101112131415161718192021222324252627282930313233private static Thread t1 = null;private static Thread t2 = null;public static void main(String[] args) throws Exception&#123; t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 26; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; :&quot; + i); LockSupport.unpark(t2); LockSupport.park(); &#125; &#125; &#125;); t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 65; i &lt; 91; i++) &#123; LockSupport.park(); System.out.println(Thread.currentThread().getName() + &quot; :&quot; + (char)i); LockSupport.unpark(t1); &#125; &#125; &#125;); t2.start(); Thread.sleep(10); t1.start(); t1.join(); t2.join();&#125; 利用condition 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void main(String[] args) throws Exception&#123; Lock lock = new ReentrantLock(); Condition c1 = lock.newCondition(); Condition c2 = lock.newCondition(); t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; lock.lock(); try &#123; for (int i = 1; i &lt;= 26; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; :&quot; + i); c2.signal(); c1.await(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;); t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; lock.lock(); try &#123; for (int i = 65; i &lt; 91; i++) &#123; c2.await(); System.out.println(Thread.currentThread().getName() + &quot; :&quot; + (char)i); c1.signal(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;); t2.start(); Thread.sleep(10); t1.start(); t1.join(); t2.join();&#125; 利用Exchange实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) throws Exception&#123; Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; String flag = &quot;t1&quot;; for (int i = 1; i &lt;= 26; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; :&quot; + i); flag = exchanger.exchange(flag); if (&quot;t2&quot;.equals(flag)) &#123; flag = exchanger.exchange(flag); &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; String flag = &quot;t2&quot;; for (int i = 65; i &lt; 91; i++) &#123; flag = exchanger.exchange(flag); //t2 System.out.println(Thread.currentThread().getName() + &quot; :&quot; + (char)i); if (&quot;t1&quot;.equals(flag)) &#123; flag = exchanger.exchange(flag); &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t2.start(); t1.start(); t1.join(); t2.join(); &#125; 利用volatile 12345678910111213141516171819202122232425262728293031323334353637383940414243private static volatile boolean flag = false; public static void main(String[] args) throws Exception&#123; t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; for (int i = 1; i &lt;= 26; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; :&quot; + i); flag = true; while (flag)&#123; &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; for (int i = 65; i &lt; 91; i++) &#123; flag = false; while (!flag)&#123; &#125; System.out.println(Thread.currentThread().getName() + &quot; :&quot; + (char)i); &#125; flag = false; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t2.start(); t1.start(); t1.join(); t2.join(); &#125; 利用blockingQueue 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) throws Exception&#123; LinkedBlockingQueue&lt;String&gt; q1 = new LinkedBlockingQueue&lt;&gt;(); LinkedBlockingQueue&lt;String&gt; q2 = new LinkedBlockingQueue&lt;&gt;(); t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; for (int i = 1; i &lt;= 26; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; :&quot; + i); q2.put(&quot;a&quot;); q1.take(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; for (int i = 65; i &lt; 91; i++) &#123; q2.take(); System.out.println(Thread.currentThread().getName() + &quot; :&quot; + (char)i); q1.put(&quot;a&quot;); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t2.start(); t1.start(); t1.join(); t2.join(); &#125; CompletableFuture CompletableFuture这个类主要是用于对多个Future任务进行管理的一个类，它提供了很多的针对多任务(Future)管理的API 如allof、anyof、join、cancel等 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Client &#123; public static void main(String[] args) throws Exception&#123; CompletableFuture&lt;Double&gt; cf_1 = CompletableFuture.supplyAsync(() -&gt; priceOfTM()); CompletableFuture&lt;Double&gt; cf_2 = CompletableFuture.supplyAsync(() -&gt; priceOfTB()); CompletableFuture&lt;Double&gt; cf_3 = CompletableFuture.supplyAsync(() -&gt; priceOfJD()); //CompletableFuture.allOf(cf_1, cf_2, cf_3).join(); //这句话的意思是等着3个future都执行完 但这个API有个缺点没办法直接获取执行结果 CompletableFuture.supplyAsync(() -&gt; priceOfTM()).thenAcceptAsync(new Consumer&lt;Double&gt;() &#123; @Override public void accept(Double result) &#123; //对一个任务的结果继续进行处理 System.out.println(&quot;TM上的价格 = &quot; + result); &#125; &#125;).join(); &#125; //模拟上天猫上查询价格 private static Double priceOfTM() &#123; delay(); return 10.0; &#125; //模拟上淘宝上查询价格 private static Double priceOfTB() &#123; delay(); return 12.0; &#125; //模拟上京东上查询价格 private static Double priceOfJD() &#123; delay(); return 14.0; &#125; private static void delay() &#123; int time = new Random().nextInt(3000); try &#123; Thread.sleep(time); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"状态模式","slug":"设计模式-状态模式","date":"2022-04-10T12:57:38.455Z","updated":"2022-04-10T13:22:50.290Z","comments":false,"path":"2022/04/10/设计模式-状态模式/","link":"","permalink":"http://example.com/2022/04/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"状态模式(State Pattern) 也叫状态机模式 允许对象在内部状态发生改变时改变它的行为 状态模式中 行为是由它的状态来决定的，在不同的状态下会有不同的行为 状态模式和责任链模式很像状态模式的角色分为 环境类角色(Context) 定义客户需要的接口 内部维护一个当前状态的实例 抽象状态角色(IState) 定义该状态下的行为 可以有一个或多个行为 具体状态角色(ConcreteState) 具体实现该状态对应的行为 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface State &#123; //行为1 void doSomething_01(); //行为2 void doSomething_02();&#125;public class StateA implements State &#123; @Override public void doSomething_01() &#123; System.out.println(&quot;A状态下执行doSomething_01&quot;); &#125; @Override public void doSomething_02() &#123; System.out.println(&quot;A状态下执行doSomething_02&quot;); &#125;&#125;public class StateB implements State &#123; @Override public void doSomething_01() &#123; System.out.println(&quot;B状态下执行doSomething_01&quot;); &#125; @Override public void doSomething_02() &#123; System.out.println(&quot;B状态下执行doSomething_02&quot;); &#125;&#125;public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; //行为1 public void doSomething_01() &#123; state.doSomething_01(); &#125; //行为2 public void doSomething_02() &#123; state.doSomething_02(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Context c = new Context(new StateA()); //Context c = new Context(new StateA()); c.doSomething_01(); c.doSomething_02(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"java中的原子操作","slug":"FQA-java中的原子操作","date":"2022-04-10T12:48:30.298Z","updated":"2022-04-10T12:56:03.333Z","comments":false,"path":"2022/04/10/FQA-java中的原子操作/","link":"","permalink":"http://example.com/2022/04/10/FQA-java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/","excerpt":"","text":"问题 java中哪些操作是原子操作 回答 除了long和double之外的基本类型的赋值操作，因为long和double类型是64位的，所以它们的操作在32位机器上不算原子操作，而在64位的机器上是原子操作。 所有引用reference的赋值操作 java.concurrent.Atomic *包中所有类的原子操作 Java使用锁和自旋CAS实现原子操作 面试题 多线程条件下 下面的代码 调用set1、set2、check方法 会打印Error吗 12345678910111213141516171819public class P1 &#123; private long b = 0; public void set1() &#123; b = 0; &#125; public void set2() &#123; b = -1; &#125; public void check() &#123; System.out.println(b); if (0 != b &amp;&amp; -1 != b) &#123; //这个&amp;&amp;操作并不是原子操作 很有可以能 b=-1时(有线程执行了set2方法) 进行判断 0!=b 然后有其他线程执行了 set1方法 将b的值修改成0 然后再判断-1 != b 最后会打出Error System.err.println(&quot;Error&quot;); &#125; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132public static void main(final String[] args) &#123; final P1 v = new P1(); // 线程 1：设置 b = 0 final Thread t1 = new Thread() &#123; public void run() &#123; while (true) &#123; v.set1(); &#125; &#125;; &#125;; t1.start(); // 线程 2：设置 b = -1 final Thread t2 = new Thread() &#123; public void run() &#123; while (true) &#123; v.set2(); &#125; &#125;; &#125;; t2.start(); // 线程 3：检查 0 != b &amp;&amp; -1 != b final Thread t3 = new Thread() &#123; public void run() &#123; while (true) &#123; v.check(); &#125; &#125;; &#125;; t3.start(); &#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"maven deploy报错","slug":"FAQ-maven执行deploy报错","date":"2022-04-10T12:42:42.098Z","updated":"2022-04-10T12:47:08.946Z","comments":false,"path":"2022/04/10/FAQ-maven执行deploy报错/","link":"","permalink":"http://example.com/2022/04/10/FAQ-maven%E6%89%A7%E8%A1%8Cdeploy%E6%8A%A5%E9%94%99/","excerpt":"","text":"问题 在执行mvn deploy 推包到私服时报错 1Could not transfer artifact xxxxx : Return code is: 500 原因 建议查看私服的服务器的磁盘是不是满了","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"备忘录模式","slug":"设计模式-备忘录","date":"2022-04-10T11:02:20.133Z","updated":"2022-04-10T12:36:32.627Z","comments":false,"path":"2022/04/10/设计模式-备忘录/","link":"","permalink":"http://example.com/2022/04/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"","text":"备忘录模式(Memento Pattern) 又叫做快照模式或者令牌模式 指在不破坏封装的前提下 捕获一个对象的内部状态 并在对象之外保存这个状态，备忘录一般用来做快照或者存盘 备忘录有点像命令模式都具备处理undo和redo的功能 备忘录基本角色 发起人角色 负责创建一个备忘录 记录自身需要保存的状态 具备状态的回滚功能(需要进行备忘录/存盘/快照的对象) 备忘录角色 用于存储发起人角色的内部状态 且可以防止发起人角色以外的对象进行访问 备忘录管理员角色 负责存储、提供和管理备忘录 示例 使用备忘录实现草稿箱的功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//备忘录角色public class Memento extends Editor &#123; protected Memento(String title, String content, String imgs) &#123; super(title, content, imgs); &#125;&#125;//发起人角色@Data@AllArgsConstructorpublic class Editor &#123; private String title; private String content; private String imgs; //将当前对象的状态存储到备忘录中 public Memento saveToMemento() &#123; return new Memento(title, content, imgs); &#125; public void recover(Memento memento) &#123; if (memento != null) &#123; this.content = memento.getContent(); this.imgs = memento.getImgs(); this.title = memento.getTitle(); &#125; &#125; @Override public String toString() &#123; return &quot;Editor&#123;&quot; + &quot;title=&#x27;&quot; + title + &#x27;\\&#x27;&#x27; + &quot;, content=&#x27;&quot; + content + &#x27;\\&#x27;&#x27; + &quot;, imgs=&#x27;&quot; + imgs + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;//备忘录管理员角色public class Box &#123; private final Stack&lt;Memento&gt; stack = new Stack&lt;&gt;(); public Memento pop()&#123; return stack.pop(); //出栈 &#125; public void push(Memento memento) &#123; stack.push(memento); &#125;&#125;//测试public class Client &#123; public static void main(String[] args) &#123; //创建草稿箱(充当备忘录管理员角色) Box box = new Box(); //创建一个编辑器(充当发起人角色) Editor editor = new Editor(&quot;Hello World&quot;, &quot;This is content&quot;, &quot;This is image&quot;); //模拟编辑器的自动保存 Memento memento = editor.saveToMemento(); box.push(memento); System.out.println(&quot;初始信息 = &quot; + editor); //模拟修改信息 并存盘 editor.setTitle(&quot;Hello World 2&quot;); memento = editor.saveToMemento(); box.push(memento); System.out.println(&quot;第一次修改 = &quot; + editor); //模拟第二次修改 editor.setContent(&quot;This is content2&quot;); memento = editor.saveToMemento(); box.push(memento); System.out.println(&quot;第二次修改 = &quot; + editor); //模拟第一次恢复 editor.recover(box.pop()); System.out.println(&quot;第一次恢复 = &quot; + editor); //模拟第二次恢复 editor.recover(box.pop()); System.out.println(&quot;第二次恢复 = &quot; + editor); //模拟第三次恢复 editor.recover(box.pop()); System.out.println(&quot;第三次恢复 = &quot; + editor); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"多线程与高并发(三)","slug":"高并发-多线程与高并发三","date":"2022-04-09T08:34:07.628Z","updated":"2022-04-14T14:13:32.732Z","comments":false,"path":"2022/04/09/高并发-多线程与高并发三/","link":"","permalink":"http://example.com/2022/04/09/%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%89/","excerpt":"","text":"一 容器概览 Vector和HashTable 这两个容器是java 1.0自带的 它们都是线程安全的 因为其方法都是同步方法(加了synchorinized关键字) ConcurrentHashMap 它主要改善的是并发读的效率 其实ConcurrentHashMap写的效率不见得比HashTable或者SynchorinizedMap高 但是读的效率比它们高很多 TreeMap treeMap底层实现是红黑树 CopyOnWriteList 写时复制 CopyOnWriteList源码 从源码上看add方法是线程安全的 并且每增加一个元素会进行一次数组拷贝 读的时候是没有加锁的 通过这种写时复制的机制来保证了整个容器的线程安全 同时呢 由于读的时候没有加锁所以它的读效率很高 一般copyOnWriteList 适用于读操作频繁写操作不频繁的多线程环境 1234567891011121314151617181920212223242526272829303132public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;final void setArray(Object[] a) &#123; array = a; //这是一个原子操作 所以也是线程安全的&#125;@SuppressWarnings(&quot;unchecked&quot;)private E get(Object[] a, int index) &#123; return (E) a[index];&#125;/** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; return get(getArray(), index);&#125; Queue 对于队列的数据插入 一般用offer而不用add offer添加成功后会返回true 如果没成功会返回false 而add如果不成功则会抛异常 peek则是读取队列头部的数据 而poll则是删除头部的数据 并把这个数据返回 测试 123456789101112131415161718public class Client &#123; public static void main(String[] args) throws Exception &#123; Queue&lt;String&gt; strs = new ConcurrentLinkedQueue&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; strs.offer(&quot;a&quot; + i); &#125; System.out.println(strs.size()); System.out.println(strs.peek()); System.out.println(strs.size()); System.out.println(strs.poll()); System.out.println(strs.size()); &#125;&#125; 下面是ConcurrentLinkedQueue的部分源码利用了cas操作 保证了线程安全 对于这个队列来说 不存在阻塞的说法 本身队列就是无界的 1234567891011121314151617181920212223242526272829public boolean offer(E e) &#123; checkNotNull(e); //如果e为空抛异常 final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); for (Node&lt;E&gt; t = tail, p = t;;) &#123; //死循环 t被设置成为了队尾 Node&lt;E&gt; q = p.next; if (q == null) &#123; //如果q为null 那证明确实p是队尾 // p is last node if (p.casNext(null, newNode)) &#123; //cas原子操作 把入参设置为新的队尾 // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become &quot;live&quot;. if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK.//如果成功了再利用cas把tail指向newNode return true; &#125; // Lost CAS race to another thread; re-read next &#125; else if (p == q) //自己的下一个节点指向了自己 // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125; &#125; BlockingQueue 阻塞队列也是线程安全的队列 下面是BlockingQueue的部分源码 从源码可以看到 offer方法是加了锁的 但是它不是阻塞方法 如果超过容量了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; if (count.get() == capacity) return false; int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; if (count.get() &lt; capacity) &#123; //超过容量不写入返回c为-1 返回false enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); return c &gt;= 0; &#125;public E take() throws InterruptedException &#123; //获取队尾的数据 E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); //尝试获取takeLock这把锁 如果获取不到 只要当前线程进行中断(执行interput方法) 这个获取锁的进程可以被打断 抛出InterruptedException异常 try &#123; while (count.get() == 0) &#123; //表示队列中没有数据了 这里就是take阻塞的核心方法 notEmpty.await(); //notEmpty是一把takeLock这把锁的的一个条件(队列)放在这个队列里进行等待 &#125; x = dequeue(); //从队列的头部删除并返回这个元素(head) c = count.getAndDecrement(); //count的值减一 if (c &gt; 1) notEmpty.signal(); //c&gt;1 那么证明此时count为0 队列已经空了 condition(notEmpty)的signal方法 可以唤醒所有被notEmpty阻塞住的线程(执行到notEmpty.await();这行代码的线程可以继续向下执行了) &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x; &#125;//这个方法也是阻塞方法public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; //拿到put锁 final AtomicInteger count = this.count; putLock.lockInterruptibly(); //和take一样 try &#123; /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ while (count.get() == capacity) &#123; //当队列满了 notFull.await(); //notFull 是put锁的一个Condition(队列) 阻塞 &#125; enqueue(node); //进入队列 c = count.getAndIncrement(); //返回当前的count if (c + 1 &lt; capacity) notFull.signal(); //队列以满 唤醒所有执行到notFull.await(); 的线程 &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); &#125; DelayQueue 装在DelayQueue中的元素需要实现Delayed接口 这个队列不是以元素入队的顺序进行出队的 而是以任务Delay的时间进行排序出队的 DelayQueue的底层实现实际上是一个优先队列 PriorityQueue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Client &#123; public static void main(String[] args) throws Exception &#123; DelayQueue&lt;Task&gt; queue = new DelayQueue&lt;&gt;(); long now = System.currentTimeMillis(); Task t1 = new Task(now + 10000, &quot;t1&quot;); Task t2 = new Task(now + 20000, &quot;t2&quot;); Task t3 = new Task(now + 15000, &quot;t3&quot;); Task t4 = new Task(now + 35000, &quot;t4&quot;); Task t5 = new Task(now + 30000, &quot;t5&quot;); Task t6 = new Task(now + 25000, &quot;t6&quot;); queue.add(t1); queue.add(t2); queue.add(t3); queue.add(t4); queue.add(t5); queue.add(t6); for (int i = 0; i &lt; 6; i++) &#123; System.out.println(queue.take()); &#125; &#125;&#125;class Task implements Delayed &#123; private Long runningTime; private String name; public Task(Long runningTime, String name) &#123; this.runningTime = runningTime; this.name = name; &#125; @Override public long getDelay(TimeUnit unit) &#123; return unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; @Override public int compareTo(Delayed o) &#123; if (this.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123; return -1; &#125; else if (this.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; @Override public String toString() &#123; return &quot;Task&#123;&quot; + &quot;runningTime=&quot; + runningTime + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; SynchronousQueue 这个队列每次只能存一个信息 主要是用于线程通信的 一个线程通过调用put方法把数据put进来 另外一个线程去take 功能类似于Exchanger 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) throws Exception &#123; SynchronousQueue&lt;String&gt; queue = new SynchronousQueue&lt;&gt;(); Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; while (true) &#123; System.out.println(queue.take()); //会依次打印aaa bbb ccc &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t.start(); queue.put(&quot;aaa&quot;); //不能用add 或 offer这种非阻塞的方法 queue.put(&quot;bbb&quot;); queue.put(&quot;ccc&quot;); &#125;&#125; TransferQueue 它也是用来做线程之间的数据交换(通信的) 但它比transfer更强大 1234567891011121314151617181920212223242526public class Client &#123; public static void main(String[] args) throws Exception &#123; TransferQueue&lt;String&gt; queue = new LinkedTransferQueue&lt;&gt;(); Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; while (true) &#123; System.out.println(queue.take()); Thread.sleep(1000); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t.start(); queue.transfer(&quot;aaa&quot;); //这个方法与put方法的区别 会等着另一个线程take到了之后 再走下一步 如果这里换成put打印的顺序就不一样了 queue.transfer(&quot;bbb&quot;); queue.transfer(&quot;ccc&quot;); System.out.println(&quot;=====================&quot;); &#125;&#125;","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"命令模式","slug":"设计模式-命令模式","date":"2022-04-08T13:09:14.334Z","updated":"2022-04-08T15:45:18.604Z","comments":false,"path":"2022/04/08/设计模式-命令模式/","link":"","permalink":"http://example.com/2022/04/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"命令模式主要适用于以下场景 现实语义中具备命令的操作 如命令菜单、shell命令等等 需要抽象出等待执行的行为 比如撤销(Undo)和恢复(Redo) 需要支持命令宏(即命令组合操作) 请求的调用者和接收者需要解耦的时候 比如Thread的start和run方法的实现 就是这种情况 示例 模拟餐厅点餐的场景 这个场景没有实现Undo 和 Redo的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//模拟不同的菜系(粤菜、鲁菜、苏菜等) 也就是命令模式中的命令接口public interface ICuisine &#123; void cook();&#125;//厨师接口 也就是命令的执行者接口public interface ICook &#123; void doCooking();&#125;//粤菜 也就是具体的命令对象public class GuangDongICuisine implements ICuisine &#123; //厨师 也就是命令模式中的命令执行者角色 Invoker private ICook cook; public GuangDongICuisine(ICook cook)&#123; this.cook = cook; &#125; @Override public void cook() &#123; cook.doCooking(); &#125;&#125;//苏菜public class JiangSuICuisine implements ICuisine &#123; private ICook cook; public JiangSuICuisine(ICook cook)&#123; this.cook = cook; &#125; @Override public void cook() &#123; cook.doCooking(); &#125;&#125;//鲁菜public class ShanDongICuisine implements ICuisine &#123; private ICook cook; public ShanDongICuisine(ICook cook)&#123; this.cook = cook; &#125; @Override public void cook() &#123; cook.doCooking(); &#125;&#125;//广东厨师 也就是命令具体的Invokerpublic class GuangDongCook implements ICook &#123; @Override public void doCooking() &#123; System.out.println(&quot;广东厨师烹饪粤菜&quot;); &#125;&#125;//江苏厨师public class JiangSuCook implements ICook &#123; @Override public void doCooking() &#123; System.out.println(&quot;江苏厨师烹饪苏菜&quot;); &#125;&#125;//山东厨师public class ShanDongCook implements ICook &#123; @Override public void doCooking() &#123; System.out.println(&quot;山东厨师烹饪鲁菜&quot;); &#125;&#125;//店小二 命令接受者角色public class DianXiaoEr &#123; private List&lt;ICuisine&gt; list = new ArrayList&lt;&gt;(); //点餐 public void order(ICuisine cuisine)&#123; list.add(cuisine); &#125; public synchronized void placeOrder() &#123; for (ICuisine cuisine : list) &#123; cuisine.cook(); &#125; list.clear(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; ICuisine guangdongCuisine = new GuangDongICuisine(new GuangDongCook()); ICuisine shandongCuisine = new ShanDongICuisine(new ShanDongCook()); ICuisine jiangsuCuisine = new JiangSuICuisine(new JiangSuCook()); //点菜 DianXiaoEr xiaoEr = new DianXiaoEr(); xiaoEr.order(guangdongCuisine); xiaoEr.order(shandongCuisine); xiaoEr.order(jiangsuCuisine); //上菜 xiaoEr.placeOrder(); &#125;&#125; 示例2 模拟文本编辑器的操作 包括恢复操作 这里省略了一个角色 Invoker 因为不需要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//命令接口public interface Command &#123; String exec(); String recover();&#125;//具体的命令角色public class Add implements Command &#123; private String origin; private String text; public Add(String origin, String text)&#123; this.origin = origin; this.text = text; &#125; @Override public String exec() &#123; return origin + text; &#125; @Override public String recover() &#123; return origin; &#125;&#125;public class Copy implements Command &#123; private String text; public Copy(String text)&#123; this.text = text; &#125; @Override public String exec() &#123; return text + text; &#125; @Override public String recover() &#123; return text; &#125;&#125;public class Delete implements Command &#123; private String origin; private int index; public Delete(String origin, Integer index)&#123; this.origin = origin; this.index = index; &#125; @Override public String exec() &#123; return origin.substring(0, index); &#125; @Override public String recover() &#123; return origin; &#125;&#125;//命令接收者public class Editor &#123; private String origin; private List&lt;Command&gt; list = new ArrayList&lt;&gt;(); public synchronized String execute(Command command) &#123; list.add(command); return command.exec(); &#125; public synchronized String recover() &#123; if (list.size() == 0) &#123; return origin; &#125; Command command = list.get(list.size() - 1); list.remove(list.size() - 1); String result = command.recover(); origin = result; return result; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; Editor editor = new Editor(); String result = editor.execute(new Add(&quot;1&quot;, &quot;123&quot;)); System.out.println(&quot;ADD result = &quot; + result); result = editor.execute(new Add(result, &quot;456&quot;)); System.out.println(&quot;ADD result = &quot; + result); result = editor.execute(new Copy(result)); System.out.println(&quot;Copy result = &quot; + result); result = editor.execute(new Delete(result, 10)); System.out.println(&quot;DELETE result = &quot; + result); for (int i = 0; i &lt; 5; i ++) &#123; System.out.println(&quot;第 &quot; + i+ &quot; 次Ctrl+Z 结果为&quot; + editor.recover()); &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"多线程与高并发(二)","slug":"高并发-多线程与高并发二","date":"2022-04-04T15:44:56.738Z","updated":"2022-04-09T08:30:35.183Z","comments":false,"path":"2022/04/04/高并发-多线程与高并发二/","link":"","permalink":"http://example.com/2022/04/04/%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BA%8C/","excerpt":"","text":"一 ExchangerExchanger是用来进行两个线程之间的数据交换 如果需要超过两个线程 则会阻塞 12345678910111213141516171819202122232425262728293031323334353637383940public class Client &#123; public static void main(String[] args) throws Exception &#123; Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); new Thread(() -&gt; &#123; String s = &quot;T1&quot;; try &#123; s = exchanger.exchange(s); //执行到这里先阻塞 会与t2进行数据交换 此时s = T2 &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + s); &#125;, &quot;t1&quot;).start(); Thread.sleep(1000); //休眠的目的是为了保证t1 一定先执行 new Thread(() -&gt; &#123; String s = &quot;T2&quot;; try &#123; s = exchanger.exchange(s); //执行到这里先阻塞 然后进行t1 与 t2之间的数据交换 此时 s 值为T1 s = exchanger.exchange(s); //执行到这里先阻塞 然后与t3进行数据交换 此时s = T3 &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + s); &#125;, &quot;t2&quot;).start(); Thread.sleep(1000); //休眠的目的是为了保证t2 一定先执行 new Thread(() -&gt; &#123; String s = &quot;T3&quot;; try &#123; s = exchanger.exchange(s); //执行到这里先阻塞 然后与t3进行数据交换 此时s = T1 &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + s); &#125;, &quot;t3&quot;).start(); &#125;&#125; 二 LockSupportlockSupport 功能和Object的wait和notify类似 但是比wait 和 notify更灵活 123456789101112131415161718192021222324252627public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; sleep(1000); System.out.println(i); if (i == 5) &#123; LockSupport.park(); //阻塞当前线程 &#125; &#125; &#125;); t.start(); sleep(8000); System.out.println(&quot;time after 8 second&quot;); LockSupport.unpark(t); //解封txianc t.join(); &#125; private static void sleep(long millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 面试题一 实现一个容器 提供两个方法 add、size 写两个线程 线程1添加10个元素到容器中 线程2实现监控元素的个数 当个数到5个时 线程2给出提示并结束 volatile加锁的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Client &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; list.add(i+&quot;&quot;); System.out.println(i); sleep(1000); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; while (true) &#123; if (list.size() ==5) &#123; System.out.println(&quot;容器的size是有5个了 退出t2线程&quot;); break; &#125; &#125; System.out.println(&quot;t2 退出完成&quot;); &#125;); t1.start(); t2.start(); t1.join(); t2.join(); &#125; private static void sleep(long millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ArrayList&lt;T&gt; &#123; private volatile int size = 0; private Object[] elements = new Object[16]; public synchronized void add(T t) &#123; if (size &gt;= elements.length) &#123; elements = Arrays.copyOf(elements, elements.length * 2); &#125; elements[size] = t; size++; &#125; public int size() &#123; return size; &#125;&#125; wait 和 notify 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Client &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Object lock = new Object(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; synchronized (lock) &#123; if (i == 5) &#123; try &#123; lock.notify(); lock.wait(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; list.add(i+&quot;&quot;); sleep(1000); System.out.println(i); &#125; &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; synchronized (lock) &#123; try &#123; if (list.size() != 5) &#123; lock.wait(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; lock.notify(); &#125; System.out.println(&quot;t2 退出&quot;); &#125;); t2.start(); sleep(1000); t1.start(); t1.join(); t2.join(); &#125; private static void sleep(long millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ArrayList&lt;T&gt; &#123; private int size = 0; private Object[] elements = new Object[16]; public void add(T t) &#123; if (size &gt;= elements.length) &#123; elements = Arrays.copyOf(elements, elements.length * 2); &#125; elements[size] = t; size++; &#125; public int size() &#123; return size; &#125;&#125; LcokSupport实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Client &#123; private static Thread t1; private static Thread t2; public static void main(String[] args) throws Exception &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); t2 = new Thread(() -&gt; &#123; LockSupport.park(); //阻塞 LockSupport.unpark(t1); //t1 解封 System.out.println(&quot;t2 退出&quot;); &#125;); t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; LockSupport.unpark(t2); //t2解封 LockSupport.park(); //t1阻塞 &#125; list.add(i+&quot;&quot;); sleep(1000); System.out.println(i); &#125; &#125;); t2.start(); sleep(1000); t1.start(); t2.join(); t1.join(); &#125; private static void sleep(long millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ArrayList&lt;T&gt; &#123; private int size = 0; private Object[] elements = new Object[16]; public void add(T t) &#123; if (size &gt;= elements.length) &#123; elements = Arrays.copyOf(elements, elements.length * 2); &#125; elements[size] = t; size++; &#125; public int size() &#123; return size; &#125;&#125; Semaphore实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class Client &#123; private static Thread t1; private static Thread t2; public static void main(String[] args) throws Exception &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Semaphore semaphore = new Semaphore(1, true); t2 = new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(&quot;t2 退出&quot;); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); &#125; &#125;); t1 = new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 5; i++) &#123; list.add(i+&quot;&quot;); //sleep(1000); System.out.println(i); &#125; semaphore.release(); try &#123; t2.join(); semaphore.acquire(); for (int i = 5; i &lt; 10; i++) &#123; list.add(i+&quot;&quot;); //sleep(1000); System.out.println(i); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); t1.start(); t2.start(); t2.join(); t1.join(); &#125; private static void sleep(long millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ArrayList&lt;T&gt; &#123; private int size = 0; private Object[] elements = new Object[16]; public void add(T t) &#123; if (size &gt;= elements.length) &#123; elements = Arrays.copyOf(elements, elements.length * 2); &#125; elements[size] = t; size++; &#125; public int size() &#123; return size; &#125;&#125; 面试题二 写一个固定容量的同步容器 拥有put/get方法 以及getCount方法 能够支持2个生产者线程 以及10个消费者线程阻塞调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Client &#123; private static Thread t1; private static Thread t2; public static void main(String[] args) throws Exception &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); t2 = new Thread(() -&gt; &#123; try &#123; for (int i = 0; i &lt; 20; i++) &#123; list.put(i+&quot;&quot;); sleep(1000); System.out.println(&quot;t2 add &quot; + i); &#125; System.out.println(&quot;t2 退出&quot;); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;t1 &quot; + list.get()); sleep(1000); &#125; System.out.println(&quot;t1 退出&quot;); &#125;); t2.start(); sleep(1000); t1.start(); t2.join(); t1.join(); &#125; private static void sleep(long millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ArrayList&lt;T&gt; &#123; private int size = 0; private Object[] elements = new Object[10]; private final Object lock = new Object(); public void put(T t) &#123; synchronized (lock) &#123; while (size == elements.length) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; elements[size] = t; size++; lock.notifyAll(); &#125; public Object get() &#123; synchronized (lock) &#123; while (size == 0) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; size--; lock.notifyAll(); return elements[size]; &#125; &#125; public int size() &#123; return size; &#125;&#125; 利用ReentrantLock的Condition可以实现更加精确的控制 在生产者 唤醒的时候 可以只叫醒消费者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class Client &#123; private static Thread t1; private static Thread t2; public static void main(String[] args) throws Exception &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); t2 = new Thread(() -&gt; &#123; try &#123; for (int i = 0; i &lt; 20; i++) &#123; list.put(i+&quot;&quot;); sleep(1000); System.out.println(&quot;t2 add &quot; + i); &#125; System.out.println(&quot;t2 退出&quot;); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;t1 consumer &quot; + list.get()); sleep(1000); &#125; System.out.println(&quot;t1 退出&quot;); &#125;); t2.start(); sleep(1000); t1.start(); t2.join(); t1.join(); &#125; private static void sleep(long millis) &#123; try &#123; Thread.sleep(millis); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class ArrayList&lt;T&gt; &#123; private int size = 0; private Object[] elements = new Object[10]; private final Lock lock = new ReentrantLock(); private final Condition producer = lock.newCondition(); //生产者的锁 condition 的本质就是锁的等待队列 一个condition代表锁有一个等待队列 private final Condition consumer = lock.newCondition(); //消费者的锁 public void put(T t) &#123; try &#123; lock.lock(); while (size == elements.length) &#123; try &#123; producer.await(); //进入生产者队列等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; elements[size] = t; size++; consumer.signalAll(); //唤醒所有的消费者线程 &#125;finally &#123; lock.unlock(); &#125; &#125; public Object get() &#123; try &#123; lock.lock(); while (size == 0) &#123; try &#123; consumer.await(); //进入消费者队列等待 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; size--; producer.signalAll(); //唤醒所有生产者线程 return elements[size]; &#125;finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; return size; &#125;&#125; 之前提到过的ReentrantLock、CountDownLatch、CyclicBarrier、phaser、ReadWriteLock这些锁底层都是基于AbstractQueuedSynchronizer(AQS)来实现的 AQS的底层的核心实际上就是CAS操作加一个队列 二 ThreadLocalThreadLocal 从字面意义上来说就是线程本地变量 是属于线程自己独有的。其他线程是看不到的 先看一个示例 在下面的示例中t2获得的值已经被t1所修改了 12345678910111213141516171819202122232425262728293031323334353637public class Client &#123; private static volatile Person person = new Person(); public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; sleep(1000); person.name = &quot;lisi&quot;; sleep(3000); &#125;); Thread t2 = new Thread(() -&gt; &#123; sleep(2000); System.out.println(person.name); //打印的会是lisi 而不是zhangsan sleep(1000); &#125;); t1.start(); t2.start(); t1.join(); t2.join(); &#125; public static void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Person &#123; public String name = &quot;zhangsan&quot;;&#125; 从下面的例子中可以很清晰的看到被ThreadLocal修饰的属性 是不会被其他线程所识别的 也就是所谓的线程独占 其他线程不会拿到本线程的这个变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Client &#123; private static ThreadLocal&lt;Person&gt; local = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws Exception &#123; local.set(new Person()); //在main线程设置了一个变量 sleep(1000); Thread t1 = new Thread(() -&gt; &#123; sleep(1000); System.out.println(&quot;t1 = &quot; + local.get()); //null Person p = new Person(); //t1 线程自己设置了一个TheadLocal类型的p变量 p.name = &quot;王五&quot;; local.set(p); System.out.println(&quot;t1 = &quot; + local.get().name); //王五 local.remove(); //切记ThreadLocal使用完成后一定要记得remove!! 否则在线程池的环境下 下一次请求很有可能读到上一个请求(如果他们从线程池中拿到的是同一个线程的话)遗留的数据 &#125;); Thread t2 = new Thread(() -&gt; &#123; sleep(3000); System.out.println(&quot;t2 = &quot; + local.get()); //null &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(&quot;main = &quot; + local.get().name); //zhangsan local.remove(); //切记ThreadLocal使用完成后一定要记得remove!! &#125; public static void sleep(int millis) &#123; try &#123; Thread.sleep(millis); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Person &#123; public String name = &quot;zhangsan&quot;;&#125; 使用ThreadLocal关键之处还是在于，使用完毕要记得remove。特别是在线程池中使用的时候。（否则会等到下一次set的时候才替换掉value–&gt;作为key的threadLocal为同一个所以是替换） ThreadLocal源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//set方法public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //获取当前线程的 ThreadLocal.ThreadLocalMap threadLocals 变量 if (map != null) map.set(this, value); else createMap(t, value);&#125;//map.set(this, value); 源码private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; //table是ThreadLocal的成员变量 是一个Entry[] int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; //遍历Entry[] ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; //如果相等证明之前已经设置过了 所以需要覆盖 e.value = value; return; &#125; if (k == null) &#123; //这种情况是有可能在GC之后导致key为null的情况 GC后会导致threadLocalMap的key为null,但value不为null的情况 replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); //会进行扩容等操作&#125;static class ThreadLocalMap &#123; /** * Entry是一个弱引用 所以一旦发生gc Entry对象的k就会为null 但是value不会为null * 之所以设计成为弱引用 就是为了方式某些线程一直存在的时候(比如线程池) ThreadLocal能被回收掉 * 不至于造成内存泄漏(所谓内存泄漏就是指这一块内存 永远无法被垃圾回收器回收掉 那么这块内存就相当于是泄漏了) * 内存泄漏和内存溢出是不一样的 */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125;&#125; ThreadLocal的一个最典型的应用就是Spring的声明式事务 Spring为了保证同一个请求的对数据库访问的事务操作 它必须要保证在这个请求(线程)中 每次访问数据库都是拿的同一个连接 只有这样才能保证这次请求的数据库操作都在同一个事务中 如果跨了数据库连接 是没办法保证事务性的 所以Spring为了保证同一个请求 都能拿到同一个数据库连接 就会用到ThreadLocal 它会将数据库连接放到ThreadLocal中 测试ThreadLocal在gc后在引发的threadLocalMap的key为null,但value不为null的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Client &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InterruptedException &#123; Thread t = new Thread(()-&gt;test(&quot;abc&quot;,false)); t.start(); t.join(); System.out.println(&quot;--gc后--&quot;); Thread t2 = new Thread(() -&gt; test(&quot;def&quot;, true)); t2.start(); t2.join(); &#125; private static void test(String s,boolean isGC) &#123; try &#123; ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;&gt;(); threadLocal.set(s); threadLocal = null;//失去对threadLocal的强引用 ,help gc if (isGC) &#123; System.gc(); &#125; Thread t = Thread.currentThread(); Class&lt;? extends Thread&gt; clz = t.getClass(); Field field = clz.getDeclaredField(&quot;threadLocals&quot;); field.setAccessible(true); Object threadLocalMap = field.get(t); Class&lt;?&gt; tlmClass = threadLocalMap.getClass(); Field tableField = tlmClass.getDeclaredField(&quot;table&quot;); tableField.setAccessible(true); Object[] arr = (Object[]) tableField.get(threadLocalMap); for (Object o : arr) &#123; if (o != null) &#123; Class&lt;?&gt; entryClass = o.getClass(); Field valueField = entryClass.getDeclaredField(&quot;value&quot;); Field referenceField = entryClass.getSuperclass().getSuperclass().getDeclaredField(&quot;referent&quot;); valueField.setAccessible(true); referenceField.setAccessible(true); System.out.println(String.format(&quot;弱引用key:%s,值:%s&quot;, referenceField.get(o), valueField.get(o))); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 强、软、弱、虚四种引用 java中的引用类型分为四种分别是强引用、软引用、弱引用和虚引用 强引用 一般的java赋值操作都是强引用 强引用一般指的是只要有一个引用指向了该对象 该对象就不会被回收 12345678910111213141516171819202122232425//强引用测试 public class Client &#123; public static void main(String[] args) throws Exception &#123; Person person = new Person(); System.gc(); //建议系统gc Thread.sleep(5000); System.out.println(&quot;第一次gc结束&quot;); person = null; System.gc(); //建议系统gc System.out.println(&quot;第二次gc结束&quot;); //只有在第二次gc的时候 才会调用person的finalize() 方法 System.in.read(); &#125;&#125;class Person &#123; public String name = &quot;zhangsan&quot;; //一般不要重写finalize方法 这里只是为了做测试 jvm在进行gc回收对象的时候 是会调用这个方法的 @Override protected void finalize() throws Throwable &#123; System.out.println(&quot;person 被回收了&quot;); super.finalize(); &#125;&#125; 软引用 当一个对象被一个软引用所指向的时候 只有系统内存不够了 该软引用锁指向的对象才会被回收 如果内存充足 即便没有引用指向这个对象 这个对象也不会被回收 软引用一般用作缓存 内存充足条件下测试 123456789101112131415161718192021222324252627public class Client &#123; public static void main(String[] args) throws Exception &#123; Person p1 = new Person(); SoftReference&lt;Person&gt; m = new SoftReference&lt;&gt;(p1); System.out.println(m.get()); System.gc(); Thread.sleep(1000); System.out.println(m.get()); p1 = null; System.gc(); System.out.println(m.get()); //get的对象还是原来p1的地址 m = null; //即便是把m都设置为null 也不会触发person回收 &#125;&#125;class Person &#123; public String name = &quot;zhangsan&quot;; //一般不要重写finalize方法 这里只是为了做测试 jvm在进行gc回收对象的时候 是会调用这个方法的 @Override protected void finalize() throws Throwable &#123; System.out.println(&quot;person 被回收了&quot;); super.finalize(); &#125;&#125; 内存不足条件下测试 这个案例的测试需要设置这三个jvm参数 -Xms20m -Xmx20m -Xmn1m 至于为啥要控制年轻代的大小暂时没想明白 可能是让对象直接进入老年代吧 1234567891011121314151617181920212223242526272829303132public class Client &#123; public static void main(String[] args) throws Exception &#123; SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024*1024*10]); System.out.println(m.get()); System.gc(); Thread.sleep(1000); System.out.println(m.get()); showCurrentMemoryInfo(); byte[] b = new byte[15*1024*1024]; System.out.println(m.get()); //这次会变成null &#125; private static void showInitialMemoryInfo() &#123; MemoryMXBean mbean = ManagementFactory.getMemoryMXBean(); System.out.println(&quot;最大可用内存:&quot; + toMB(mbean.getHeapMemoryUsage().getMax()));// for (MemoryPoolMXBean mxBean : ManagementFactory.getMemoryPoolMXBeans()) &#123;// System.out.println(&quot;Name:&quot; + mxBean.getName()// + &quot;,Type:&quot; + mxBean.getType()// + &quot;,Size:&quot; + toMB(mxBean.getUsage().getMax()));// &#125; &#125; private static String toMB(long bytes) &#123; return bytes / 1024 / 1024 + &quot;MB&quot;; &#125; private static void showCurrentMemoryInfo() &#123; String str = &quot;当前最大可用内存:&quot; + toMB(Runtime.getRuntime().maxMemory()) + &quot;,当前空闲内存:&quot; + toMB(Runtime.getRuntime().freeMemory()); System.out.println(str); &#125;&#125; 弱引用 弱引用 只要发生gc 弱引用所指向的对象就会被回收 当然 如果这个对象还被另外一个变量强引用依赖了 是不会被回收的 1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) throws Exception &#123; WeakReference&lt;M&gt; m = new WeakReference&lt;&gt;(new M()); System.out.println(m.get()); System.gc(); System.out.println(m.get()); //null 弱引用被回收了 M m1 = new M(); WeakReference&lt;M&gt; weakReference = new WeakReference&lt;&gt;(m1); System.out.println(weakReference.get()); System.gc(); System.out.println(weakReference.get()); //不为null 虽然它是弱引用 但是m1这个对象还有一个强引用 所以无法回收 ThreadLocal&lt;M&gt; t1 = new ThreadLocal&lt;&gt;(); t1.set(new M()); t1.remove(); &#125;&#125;class M&#123;&#125; 所以说为了防止内存泄漏的情况发生 使用ThreadLocal时一定要记得remove 虚引用 虚引用主要是管理堆外内存的 虚引用的用法不多 一般是研发虚拟机会用到","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"ASM应用入门","slug":"FAQ-ASM应用入门","date":"2022-04-03T00:55:10.188Z","updated":"2022-04-06T13:16:27.763Z","comments":false,"path":"2022/04/03/FAQ-ASM应用入门/","link":"","permalink":"http://example.com/2022/04/03/FAQ-ASM%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8/","excerpt":"","text":"ASM官网 ASM是用来操作和分析java字节码的框架 它可以用来修改class文件 或者动态的生成class。一个class文件基本上由以下几个部分组成 class文件组成部分 Magic 该项存放了一个java类文件的魔数(magic number) 和版本信息 一个java class文件的前4个字节被称之为它的魔数。每个正确的java class文件都是以0xCAFEBABE开头的 这样保证了java虚拟机能够很轻松的分辨出Java文件和非java文件 Version 该项存放了java 类文件的版本信息 它对于一个java文件具有重要意义 因为java一直在发展 所以类文件的格式也在不断的变化中 类文件的版本信息让虚拟机知道如何去读取和处理该类文件 Constant Pool 该项存放了类中各种文字字符串、类名、方法名、接口名、final变量、以及对外部类的引用信息 虚拟机必须为每一个被装载的类维护一个常量池 常量池的大小占到了整个类文件大小的60% Access flag 该项指明了该文件中定义的是类 还是接口(一个class文件只能有一个类 或者接口) 同时还指名了类和接口的访问标志 如 public、private、abstract 等 This class 指向表示该类全限定名称的字符串常量的指针 Super class 指向表示父类全限定名称的字符串常量的指针 Interface 一个指针组 存放了该类或父类实现的所有接口名称的字符串常量指针 以上三项(This class 、Super class、interface) 特别是前两项 在我们用ASM 从已有类派生新类时一般需要修改 将类名称修改为子类名称 将父类该为派生类前的类名称 如有必要 增加新的实现接口 Fields 该项对类或接口中声明的字段进行了细致的描述 需要注意的是 fields列表中仅列出来了本类或接口中的字段 并不包括从超类和父接口继承而来的字段 Methods 该项对类或接口中声明的方法进行了细致的描述 例如方法的名称 参数 返回值等 需要注意的是methods列表存放的仅仅只是本类或本接口中的方法 并不包括从超类或父接口继承而来的方法 使用ASM进行AOP编程 通常需要调整Method中的指令来实现 Class attributes 该项存放了该类文件中类或接口所定义的属性的基本信息 如果需要详细的了解java class文件的组成部分 请阅读《java 虚拟机规范》这本书 也可以去oracle官网去找 首先找到javaSE 的documentation 然后继续下拉 找到Language and VM 然后找到你想要了解的jdk版本的虚拟机指引 找到第4章 The Class File Format 这里面有最新的java 类文件组成的说明 ASM读取class文件示例 这里面用到了visitor设计模式 123456789101112131415161718192021222324252627282930313233343536373839package com.poi.tl.test;import org.objectweb.asm.*;import static jdk.internal.org.objectweb.asm.Opcodes.ASM4;public class ClassPrinter extends ClassVisitor &#123; public ClassPrinter() &#123; super(ASM4); &#125; public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; System.out.println(name + &quot; extends &quot; + superName + &quot; &#123;&quot;); &#125; public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) &#123; System.out.println(&quot; &quot; + desc + &quot; &quot; + name); return null; &#125; public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; System.out.println(&quot; &quot; + name + desc); return null; &#125; public void visitEnd() &#123; System.out.println(&quot;&#125;&quot;); &#125; public static void main(String[] args) throws Exception&#123; ClassPrinter cp = new ClassPrinter(); //利用classReader 将Client.class 读进来 利用visitor 对这个类文件进行一些处理 ClassReader cr = new ClassReader(ClassPrinter.class.getClassLoader().getResourceAsStream(&quot;com/poi/tl/test/Client.class&quot;)); cr.accept(cp, 0); &#125;&#125; ASM生成class文件示例 1234567891011121314151617181920212223242526272829303132import org.objectweb.asm.ClassWriter;import java.util.Arrays;import static org.objectweb.asm.Opcodes.*;public class ClassWriterTest &#123; public static void main(String[] args) throws Exception&#123; ClassWriter cw = new ClassWriter(0); cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, &quot;pkg/Comparable&quot;, null, &quot;java/lang/Object&quot;, null); cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, &quot;LESS&quot;, &quot;I&quot;, null, new Integer(-1)).visitEnd(); cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, &quot;EQUAL&quot;, &quot;I&quot;, null, new Integer(0)).visitEnd(); cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, &quot;GREATER&quot;, &quot;I&quot;, null, new Integer(1)).visitEnd(); cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, &quot;compareTo&quot;, &quot;(Ljava/lang/Object;)I&quot;, null, null).visitEnd(); cw.visitEnd(); byte[] b = cw.toByteArray(); Class c = new MyClassLoader().defineClass(&quot;pkg.Comparable&quot;, b); //生成一个class System.out.println(c.getName()); Arrays.stream(c.getMethods()).forEach(m -&gt; &#123; System.out.println(m.getName()); &#125;); &#125;&#125;class MyClassLoader extends ClassLoader &#123; public Class defineClass(String name, byte[] b) &#123; return defineClass(name, b, 0, b.length); &#125;&#125; 利用ASM模拟修改class 下面的例子对Man这个类的方法做了一点处理 12345678910111213141516171819202122232425262728293031323334public class AopTest &#123; public static void main(String[] args) throws Exception &#123; ClassReader cr = new ClassReader(Man.class.getClassLoader().getResourceAsStream(&quot;com/poi/tl/test/Man.class&quot;)); ClassWriter cw = new ClassWriter(0); ClassVisitor cv = new ClassVisitor(ASM4, cw) &#123; @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123; MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions); return new MethodVisitor(ASM4, mv) &#123; @Override public void visitCode() &#123; //当读到class文件的方法之后 做一些处理 visitMethodInsn(INVOKESTATIC, &quot;proxy&quot;, &quot;before&quot;, &quot;()V&quot;, false); super.visitCode(); &#125; &#125;; &#125; &#125;; cr.accept(cv, 0); byte[] bytes = cw.toByteArray(); String path = System.getProperty(&quot;user.dir&quot;); FileOutputStream fos = new FileOutputStream(new File(path + &quot;/poi-tl-test/target/classes/com/poi/tl/test/Man_0.class&quot;)); fos.write(bytes); fos.flush(); fos.close(); &#125;&#125;public class Man &#123; public void eat() &#123; System.out.println(&quot;这个在吃饭&quot;); &#125;&#125; 生成的Man_0的class文件反编译后的结果如下","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"访问者模式","slug":"设计模式-访问者模式","date":"2022-04-02T14:40:23.430Z","updated":"2022-04-06T12:42:39.025Z","comments":false,"path":"2022/04/02/设计模式-访问者模式/","link":"","permalink":"http://example.com/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"访问者模式是一种将数据结构与数据操作分离的设计模式 它适用于在内部组成模块固定的情况 访问者模式可以在不改变数据结构的条件下 定义这些元素的新的操作。下面的例子模拟的是组装台式机的时候 针对不同的客户(visitor)给与不同的优惠策略 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class Client &#123; public static void main(String[] args) throws Exception &#123; Student student = new Student(); Teacher teacher = new Teacher(); Computer c1 = new Computer.ComputerBuilder() .setCpu(new Cpu(&quot;英特尔酷睿i5处理器&quot;, 1000)) .setBoard(new Board(&quot;华硕主板&quot;, 1500)) .setMemory(new Memory(&quot;金士顿16G内存条&quot;, 1200)).build(); Computer c2 = new Computer.ComputerBuilder() .setCpu(new Cpu(&quot;英特尔酷睿i7处理器&quot;, 1400)) .setBoard(new Board(&quot;微星主板&quot;, 1200)) .setMemory(new Memory(&quot;ADATA16G内存条&quot;, 1000)).build(); System.out.println(&quot;学生买电脑 配置:&quot; + c1.getConfig() + &quot; 价格 : &quot; + c1.getPrice(student)); System.out.println(&quot;老师买电脑 配置:&quot; + c1.getConfig() + &quot; 价格 : &quot; + c1.getPrice(teacher)); System.out.println(&quot;================分隔线========================================&quot;); System.out.println(&quot;学生买电脑 配置:&quot; + c2.getConfig() + &quot; 价格 : &quot; + c2.getPrice(student)); System.out.println(&quot;老师买电脑 配置:&quot; + c2.getConfig() + &quot; 价格 : &quot; + c2.getPrice(teacher)); &#125;&#125;@Datapublic class Computer &#123; private Cpu cpu; private Memory memory; private Board board; private Computer() &#123; &#125; //获得电脑的价格 public int getPrice(Visitor visitor) &#123; return cpu.getPrice(visitor) + memory.getPrice(visitor) + board.getPrice(visitor); &#125; public String getConfig() &#123; return &quot;CPU : &quot; + cpu.getName() + &quot;\\t 内存 : &quot; + memory.getName() + &quot;\\t 主板 : &quot; + board.getName(); &#125; public static class ComputerBuilder &#123; private final Computer computer = new Computer(); public ComputerBuilder setCpu(Cpu cpu) &#123; computer.setCpu(cpu); return this; &#125; public ComputerBuilder setMemory(Memory memory) &#123; computer.setMemory(memory); return this; &#125; public ComputerBuilder setBoard(Board board) &#123; computer.setBoard(board); return this; &#125; public Computer build() &#123; return computer; &#125; &#125;&#125;//电脑元件interface ComputerPart &#123; //获取元件的价格 int getPrice(Visitor visitor);&#125;//不同的客户interface Visitor &#123; //获取cpu价格 int getPrice(Cpu cpu); //获取内存条价格 int getPrice(Memory memory); //获取主板价格 int getPrice(Board board);&#125;@Dataclass Cpu implements ComputerPart &#123; //cpu 品牌名称 private String name; //cpu价格 private int price; public Cpu(String name, int price) &#123; this.name = name; this.price = price; &#125; //cpu 特有属性 public int getPrice(Visitor visitor) &#123; return visitor.getPrice(this); &#125;&#125;@Dataclass Memory implements ComputerPart &#123; //内存条 品牌名称 private String name; //内存条价格 private int price; //内存条 特有属性 public Memory(String name, int price) &#123; this.name = name; this.price = price; &#125; public int getPrice(Visitor visitor) &#123; return visitor.getPrice(this); &#125;&#125;@Dataclass Board implements ComputerPart &#123; //主板 品牌名称 private String name; //主板价格 private int price; //主板 特有属性 public Board(String name, int price) &#123; this.name = name; this.price = price; &#125; public int getPrice(Visitor visitor) &#123; return visitor.getPrice(this); &#125;&#125;class Student implements Visitor &#123; @Override public int getPrice(Cpu cpu) &#123; return (int) Math.round(cpu.getPrice() * 0.8); &#125; @Override public int getPrice(Memory memory) &#123; return (int) Math.round(memory.getPrice() * 0.75); &#125; @Override public int getPrice(Board board) &#123; return (int) Math.round(board.getPrice() * 0.9); &#125;&#125;class Teacher implements Visitor &#123; @Override public int getPrice(Cpu cpu) &#123; return (int) Math.round(cpu.getPrice() * 0.8); &#125; @Override public int getPrice(Memory memory) &#123; return (int) Math.round(memory.getPrice() * 0.8); &#125; @Override public int getPrice(Board board) &#123; return (int) Math.round(board.getPrice() * 0.8); &#125;&#125; 由于电脑的组成部分相对固定 各个元件差别较小 所以利用访问者模式可以灵活的为不同的客户(学生/老师)提供不同的优惠策略 避免了if else的操作","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"多线程与高并发(一)","slug":"高并发-多线程与高并发一","date":"2022-03-31T14:49:15.189Z","updated":"2022-04-06T12:40:34.644Z","comments":false,"path":"2022/03/31/高并发-多线程与高并发一/","link":"","permalink":"http://example.com/2022/03/31/%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%80/","excerpt":"","text":"一、sleep与wait、notify的区别 sleep 是抱着锁睡觉 在sleep的时候 它不会释放锁 而且sleep会使线程进入time_watting状态 wait 也是会使线程进入等待 但是wait会释放锁 它会使线程进入wating状态 同时wait与notify一样都是object的方法 且只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。这一点通常不会被程序员注意，因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法，那么你将得到一个”java.lang.IllegalMonitorStateException” notify 会唤醒其他线程去抢锁 但是执行notify并不会立即释放当前线程的锁 另外与wait一样 notify也是object的方法且只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的notify方法 notify会使得被处于waiting状态的线程重新进入到runnable状态 下面的代码可以证明wait是释放了锁的 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) throws Exception&#123; Object lock = new Object(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(&quot;t1开始执行&quot;); synchronized (lock) &#123; System.out.println(&quot;wait开始执行&quot;); lock.wait(); //只有在同步代码块中 使用lock.wait()才不会报错 因为此时t1线程具有lock对象的独占锁 &#125; System.out.println(&quot;t1执行结束&quot;); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; synchronized (lock) &#123; System.out.println(&quot;t2开始执行&quot;); Thread.sleep(3000); System.out.println(&quot;开始唤醒t1&quot;); lock.notifyAll(); //只有在同步代码块中 使用lock.wait()才不会报错 因为此时t2线程具有lock对象的独占锁 调用notify 并不会导致当前线程释放锁 Thread.sleep(3000); System.out.println(&quot;t2同步代码块逻辑执行完毕&quot;); &#125; Thread.sleep(5000); System.out.println(&quot;t2执行结束&quot;); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); Thread.sleep(3000); t2.start(); Thread.sleep(10000); &#125;&#125; 二、异常跟锁在程序当中 如果抛出了异常 锁是会被释放的 除非你try catch Synchorinzed锁升级 最开始的时候 如果锁对象是在JVM启动4秒之前 则是这个对象的锁的状态是无锁 如果是4秒之后创建的对象 则这个对象的锁的状态是匿名偏向 如果此时有线程进入 那么该对象的状态变成偏向锁 偏向锁内部实际上是没有锁的 只是一个标志 如果此时有其他线程来争抢 则会撤销偏向锁 升级为自旋锁 如果某一个线程自旋了10次还未获得锁 则升级为重量级锁 三 AtomicInteger 源码分析Atomic类底层都是利用CAS机制实现的 java中提供了一个类Unsafe 利用Unsafe类可以直接操作内存 下面是AtomicInteger 和 Unsafe类的相应源码 12345678910111213141516171819202122232425262728293031323334353637383940public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; private volatile int value; static &#123; try &#123; //这个代码的意思其实就是获取了AtomicInteger.class这个class对象的value字段在内存地址中的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; //省略部分代码 public final int getAndSet(int newValue) &#123; //所以这里需要传this进来 可以通过this获取当前对象在堆内存中的内存地址 再加上value这个字段的内存偏移量 就可以得到这个对象的value字段的内存地址 并且把新值传进来 return unsafe.getAndSetInt(this, valueOffset, newValue); &#125;&#125;//下面是Unsafe类的相关源码public final class Unsafe &#123; private Unsafe() &#123; &#125; //var1 就是当前对象 //var2 是value字段的内存偏移量 //var4 是新值 public final int getAndSetInt(Object var1, long var2, int var4) &#123; int var5; do &#123; //根据对象 和 value字段的偏移量 获取value字段对应的值(CAS操作中的当前值E) var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4)); //compareAndSwapInt这是个原子操作 会先比较内存中value字段对应的值是不是var5 如果是 则把var4设置到value字段中 并返回var5 return var5; &#125;&#125; 测试Synchorinized、AtomicInteger、LongAdder的性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class Client &#123; private String name; private static AtomicInteger count_1 = new AtomicInteger(0); private static int count_2 = 0; private static LongAdder count_3 = new LongAdder(); public static void main(String[] args) throws Exception &#123; count_1(); count_2(); count_3(); &#125; private static void count_1() throws Exception&#123; List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); CountDownLatch cd = new CountDownLatch(1000); for (int i = 0; i &lt; 1000; i++) &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 100; i++) &#123; sleep(); count_1.incrementAndGet(); &#125; &#125;finally &#123; cd.countDown(); &#125; &#125; &#125;); list.add(t); &#125; Long start = System.currentTimeMillis(); for (Thread t : list) &#123; t.start(); &#125; cd.await(); Long end = System.currentTimeMillis(); System.out.println(&quot;AtomicInter 计算结果 = &quot; + count_1.get() + &quot; 耗时 &quot; + (end - start) + &quot;毫秒&quot;); &#125; private static void count_2() throws Exception&#123; List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); final Object lock = new Object(); CountDownLatch cd = new CountDownLatch(1000); for (int i = 0; i &lt; 1000; i++) &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 100; i++) &#123; sleep(); synchronized (lock) &#123; count_2++; &#125; &#125; &#125;finally &#123; cd.countDown(); &#125; &#125; &#125;); list.add(t); &#125; Long start = System.currentTimeMillis(); for (Thread t : list) &#123; t.start(); &#125; cd.await(); Long end = System.currentTimeMillis(); System.out.println(&quot;i++计算结果 = &quot; + count_2 + &quot; 耗时 &quot; + (end - start) + &quot;毫秒&quot;); &#125; private static void count_3() throws Exception&#123; List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); CountDownLatch cd = new CountDownLatch(1000); for (int i = 0; i &lt; 1000; i++) &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 100; i++) &#123; sleep(); count_3.increment(); &#125; &#125;finally &#123; cd.countDown(); &#125; &#125; &#125;); list.add(t); &#125; Long start = System.currentTimeMillis(); for (Thread t : list) &#123; t.start(); &#125; cd.await(); Long end = System.currentTimeMillis(); System.out.println(&quot;LongAdder 计算结果 = &quot; + count_3 + &quot; 耗时 &quot; + (end - start) + &quot;毫秒&quot;); &#125; private static void sleep()&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 从实测的结果来看同步快执行时间短的情况下 三者相差不大 ReentrantLock 可重入锁 就是是对于同一个线程来说 如果获得了可冲入锁 就不需要再次获取了 synchronized就是可重入锁的一种 下面的示例 如果synchronized不是可重入锁的话 那么 t1会死锁 t2也会死锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; m1(); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; m1(); &#125; &#125;); t1.start(); sleep(1000); t2.start(); t1.join(); t2.join(); &#125; private static synchronized void m1() &#123; System.out.println(Thread.currentThread().getId() + &quot;执行m1方法&quot;); sleep(3000); m2(); System.out.println(Thread.currentThread().getId() + &quot;m1方法执行结束&quot;); &#125; private static synchronized void m2() &#123; System.out.println(Thread.currentThread().getId() + &quot;执行m2方法&quot;); sleep(3000); System.out.println(Thread.currentThread().getId() + &quot;m2方法执行结束&quot;); &#125; private static void sleep(int ttl)&#123; try &#123; Thread.sleep(ttl); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面是用ReentrantLock来代替synchronized 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Client &#123; private static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; m1(); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; m1(); &#125; &#125;); t1.start(); sleep(1000); t2.start(); t1.join(); t2.join(); &#125; private static void m1() &#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getId() + &quot;执行m1方法&quot;); sleep(3000); m2(); System.out.println(Thread.currentThread().getId() + &quot;m1方法执行结束&quot;); &#125;finally &#123; lock.unlock(); &#125; &#125; private static void m2() &#123; try&#123; lock.lock(); System.out.println(Thread.currentThread().getId() + &quot;执行m2方法&quot;); sleep(3000); System.out.println(Thread.currentThread().getId() + &quot;m2方法执行结束&quot;); &#125;finally &#123; lock.unlock(); &#125; &#125; private static void sleep(int ttl)&#123; try &#123; Thread.sleep(ttl); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; tryLock用法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Client &#123; private static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; m1(); &#125; &#125;); t1.start(); sleep(1); boolean locked = false; try &#123; locked = lock.tryLock(5, TimeUnit.SECONDS); //会阻塞5秒钟 如果5秒内没有获得锁则继续执行下面的内容 System.out.println(&quot;执行方法&quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;尝试获得锁失败&quot;); &#125; finally &#123; if (locked) &#123; lock.unlock(); &#125; &#125; t1.join(); &#125; private static void m1() &#123; try &#123; lock.lock(); System.out.println(&quot;m1开始执行&quot;); sleep(6000); System.out.println(&quot;m1执行结束&quot;); &#125;finally &#123; lock.unlock(); &#125; &#125; private static void sleep(int ttl)&#123; try &#123; Thread.sleep(ttl); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 公平锁 可以通过对ReentrantLock设置参数使它变成一个公平锁 公平锁的原理实际上是当锁被释放后 它会先检查锁的等待队列 如果等待队列中有线程在等待那么它会优先从等待队列里面取 所有公平锁的有序是指的在等待队列里的线程抢锁的有序 至于不同的线程进入等待队列的这个顺序是无法保证的 所以下面例子可以看到绝大多数情况下它都是一个固定的输出 但是偶尔也会有乱序的情况 但是这只能说明 线程进入等待队列的顺序是错乱的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.concurrent.locks.ReentrantLock;public class Client &#123; private static ReentrantLock lock = new ReentrantLock(true); //设置为true表示这是一个公平锁 public static void main(String[] args) throws Exception &#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;获得锁&quot;); &#125;finally &#123; if (lock.isLocked()) &#123; lock.unlock(); &#125; &#125; &#125; &#125; &#125;; Thread t1 = new Thread(r); Thread t2 = new Thread(r); Thread t3 = new Thread(r); t1.start(); t2.start(); t3.start(); t1.join(); t2.join(); t3.join(); &#125; private static void m1() &#123; try &#123; lock.lock(); System.out.println(&quot;m1开始执行&quot;); sleep(6000); System.out.println(&quot;m1执行结束&quot;); &#125;finally &#123; lock.unlock(); &#125; &#125; private static void sleep(int ttl)&#123; try &#123; Thread.sleep(ttl); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 四 CountDownLatchCountDownLatch与线程的join方法具有同样的效果 下面的两种方式是等价的 1234567891011121314151617181920212223242526272829303132333435363738394041 public static void main(String[] args) throws Exception &#123; AtomicInteger count = new AtomicInteger(0); List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Thread t = new Thread(count::incrementAndGet); list.add(t); &#125; for (Thread t : list) &#123; t.start(); &#125; for (Thread t : list) &#123; t.join(); &#125; System.out.println(count.get()); &#125;public static void main(String[] args) throws Exception &#123; CountDownLatch cd = new CountDownLatch(100); AtomicInteger count = new AtomicInteger(0); List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Thread t = new Thread(() -&gt; &#123; try &#123; count.incrementAndGet(); &#125;finally &#123; cd.countDown(); &#125; &#125;); list.add(t); &#125; for (Thread t : list) &#123; t.start(); &#125; cd.await(); System.out.println(count.get()); &#125; 五 CyclicBarrierCyclicBarrier也叫同步屏障，在JDK1.5被引入，可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所以被阻塞的线程才能继续执行。CyclicBarrier好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。 构造方法 12public CyclicBarrier(int parties)public CyclicBarrier(int parties, Runnable barrierAction) parties 是参与线程的个数 第二个构造方法有一个 Runnable 参数，这个参数的意思是最后一个到达线程要做的任务 重要方法 12public int await() throws InterruptedException, BrokenBarrierExceptionpublic int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException 线程调用 await() 表示自己已经到达栅栏 BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时 示例 12345678910111213141516171819202122232425262728293031323334353637383940public class Client &#123; public static void main(String[] args) throws Exception &#123; AtomicInteger count = new AtomicInteger(); CyclicBarrier cyclicBarrier = new CyclicBarrier(20, new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;执行runnable&quot;); &#125; &#125;); for (int i = 0; i &lt; 100; i++) &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; count.incrementAndGet(); cyclicBarrier.await(); System.out.println(Thread.currentThread().getId() + &quot;继续执行&quot;); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t.start(); sleep(10); //阻塞只是为了保证 每个线程启动的顺序 &#125; System.out.println(count.get()); &#125; private static void sleep(int ttl)&#123; try &#123; Thread.sleep(ttl); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 六 phaser在Phaser中，它把多个线程协作执行的任务划分为多个阶段，编程时需要明确各个阶段的任务，每个阶段都可以有任意个参与者，线程都可以随时注册并参与到某个阶段。Phaser相对于CyclicBarrier来说是一个分阶段的栅栏 它的可操作粒度会比CyclicBarrier要小 下面的示例是以结婚为主题 结婚分为多个步骤 1、所有人先到场 、2、新郎、新娘 举行婚礼仪式 3、吃饭 4、其他人离开 新郎、新娘洞房 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class Client &#123; public static void main(String[] args) throws Exception &#123; MarriagePhaser phaser = new MarriagePhaser(); phaser.bulkRegister(7); //简单理解就是当有7个线程进入到这个phaser中的时候 会触发执行phaser的onAdvance方法 new Person(&quot;张三&quot;, phaser).start(); new Person(&quot;李四&quot;, phaser).start(); new Person(&quot;王五&quot;, phaser).start(); new Person(&quot;赵六&quot;, phaser).start(); new Person(&quot;钱七&quot;, phaser).start(); new Person(&quot;新郎&quot;, phaser).start(); new Person(&quot;新娘&quot;, phaser).start(); &#125; public static void sleep(int ttl)&#123; try &#123; Thread.sleep(ttl); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MarriagePhaser extends Phaser &#123; /** * onAdvance 表示当某个阶段的线程数达到预期后 执行 * @param phase * @param registeredParties * @return */ @Override protected boolean onAdvance(int phase, int registeredParties) &#123; switch (phase) &#123; case 0 : //arrive(); System.out.println(&quot;所有人到齐了&quot; + registeredParties); System.out.println(&quot;===============================&quot;); return false; case 1 : //nothing(); System.out.println(&quot;新郎、新娘举行婚礼&quot; + registeredParties); return false; case 2 : //ceremony(); System.out.println(&quot;===============================&quot;); System.out.println(&quot;婚宴开席&quot; + registeredParties); return false; case 3 : //eat(); System.out.println(&quot;===============================&quot;); System.out.println(&quot;婚宴散席 客人离开&quot; + registeredParties); return false; case 4 : //leave(); return false; case 5 : //nothing(); System.out.println(&quot;===============================&quot;); System.out.println(&quot;新郎，新娘洞房&quot; + registeredParties); return false; case 6 : //hug(); System.out.println(&quot;婚礼结束&quot; + registeredParties); return true; default: return true; &#125; &#125;&#125;@Data@AllArgsConstructorclass Person extends Thread &#123; private String personName; private Phaser phaser; @Override public void run() &#123; arrive(); nothing(); //这个方法没有含义 只是为了调整打印语句的流程 ceremony(); eat(); leave(); nothing(); //这个方法没有含义 只是为了调整打印语句的流程 hug(); &#125; public void arrive() &#123; Client.sleep(1000); System.out.println(personName + &quot;到达婚礼现场&quot;); phaser.arriveAndAwaitAdvance(); //标识当前线程已经到了某个阶段 并且等待进入下一阶段 &#125; public void nothing() &#123; Client.sleep(1000); phaser.arriveAndAwaitAdvance(); //标识当前线程已经到了某个阶段 并且等待进入下一阶段 &#125; public void ceremony() &#123; //举行婚礼 Client.sleep(1000); if (personName.equals(&quot;新郎&quot;)) &#123; System.out.println(&quot;新郎为新娘戴上戒指&quot;); phaser.arriveAndAwaitAdvance(); //标识当前线程已经到了某个阶段 并且等待进入下一阶段 return; &#125; if (personName.equals(&quot;新娘&quot;)) &#123; System.out.println(&quot;新娘为新郎戴上戒指&quot;); phaser.arriveAndAwaitAdvance(); //标识当前线程已经到了某个阶段 并且等待进入下一阶段 return; &#125; System.out.println(personName + &quot;参加婚礼 并送上祝福&quot;); phaser.arriveAndAwaitAdvance(); //标识当前线程已经到了某个阶段 并且等待进入下一阶段 &#125; public void eat() &#123; Client.sleep(1000); System.out.println(&quot;婚宴开始 &quot; + personName + &quot;开始吃饭&quot;); phaser.arriveAndAwaitAdvance(); //标识当前线程已经到了某个阶段 并且等待进入下一阶段 &#125; public void leave() &#123; Client.sleep(1000); if (personName.equals(&quot;新郎&quot;) || personName.equals(&quot;新娘&quot;)) &#123; phaser.arriveAndAwaitAdvance(); //标识当前线程已经到了某个阶段 并且等待进入下一阶段 return; &#125; System.out.println(&quot;散席 &quot; + personName + &quot;离开现场&quot;); &#125; public void hug() &#123; if (personName.equals(&quot;新郎&quot;) || personName.equals(&quot;新娘&quot;)) &#123; Client.sleep(1000); System.out.println(personName + &quot;洞房&quot;); phaser.arriveAndAwaitAdvance(); //标识当前线程已经到了某个阶段 并且等待进入下一阶段 return; &#125; else &#123; phaser.arriveAndDeregister(); // registeredParties 值会减一 arriveAndDeregister只能在最后一个阶段 &#125; &#125;&#125; 七 ReadWriteLock读写锁 实际上就是共享锁(读锁)和排他锁(写锁) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Client &#123; private static ReentrantLock reentrantLock = new ReentrantLock(); private static ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //实例化一个读写锁 private static Lock readLock = readWriteLock.readLock(); //读锁 读锁允许所有的读线程(需要获取读锁的线程)进入 排斥写线程进入 private static Lock writeLock = readWriteLock.writeLock(); //写锁 排斥读线程和写线程 public static void main(String[] args) throws Exception &#123; for (int i = 0; i &lt; 10; i++) &#123; Thread t = new Thread(() -&gt; read(readLock)); t.start(); &#125; for (int i = 0; i &lt; 2; i++) &#123; Thread t = new Thread(() -&gt; write(writeLock, 1)); t.start(); &#125; sleep(20000); //理论上的执行时间为3秒 而不是12秒 如果用reentrantLock则需要12秒 &#125; private static void read(Lock lock) &#123; try &#123; lock.lock(); sleep(1000); System.out.println(&quot;read&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125; private static void write(Lock lock, int val) &#123; try &#123; lock.lock(); sleep(1000); System.out.println(&quot;write val &quot; + val); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void sleep(int ttl)&#123; try &#123; Thread.sleep(ttl); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 八 SemaphoreSemaphore是信号量的意思 一个信号量可以允许一个线程执行 一个信号量类似于一个锁 semaphore一般可以用来做限流 比如买票窗口 无论买的人有多少 只会同时开放几个窗口来处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Client &#123; public static void main(String[] args) throws Exception &#123; Semaphore semaphore = new Semaphore(2); //permits 一共可以有多少个信号量 new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); //阻塞方法 获取一个信号量(获取一把锁) 会将semaphore设置的permits的值减一 System.out.println(&quot;T1 running ....&quot;); Thread.sleep(5000); System.out.println(&quot;T1 end&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); //会将semaphore设置的permits的值增加一(释放一把锁) &#125; &#125;).start(); new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(&quot;T2 running ....&quot;); Thread.sleep(5000); System.out.println(&quot;T2 end&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); //会将semaphore设置的permits的值增加一 &#125; &#125;).start(); new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(&quot;T3 running ....&quot;); Thread.sleep(5000); System.out.println(&quot;T3 end&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); //会将semaphore设置的permits的值增加一 &#125; &#125;).start(); new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(&quot;T4 running ....&quot;); Thread.sleep(5000); System.out.println(&quot;T4 end&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); //会将semaphore设置的permits的值增加一 &#125; &#125;).start(); &#125;&#125;","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"迭代器模式","slug":"设计模式-迭代器模式","date":"2022-03-31T13:19:28.160Z","updated":"2022-04-06T12:42:23.122Z","comments":false,"path":"2022/03/31/设计模式-迭代器模式/","link":"","permalink":"http://example.com/2022/03/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"计算机的物理存储结构其实只有2种 就是数组(连续存储)和链表(跳着存储) 其他的数据结构其实底层都是由这两种数据结构实现的迭代器模式又叫游标模式 它提供一种按顺序访问集合或容器的方法。所以这其实是一种容器或者集合的专属设计模式 迭代器模式最关键的就是需要设计一个Iterator接口 然后容器去实现这个接口。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class Test &#123; public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); list.add(&quot;f&quot;); list.add(&quot;g&quot;); list.add(&quot;h&quot;); list.add(&quot;i&quot;); Iterator&lt;String&gt; iterator = list.getIterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; System.out.println(&quot;=================&quot;); Iterator&lt;String&gt; iterator2 = list.getIterator(); while (iterator2.hasNext()) &#123; System.out.println(iterator2.next()); &#125; &#125;&#125;class ArrayList&lt;T&gt;&#123; private int size; private Object[] elements = new Object[2]; public void add(T o) &#123; if (size == elements.length) &#123; elements = Arrays.copyOf(elements, elements.length * 2); &#125; elements[size] = o; size++; &#125; public int size() &#123; return size; &#125; public Iterator&lt;T&gt; getIterator() &#123; return new ArrayListIterator(); &#125; public class ArrayListIterator implements Iterator&lt;T&gt;&#123; private int currentIndex; @Override public boolean hasNext() &#123; return size &gt; currentIndex; &#125; @Override public T next() &#123; T val = (T)elements[currentIndex]; currentIndex++; return val; &#125; &#125;&#125;interface Iterator&lt;T&gt; &#123; boolean hasNext(); T next();&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"CAS原理解析","slug":"高并发-CAS原理解析","date":"2022-03-30T13:29:00.930Z","updated":"2022-04-06T12:41:02.042Z","comments":false,"path":"2022/03/30/高并发-CAS原理解析/","link":"","permalink":"http://example.com/2022/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91-CAS%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"一 CAS基本概念CAS（Compare And Swap）也叫做比较与交换，是一种无锁原子算法，映射到操作系统就是一条cmpxchg硬件汇编指令，通过硬件命令保证了原子性。其作用是让CPU将内存值更新为新值，但是有个条件，内存值必须与期望值相同。CAS操作无需用户态和内核态切换，直接在用户态对内存进行读写操作，这意味着不会进行上下文切换。它包含3个参数CAS（V，E，N），V表示待更新的内存值，E表示预期值，N表示新值，当V值等于E值时，才会将V值更新成N值，如果V值和E值不等，操作失败或者重新再来，这就是一次CAS的操作。 简单说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的，如果变量不是你想象的那样，说明它已经被别人修改过了，你只需要重新读取，设置期望值，再次尝试修改就好了。设置一个期望值的目的：通过内存值与期望值的比较，防止自己的修改覆盖了别人的修改。 二 CAS如何保证原子性原子性是指一个或多个操作在CPU执行过程中不被中断的特性，要么执行，要么不执行，不能执行到一半，即原子性操作是不可被中断的一个或一系列操作。为了保证CAS的原子性，CPU提供了下面两种方式 总线锁定 总线（BUS）是计算机组件间数据传输方式，也就是说通过总线，CPU与其他组件连接传输数据，就是靠总线完成的，比如CPU对内存的读写 总线锁定是指CPU使用了总线锁，所谓总线锁就是使用CPU提供的LOCK#信号，当CPU在总线上输出LOCK#信号时，其他CPU的总线请求将被阻塞。 缓存锁定 总线锁定方式虽然保持了原子性，但是在锁定期间，总线锁定阻止了被阻塞处理器和所有内存之间的通信，而输出LOCK#信号的CPU可能只需要锁住特定的一块内存区域，因此总线锁定开销较大。 所以现代CPU为了提升性能，通过锁定范围缩小的思想设计出缓存行锁定（缓存行是CPU高速缓存存储的最小单位） 所谓缓存锁定是指CPU对缓存行进行锁定，当缓存行中的共享变量回写到内存时，其他CPU会通过总线嗅探机制感知到该共享变量是否发生变化，如果发生变化，让自己对应的共享变量缓存行失效，重新从内存读取最新的数据，缓存锁定是基于缓存一致性机制来实现的，因为缓存一致性机制会阻止两个以上CPU同时修改同一个共享变量（现代CPU基本都支持和使用缓存锁定机制）缓存锁定是某个CPU对缓存数据进行更改时，会通知缓存了该数据的CPU抛弃缓存的数据或者从内存重新读取 缓存一致性 当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU高速缓存中，那么CPU进行计算时就可以从它的高速缓存读取数据和向其中写入数据，当运算结束后，再将高速缓存中的数据刷新到主存中。 在多核CPU中，每个线程可能运行在不同的CPU中，因此每个线程运行时有自己的高速缓存。假如初始时 i 的值为0，那么我们希望两个线程执行完加1操作之后 i 的值变为2。但事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作后，i的值为1，然后线程2把i的值写入内存。最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致问题，通常来说有以下2种解决方法：1）通过在总线加LOCK锁的方式；2）通过缓存一致性协议； 在早期的CPU中，是通过在总线上加LOCK锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK锁的话，也就是说阻塞了其他CPU通过总线对其它部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中，如果一个线程在执行i = i +1，如果在执行这段代码的过程中，在总线上发出了LOCK锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量 i 所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。所以就出现了缓存一致性协议。该协议保证了每个缓存中使用的共享变量的副本是一致的。它的核心思想是：当CPU向内存写入数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存是无效的，那么它就会从内存重新读取。 三 CAS问题CAS和锁都解决了并发中的同步问题，和锁相比CAS没有阻塞、线程上下文切换、死锁。所以CAS要比锁拥有更优越的性能，但是CAS同样存在缺点。CAS的问题如下： 只能保证一个共享变量的原子操作 CAS只能针对一个共享变量使用，如果是多个共享变量最好使用锁了，当然也是可以将多个变量整合一个变量。 在并发量大的情况下，CAS将消耗大量的CPU资源 在并发量大的情况下，很容发生多个线程反复尝试更新某一个变量，却又一直更新不成功，会消耗大量的CPU资源 ABA问题 CAS需要检查待更新的内存值与预期值是否相等，其本质是要检查待更新的内存值有没有被修改过，如果没有则更新，但是如果一个值原来是A，后来被修改成了B，再被更新为A，在CAS检查时，识别不出来数据被修改过。 如果只是简单的数据结构，确实不会有什么问题，如果是复杂的数据结构可能就会产生问题。以链表数据结构为例，两个线程通过CAS去删除头节点，假设现在链表上有A-&gt;B节点 1、线程1欲删除A节点，B节点成为头节点，正要执行CAS（A,A,B）时，时间片用完，切换到线程22、线程2删除A、B节点3、线程2加入C、A节点4、线程1重现获取时间片，执行CAS（A,A,B）5、丢失C节点 要解决ABA问题也非常简单，只要追加版本号（version）即可，每次改变时version+1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A，在Java中提供了AtomicStampedRdference可以实现这个方案（面试只要问了C A S，就一定会问ABA，这块一定要搞明白）","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"并发编程三大特性","slug":"高并发-并发编程三大特性","date":"2022-03-26T08:29:03.971Z","updated":"2022-04-08T15:45:50.217Z","comments":false,"path":"2022/03/26/高并发-并发编程三大特性/","link":"","permalink":"http://example.com/2022/03/26/%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"一 可见性线程的可见性是指 是指当一个线程修改了共享变量的值，其它线程能够适时得知这个修改。用volatile关键字可以保障线程的可见性volatile 不仅能够保证基本数据类的线程可见性 也可以保证引用类型或者数组本身的可见性 对于引用类型的成员变量的可见性也是可以保证的 volatile有两个作用 1、保证线程的可见性 2、进制CPU指令重排 先看一段代码 123456789101112131415161718192021public class Client &#123; private static boolean running = true; //线程共享变量 public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;thread start&quot;); while (running) &#123; //t1的内存缓存中缓存的running变量的副本 &#125; System.out.println(&quot;thread end&quot;); &#125; &#125;); t1.start(); Thread.sleep(1000); running = false; System.out.println(&quot;running is false&quot;); &#125;&#125; 上面的代码无论running是不是false t1线程都不会终止 会一直循环 原因是每个线程在初始化的时候 都会从主线程将自己需要的变量(上面代码中的running)从主线程中copy一份到自己的缓存中 后续每次读这个变量都是从自己的缓存空间中去读 这就是为什么running明明已经是false了但是线程没有停止。 用volatile修饰running变量 下面的程序就可以正常退出了 123456789101112131415161718192021public class Client &#123; private volatile static boolean running = true; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;thread start&quot;); while (running) &#123; &#125; System.out.println(&quot;thread end&quot;); &#125; &#125;); t1.start(); Thread.sleep(1000); running = false; System.out.println(&quot;running is false&quot;); &#125;&#125; 某些语句是可以触发线程内存缓存与主线程内存缓存的同步刷新 其实就是说除了用volatile 修饰变量保证线程可见性之外 有一些语句也是可以达到类似的效果的 比如synchronized关键字 当线程执行到有synchronized关键字标识的代码块的时候 也会触发与主线程之间的同步 1234567891011121314151617181920212223public class Client &#123; private static boolean running = true; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;thread start&quot;); while (running) &#123; synchronized (Client.class) &#123; //当t1线程执行到这里的时候 会从主线程重新同步running的状态 System.out.println(&quot;thread running&quot;); &#125; &#125; System.out.println(&quot;thread end&quot;); &#125; &#125;); t1.start(); Thread.sleep(1000); running = false; System.out.println(&quot;running is false&quot;); &#125;&#125; volatile保证引用类型成员变量的可见性 下面的代码中A类的running成员变量并没有用volatile修饰 但线程仍然可以停止 (以前有的书上说 volatile只能保证引用类型本身的可见性 不能同时保证其成员变量的可见性 这个结论实测是错误的) 12345678910111213141516171819202122232425public class Client &#123; private volatile static A a = new A(); public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;thread start&quot;); while (a.running) &#123; &#125; System.out.println(&quot;thread end&quot;); &#125; &#125;); t1.start(); Thread.sleep(1000); a.running = false; System.out.println(&quot;running is false&quot;); &#125;&#125;class A &#123; boolean running = true; //没有用volatile修饰&#125; 二 有序性先看下面的代码 这段代码要跑很久 很多次才可能出现预期的结果 主要是为了说明 即便是单线程 执行顺序也不一定就是你代码的顺序 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Client &#123; private static int x = 0; private static int y = 0; private static int a = 0; private static int b = 0; public static void main(String[] args) throws Exception &#123; for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; x = 0; y = 0; a = 0; b = 0; CountDownLatch cd = new CountDownLatch(2); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; a = 1; x= b; cd.countDown(); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; b = 1; y= a; cd.countDown(); &#125; &#125;); t1.start(); t2.start(); cd.await(); String result = &quot;第&quot; + i +&quot;次 ( x = &quot; + x + &quot; y = &quot; + y + &quot;)&quot;; if (x == 0 &amp;&amp; y == 0) &#123; //如果x==0 且y==0的时候只能证明一种情况 在t1 和t2线程中 一定是先执行 x=b 和 y=a System.out.println(result); break; &#125; &#125; &#125;&#125; 执行结果 为了跑出来这个结果 跑了大概1个小时 1第16924783次 ( x = 0 y = 0) 下图对t1和t2两个线程可能的执行情况做了排列组合 可以发现如果是x=0 且y=0的情况下 那么一定是 一定是先执行 x=b 和 y=a 先执行了 之所以会出现在单线程中都可能乱序的情况 是因为cpu在执行指令的时候 为了提高效率 会进行指令重排(将前后两条指令没有依赖关系的代码 可以进行指令重排) 这种程度上的指令重排 不会影响单线程的最终一致性 有序性示例二 下面的代码存在有序性的问题 因为number=42 与ready=true没有依赖关系 所以理论上他们有可能被cpu进行指令重排 那么会导致最后System.out.println(number);打印的结果是0而不是42 12345678910111213141516171819202122public class Test &#123; private static volatile boolean ready = false; private static int number; public static void main(String[] args) throws Exception&#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; while (!ready) &#123; Thread.yield(); //调用这个方法 会使得当前线程让掉CPU的时间片 其他线程(主线程)有一定概率可以抢到这个时间片 &#125; System.out.println(number); //有一种可能的结果是0 因为 ready = true; 先于 number = 42;执行了 &#125; &#125;); t.start(); number = 42; ready = true; t.join(); &#125;&#125; jclasslib Bytecode Viewer jclasslib Bytecode Viewer 是idea的一个插件 可以用来查看字节码信息 类似于通过javac和javap -verbose 查看字节码 this对象逸出问题 所谓this对象逸出其实就是其他线程通过this(隐式调用)访问了还没有构造好的对象。下面这段代码理论上是可能由于指令重排序导致打印的结果为0 1234567891011121314public class Test &#123; private int num = 9; public Test() &#123; Thread t1 = new Thread(() -&gt; System.out.println(this.num)); //不论这里加不加this都一样 t1.start(); &#125; public static void main(String[] args) throws Exception&#123; Test test = new Test(); &#125;&#125; 下面是 Test test = new Test()的字节码 123450 new #7 &lt;com/poi/tl/test/Test&gt; //申请内存3 dup //是将栈顶数值复制一份并送入至栈顶4 invokespecial #8 &lt;com/poi/tl/test/Test.&lt;init&gt; : ()V&gt; //调用Test的构造方法(当然还包括一些其他的内容比如静态代码块之类的 这里不过多解释 只要知道这一步会调用构造方法就行了)7 astore_1 //将test字面量与Test对象进行关联 也就是把刚刚新建的Test对象的内存地址赋给test变量8 return 这里invokespecial 与 astore_1 可能会发生指令重排 astore_1 先于 invokespecial 执行 这样的话 t1这个线程就有可能在Test还没有执行完构造方法的时候(num还没有初始化的时候 此时num=0) 就执行了System.out.println(this.num) 从而输出0 而不是9 为了避免this对象逸出问题 一般不建议在构造方法中启动新的线程 你可以去new这个线程 但是不要去启动 对象在内存中的存储布局 一个对象在内存中的布局包括3个部分 markword 对象头 占8个字节 这里主要包含一些锁信息、gc信息以及hashCode的信息 class pointer 类型指针 占4个字节 实例数据 这个就是类中的一些数据 主要是成员变量 下图是对象在内存中布局的结构图 如果是数组 会多个四个字节 可以通过jol-core来获取一个对象的大小 jol-core的依赖如下 12345&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.14&lt;/version&gt;&lt;/dependency&gt; 通过下面的代码可以查看某个对象的大小 123456789101112131415public class Test &#123; private int num = 9; private int num2 = 9; public Test() &#123; &#125; public static void main(String[] args) throws Exception &#123; Test t = new Test(); String s = ClassLayout.parseInstance(t).toPrintable(); System.out.println(s); &#125;&#125; 执行结果如下 前12个字节固定不变是对象头和类型指针 第13-16个字节是num变量占的大小(一个int占4字节) 第17-20字节是第二个变量num2占的大小 由于20个字节不能被8整除 所以 补了4个字节 一共是24个字节 JVM规范要求任何虚拟机都要实现下面的四种JVM内存屏障 实际上JVM就是通过这四类屏障来阻止指令重排 LoadLoad屏障 对于这样的语句 Load1; LoadLoad; Load2;(这里的Load指的是JVM的读指令 具体是哪一个指令无所谓 只要是与读数据相关的指令就可以了)在Load2及后续读操作要读取的数据被访问之前，保证load2读取的数据被读取完毕 StoreStore屏障 对于这样的语句Store1;StoreStore;Store2;(这里的Store是指的写指令) 在Store2及后续写入操作执行前，保证Store2的写入操作对其他处理器可见 LoadStore屏障 对于这样的语句 Load1;LoadStore;Store2; 在Store2及其后续写入操作被刷出前;保证Load1要读取的数据被读取完毕 StoreLoad屏障 对于这样的语句 Store1;StoreLoad;Load2;在Store2及其后续所有操作执行前;保证Store1的写入对其所有处理器可见 三 原子性有关原子性的一些基本概念 race condition 竞争条件 指的是多个线程访问共享数据时产生竞争 unconsistency 数据不一致 指并发访问之下产生的非期望的结果 monitor 在操作系统中管程 在java中监视器 在java中其实就是用来做锁的那个对象 critical section 临界区 其实就是锁住的代码块 如果临界区执行时间长 语句多 叫做锁的粒度比较粗 jvm中具备原子性的八大操作 lock 主内存 标识变量为线程所独占 unlock 主内存 解锁线程独占变量 read 主内存 读取内存到线程缓存(工作内存) load 工作内存 read后的值放入线程本地变量副本 use 工作内存 传值给执行引擎 assign 工作内存 执行引擎结果赋值给线程本地变量 store 工作内存 存值到主内存 给write备用 write 主内存 写变量值 上锁的本质就是将并发编程序列化 volatile 保障线程的可见性和有序性 synchronized 保障线程的可见性和原子性 悲观锁与乐观锁 悲观锁 悲观的认为这个操作会被别的线程打断 不管有没有别的线程在竞争 都先把锁加上 synchronized就是一种悲观锁 乐观锁 乐观锁又叫自旋锁或者无锁 CAS操作就是乐观锁 乐观的认为这个操作不会被打断 CAS 全称叫做 compare and swap 或者 compare and exchange CAS 操作是一个原子性的操作 为了保证CAS的原子性在CPU层级其实还是加了锁的 CAS实现的最核心的CPU指令为 lock cmpchg 指令 但是它比JVM级别的锁效率要高 CAS简单来说就是在修改一个值之前先把这个值读进来 然后进行原子操作 在写入之前再读一次 发现这次读的值和原来读的值一样 就写入 否则不做修改 CAS的ABA问题 就是说一个线程读取的当前值E是0(从内存中) 然后计算结果值V为1 然后比较E和N的时候 发现当前最新值N还是0 但是此时的0 有两种可能的结果 1个是在这段时间没有其他线程进行操作 还是原来的版本 所以此时当前线程将N更新为1是没有问题的 但是还有一种结果是 当前的新值N是由于其他的线程改动多次后造成的 简单来说就是此0非彼0 对于CAS的ABA问题 如果对于简单数据类型来说 一般不需要处理 但是对于引用数据类型来说 就需要主要了 因为引用的地址没变 但是引用对象的属性可能发生了改变 解决ABA问题最好的办法就是多加一个version 用version进行计算和比较 而不用变量本身的值去做计算和比较 乐观锁与悲观锁的效率 对于悲观锁来说 它会将竞争锁的线程放到队列中等待 等待的过程是不消耗CPU的 而对于乐观锁来说 对于竞争锁的线程来说 会不断的去尝试或的锁 这个过程是要消耗CPU的 基于这种特性 所以在不同的场景下用不同的锁 临界区执行时间比较长 且 等待的线程很多(并发要求比较高) 的时候 用悲观锁 对于临界区执行时间较短 且等待的线程不多的情况下 建议用乐观锁 在实际开发过程中建议优先用synchronized因为它虽然是悲观锁 但是jdk做了很多优化 性能相对来说已经很不错了。 synchronized详解JDK早期 synchronized叫做重量级锁 是因为JDK早期 利用synchronized关键字申请锁资源的时候 必须要经过操作系统内核(kernel) JDK markword 包含哪些内容 如下图(64位系统的 32位系统会不一样) 上面这张图表示在java对象布局中 markword一共占8个字节 其中最后一个的字节的最后两个bit是锁标志位 markword的第最后一个字节的最后两位01 且 倒数第三位是0 表示是一个没有锁的普通对象 如果是101 表示这个对象加了偏向锁 如果最后两位是00 则是加了自旋锁 如果是最后两位10则是加了重量级锁 如果是最后两位11则是代表对象正在GC 可以用下面这段代码来比较一个普通对象在有锁或者无锁状态下的markword的变化 12345678910111213public class Test &#123; public static void main(String[] args) &#123; Object o = new Object(); System.out.println(ClassLayout.parseInstance(o).toPrintable()); System.out.println(&quot;============================&quot;); synchronized (o) &#123; System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125; &#125;&#125; 下图是上面代码的执行结果 注意输出的对象布局 markword的8个字节是倒着的 所以也就是说 下图显示的第一个字节就是markword的最后一个字节 下面的两次打印 一次是001 表示无锁 还有一次是00 表示轻量级锁 synchronized锁升级 下面是synchronized锁升级的流程图 用户空间锁与重量级锁 偏向锁、自旋锁(轻量级锁/无锁) 都是在用户空间完成 不需要向内核申请 偏向锁 偏向锁实际上就是将当前线程(第一个访问锁对象的线程)的id(java中是线程id 底层C++的实现是线程指针)写到写到锁对象(监视器 或者叫做synchronized锁住的那个对象)的markword当中 这种锁就叫偏向锁 偏向锁实际上是没有竞争条件的 因为就一个线程访问锁对象 当有多个线程访问锁对象的时候 会形成轻度竞争 从而将锁升级为自旋锁可以看上面的图 自旋锁 当存在竞争条件时 偏向锁会被撤销 存在竞争条件的多个线程 开始自旋 所谓自旋就是先在自己的线程栈中生成一个LR(LockRecord) 然后获得锁的线程会把LR写到锁对象的markword中 其他没有竞争到锁的线程 此时会继续自旋 重量级锁 重量级锁也叫做互斥锁 是需要向内核申请的 当自旋锁自旋10次都没拿到锁 那么就会自动升级为重量级锁 在重量级锁的时候 其他线程会进入队列等待 不会消耗CPU资源 锁重入 Synchronized是可重入锁 对于可重入锁 重入的次数必须记录 因为要解锁几次必须得对应 对于偏向锁来说 重入的次数记录在线程栈中 没重入一次LR(LockRecord) 个数加 1 轻量级锁和偏向锁的处理基本一样都是LockRecord加1 如果是重量级锁则是记录在ObjectMonitor的某一个字段上 自旋锁什么时候升级为重量级锁 如果有线程超过10次自旋 或者自旋的线程数超过CPU核数的一半 就会升级为重量级锁 JDK1.6之前 可以通过jvm 参数-XXPreBlockSpin来调整自旋的次数 JDK1.6之后加入了自适应自旋 自旋的次数由JVM自己控制 所以这个参数无效了 偏向锁是否一定比自旋锁效率高 不一定 在明确的指导会有多线程竞争的情况下 偏向锁肯定会涉及到锁撤销 这时候直接使用自旋锁 效率会更高 JVM启动时会有很多线程竞争 所以默认情况 在JVM启动时是不会打开偏向锁的 过一段时间后再打开偏向锁 可以通过JVM参数-XX:BiasedLockingStartupDelay来控制 默认情况下是进程开始启动4秒后打开偏向锁 可以用下面的代码测试 12345678910111213public class Test &#123; public static void main(String[] args) throws Exception&#123;// Object o = new Object();// System.out.println(ClassLayout.parseInstance(o).toPrintable()); System.out.println(&quot;============================&quot;); Thread.sleep(5000); Object o = new Object(); //4秒后创建的对象才会默认开启偏向锁 System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125;&#125; 再看看下面这段代码 12345678910111213141516public class Test &#123; public static void main(String[] args) throws Exception&#123;// Object o = new Object();// System.out.println(ClassLayout.parseInstance(o).toPrintable()); System.out.println(&quot;============================&quot;); Thread.sleep(5000); Object o = new Object(); //4秒后创建的对象才会默认开启偏向锁 synchronized (o) &#123; //多了一个获取锁的操作 System.out.println(Thread.currentThread().getId()); &#125; System.out.println(ClassLayout.parseInstance(o).toPrintable()); &#125;&#125;","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"观察者模式","slug":"设计模式-观察者模式","date":"2022-03-26T04:35:38.687Z","updated":"2022-04-06T12:43:03.110Z","comments":false,"path":"2022/03/26/设计模式-观察者模式/","link":"","permalink":"http://example.com/2022/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式 又叫发布/订阅模式 或者也叫 源/监听器模式 一个源对象(被观察者)可以被多个监听器(观察者)监听 下面的示例是模拟微信公众号发文 而各个关注者可以收到消息的案例 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//公众号 也就是被观察者public class OfficialAccount &#123; private String name; private List&lt;OASubscription&gt; oaSubscriptions = new ArrayList&lt;&gt;(); public OfficialAccount(String name) &#123; this.name = name; &#125; public void registry(OASubscription OASubscription) &#123; oaSubscriptions.add(OASubscription); System.out.println(&quot;用户&quot;+ OASubscription.getName() + &quot;关注了公众号&quot;); &#125; public void publish(String text)&#123; System.out.println(&quot;公众号发送文章《&quot;+text+&quot;》&quot;); //订阅者订阅消息 oaSubscriptions.forEach(subscription -&gt; &#123; subscription.subscription(new Event.EventBuilder&lt;OfficialAccount&gt;().addSource(this).addMsg(text).build()); &#125;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;//消息订阅的接口(也就是所谓的抽象的监听器接口)public interface Subscription&lt;T&gt; &#123; void subscription(Event&lt;T&gt; event);&#125;//公众号消息订阅对象 也就是具体的监听器接口public class OASubscription implements Subscription&lt;OfficialAccount&gt; &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public void subscription(Event&lt;OfficialAccount&gt; event) &#123; OfficialAccount account = event.getSource(); //获取公众号 System.out.println(&quot;订阅者 : &quot; + name + &quot;收到公众号-&quot;+account.getName() + &quot;发来的文章《&quot; + event.getMsg()+&quot;》&quot;); &#125;&#125;//消息类 也就是事件类public class Event&lt;T&gt; &#123; //消息来源(被观察者) private T source; //消息内容 private String msg; public static class EventBuilder&lt;T&gt; &#123; private final Event&lt;T&gt; event = new Event&lt;&gt;(); public Event&lt;T&gt; build() &#123; return event; &#125; public EventBuilder&lt;T&gt; addSource(T source) &#123; event.source = source; return this; &#125; public EventBuilder&lt;T&gt; addMsg(String msg) &#123; event.msg = msg; return this; &#125; &#125; public T getSource() &#123; return source; &#125; public String getMsg() &#123; return msg; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) throws Exception &#123; //创建一个名为java技术栈的公众号 (被观察者也称之为源) OfficialAccount account = new OfficialAccount(&quot;java技术栈&quot;); //创建三个学生 OASubscription user1 = new OASubscription(); user1.setName(&quot;张三&quot;); OASubscription user2 = new OASubscription(); user2.setName(&quot;李四&quot;); OASubscription user3 = new OASubscription(); user3.setName(&quot;王五&quot;); //模拟学生关注公众号 account.registry(user1); account.registry(user2); account.registry(user3); //模拟公众号发布文章 account.publish(&quot;java入门示例-HelloWord&quot;); &#125;&#125; 结果 1234567用户张三关注了公众号用户李四关注了公众号用户王五关注了公众号公众号发送文章《java入门示例-HelloWord》订阅者 : 张三收到公众号-java技术栈发来的文章《java入门示例-HelloWord》订阅者 : 李四收到公众号-java技术栈发来的文章《java入门示例-HelloWord》订阅者 : 王五收到公众号-java技术栈发来的文章《java入门示例-HelloWord》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","slug":"设计模式-责任链模式","date":"2022-03-25T13:01:32.035Z","updated":"2022-04-06T12:45:19.940Z","comments":false,"path":"2022/03/25/设计模式-责任链模式/","link":"","permalink":"http://example.com/2022/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最基本的责任链模式其实很简单 用一个对象存(Chain)储所有的执行节点 并定义好顺序 然后在Chain中循环执行每一个节点的逻辑即可 这里不做演示 下面是利用责任链模式实现的一个类似SpringMVC中FilterChain的一个操作 它会接收用户的请求 并处理服务器的响应 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//模拟用户请求对象public class Request &#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125;//模拟服务端响应对象public class Response &#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125;//定义好Filter接口用于过滤请求和响应public interface Filter &#123; void doFilter(Request request, Response response, FilterChain filterChain);&#125;//过滤器联调(责任链)public class FilterChain&#123; private int index = 0; private final List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); public void doFilter(Request request, Response response) &#123; if (index == filters.size()) return; Filter filter = filters.get(index); index++; filter.doFilter(request, response, this); &#125; public FilterChain addFilter(Filter filter) &#123; filters.add(filter); return this; &#125;&#125;//第一个过滤器public class FilterOne implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain filterChain) &#123; System.out.println(&quot;requst 经过第一个过滤器 msg = &quot; + request.getMsg()); filterChain.doFilter(request, response); System.out.println(&quot;response 经过第一个过滤器 msg = &quot; + response.getMsg()); &#125;&#125;//第二个过滤器public class FilterTwo implements Filter&#123; @Override public void doFilter(Request request, Response response, FilterChain filterChain) &#123; System.out.println(&quot;requst 经过第二个过滤器 msg = &quot; + request.getMsg()); filterChain.doFilter(request, response); System.out.println(&quot;response 经过第二个过滤器 msg = &quot; + response.getMsg()); &#125;&#125;//第三个过滤器public class FilterThree implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain filterChain) &#123; System.out.println(&quot;requst 经过第三个过滤器 msg = &quot; + request.getMsg()); filterChain.doFilter(request, response); System.out.println(&quot;response 经过第三个过滤器 msg = &quot; + response.getMsg()); &#125;&#125;//测试类 模拟用户请求public class Client &#123; public static void main(String[] args) throws Exception &#123; Request request = new Request(); request.setMsg(&quot;我是请求入参&quot;); Response response = new Response(); response.setMsg(&quot;我是响应出参&quot;); FilterChain filterChain = new FilterChain(); filterChain.addFilter(new FilterOne()).addFilter(new FilterTwo()).addFilter(new FilterThree()); filterChain.doFilter(request, response); &#125;&#125; 结果 过滤器的执行结果顺序如下 123456requst 经过第一个过滤器 msg = 我是请求入参requst 经过第二个过滤器 msg = 我是请求入参requst 经过第三个过滤器 msg = 我是请求入参response 经过第三个过滤器 msg = 我是响应出参response 经过第二个过滤器 msg = 我是响应出参response 经过第一个过滤器 msg = 我是响应出参","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"调停者模式","slug":"设计模式-调停者模式","date":"2022-03-22T13:48:45.941Z","updated":"2022-04-06T12:42:14.808Z","comments":false,"path":"2022/03/22/设计模式-调停者模式/","link":"","permalink":"http://example.com/2022/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"调停者模式又叫调解者模式或者中介者模式，用一个中介对象封装一系列的对象的交互 中介者模式是用来降低多个对象和类之间的通信复杂性的 通过提供一个中介者类将系统中的多对多关系变成一对多的关系 中介者模式主要包含4个角色 抽象中介者(Mediator) 它是中介者的接口 提供了同事对象注册与转发同事对象信息的抽象方法 具体中介者(ConcreteMediator) 实现中介者接口 定义一个List来管理同事对象 协调各个同事角色之间的交互关系 抽象同事者类(Colleague) 定义同事类的接口 保存中介者对象 提供同事对象交互的抽象方法 实现所有同事类相互影响的公共功能 具体同事类(ConcreteColleague) 是抽象同事类的实现者 当需要与其他同事类交互时 由中介者对象负责后续的交互 调停者模式与门面模式的区别 门面模式是将内部操作封装起来提供给外部进行调用 而中介者模式更侧重于当内部系统相互之间调用比较复杂时由中介对象与统筹和管理 它们一个是对外 一个是对内 下图左侧的图是使用中介者模式之前的内部系统间的调用关系 右侧是使用中介者之后的内部系统间的调用关系 中介者模式的典型应用就是消息中间件 示例 租房的时候 房主将房屋托管给房屋中介 而租房者从房屋中介获取房屋信息 房屋中介充当租房者和房屋所有者之间的中介 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//抽象的中介者public abstract class Mediator &#123; //和某人联系的方法 public abstract void contact(String message, Person person);&#125;//抽象的同事类public abstract class Person &#123; protected String name; protected Mediator mediator; public Person(String name, Mediator mediator) &#123; this.name = name; this.mediator = mediator; &#125; public abstract void contact(String message);&#125;//具体同事类 房东public class HouseOwner extends Person &#123; public HouseOwner(String name, Mediator mediator) &#123; super(name, mediator); &#125; //和中介联系 public void contact(String message) &#123; mediator.contact(message, this); &#125; //获取信息 public void getMessage(String name, String message) &#123; System.out.println(&quot;房主获取到的信息是: &quot; + name + &quot;说&quot; + message); &#125;&#125;//具体同事类 租客public class Tenant extends Person &#123; public Tenant(String name, Mediator mediator) &#123; super(name, mediator); &#125; //和中介联系 public void contact(String message) &#123; mediator.contact(message, this); &#125; //获取信息 public void getMessage(String name, String message) &#123; System.out.println(&quot;租房者获取到的信息是&quot; + name + &quot;说&quot; + message); &#125;&#125;//具体中介类 房产中介 具体中介者一定要聚合各个具体的同事类对象 这样才能相互交流public class MediatorStructure extends Mediator &#123; //租客 private Tenant tenant; //房东 private HouseOwner houseOwner; @Override public void contact(String message, Person person) &#123; if (tenant == person) &#123; //租客 通过中介获取房东的租房信息 houseOwner.getMessage(person.name, message); &#125; if (houseOwner == person) &#123; //房东通过中介获取租客的信息 tenant.getMessage(person.name, message); &#125; &#125; public Tenant getTenant() &#123; return tenant; &#125; public void setTenant(Tenant tenant) &#123; this.tenant = tenant; &#125; public HouseOwner getHouseOwner() &#123; return houseOwner; &#125; public void setHouseOwner(HouseOwner houseOwner) &#123; this.houseOwner = houseOwner; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //创建房屋中介 MediatorStructure mediator = new MediatorStructure(); //创建租房者 Tenant tenant = new Tenant(&quot;李四&quot;, mediator); //创建房东 HouseOwner houseOwner = new HouseOwner(&quot;张三&quot;, mediator); //中介者关联房东和租客 mediator.setTenant(tenant); mediator.setHouseOwner(houseOwner); //租客和房产中介联系 表明要租房 tenant.contact(&quot;我要租一个三室两厅的房子&quot;); //房东和房产中介连写 表示要出租 houseOwner.contact(&quot;我这里有三室两厅的房子你要租吗&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"线程基础知识","slug":"高并发-线程基础知识","date":"2022-03-21T15:06:15.808Z","updated":"2022-04-06T12:40:48.129Z","comments":false,"path":"2022/03/21/高并发-线程基础知识/","link":"","permalink":"http://example.com/2022/03/21/%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"一 基本概念 程序 程序简单来说就是一个可执行文件 进程 系统进行资源分配的基本单位 线程 计算机执行的基本单位 基础面试题 123451、单核CPU设置多线程是否有意义 其实是有意义的 因为并不是所有的操作都是需要消耗CPU 有些时候线程执行到某个步骤后需要等待其他线程或者网络资源的响应 这个时候让掉CPU是可以提高整个进程的执行效率的2、线程数设置多少比较合适线程计算公式 Nthread = Ncpu * Ucpu(1+W/C) Ncpu是处理器的核的数目 Ucpu是期望的cpu的使用率 W/C是等待时间与计算时间的比率 在实际开发中一般是先预设线程数是2倍的cpu核心数 - 1 然后通过压测去调整 二 创建线程的5种方法 继承Thread 重写Run方法 1234567public class MyThread extends Thread &#123; @Override public void run() &#123; //实现自己的业务逻辑 super.run(); &#125;&#125; 实现Runnable接口 重写run方法 123456public class MyThread implements Runnable &#123; @Override public void run() &#123; //实现自己的业务逻辑 &#125;&#125; 利用线程池ThreadPoolExecutor/ExecutorService 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; ThreadPoolExecutor pool = new ThreadPoolExecutor( 4, 8, 1, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(100), new ThreadPoolExecutor.CallerRunsPolicy()); pool.execute(new Runnable() &#123; @Override public void run() &#123; //执行业务逻辑 &#125; &#125;); &#125;&#125; 利用Callable接口创建带返回值的线程 123456789101112131415161718//callable接口必须接口Futrue类和线程池一起使用public class Client &#123; public static void main(String[] args) throws Exception&#123; ThreadPoolExecutor pool = new ThreadPoolExecutor( 4, 8, 1, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(100), new ThreadPoolExecutor.CallerRunsPolicy()); Future&lt;String&gt; future = pool.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; //执行业务逻辑 return null; &#125; &#125;); String result = future.get(); &#125;&#125; 利用FutureTask创建带返回值的线程 123456789101112public class Client &#123; public static void main(String[] args) throws Exception&#123; FutureTask&lt;String&gt; future = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return null; &#125; &#125;); new Thread(future).start(); String result = future.get(); &#125;&#125; 三 线程的状态线程有6种状态 NEW 线程刚刚创建(Thread对象刚刚创建好 还没有调用start方法) RUNNABLE 可运行状态 此时需要线程调度器来安排执行 有两个子状态 READ(就绪) 和 RUNNING(运行) WAITING 线程等待被唤醒 TIMED_WAITING 隔一段时间后自动唤醒 最典型的就是sleep BLOCKED 被阻塞 正在等待锁 (抢锁没抢到) TERMINATED 线程结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Client &#123; public static void main(String[] args) throws Exception&#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(&quot;2:&quot; + Thread.currentThread().getState()); //RUNNABLE System.out.println(&quot;go on !&quot;); LockSupport.park(); // 阻塞线程 当调用unpark的时候会释放锁 Thread.sleep(3000); synchronized (Client.class) &#123; System.out.println(&quot;执行同步代码块&quot;); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (Client.class) &#123; try &#123; Thread.sleep(20000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); t2.start(); System.out.println(&quot;1:&quot;+t1.getState()); //NEW t1.start(); Thread.sleep(1000); System.out.println(&quot;3:&quot;+ t1.getState()); //WAITING LockSupport.unpark(t1); //释放锁 Thread.sleep(1000); System.out.println(&quot;4:&quot;+ t1.getState()); //TIMED_WAITING Thread.sleep(5000); System.out.println(&quot;5:&quot;+ t1.getState()); //BLOCKED t1.join(); System.out.println(&quot;6:&quot;+t1.getState()); //TERMINATED &#125;&#125; Lock与Synchronized对于线程状态的区别 lock 会触发线程进入WATING状态 而只有Synchronized(经过了操作系统的调度)关键字才会触发线程进入BLOCKED状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Client &#123; public static void main(String[] args) throws Exception&#123; Lock lock = new ReentrantLock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(&quot;2:&quot; + Thread.currentThread().getState()); //RUNNABLE System.out.println(&quot;go on !&quot;); LockSupport.park(); // 阻塞线程 当调用unpark的时候会释放锁 Thread.sleep(3000); lock.lock(); System.out.println(&quot;执行同步代码块&quot;); lock.unlock(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; lock.lock(); try &#123; Thread.sleep(20000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; lock.unlock(); &#125; &#125;); t2.start(); System.out.println(&quot;1:&quot;+t1.getState()); //NEW t1.start(); Thread.sleep(1000); System.out.println(&quot;3:&quot;+ t1.getState()); //WAITING LockSupport.unpark(t1); //释放锁 Thread.sleep(1000); System.out.println(&quot;4:&quot;+ t1.getState()); //TIMED_WAITING Thread.sleep(5000); System.out.println(&quot;5:&quot;+ t1.getState()); //与上面的例子不一样 这里线程的状态是WAITING状态 t1.join(); System.out.println(&quot;6:&quot;+t1.getState()); //TERMINATED &#125;&#125; 四 线程打断interrupt线程打断的三个方法 1231、interrupt(); //打断某个线程 设置标志位 至于设置了打断标志位后线程该如何处理 是由线程本身控制的(自己写代码去控制)2、isInterrupted(); //查询某个线程是否被打断过 查询标志位3、static interrupted(); //查询当前线程是否被打断过 并重置打断标志 123456789101112131415161718192021222324252627282930313233343536373839public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; while (true) &#123; //如果线程被打断了 if (Thread.currentThread().isInterrupted()) &#123; System.out.println(&quot;Thread is interrupted!&quot;); System.out.println(Thread.currentThread().isInterrupted()); //只是查询是否设置过标志位 true break; &#125; &#125; &#125;); t1.start(); Thread.sleep(1000); t1.interrupt(); //设置线程中断标志位 t1.join(); &#125;&#125;public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; while (true) &#123; //如果线程被打断了 if (Thread.interrupted()) &#123; System.out.println(&quot;Thread is interrupted!&quot;); System.out.println(Thread.interrupted()); //查询并且重置标志位了 所以这里是false break; &#125; &#125; &#125;); t1.start(); Thread.sleep(1000); t1.interrupt(); //设置线程中断标志位 t1.join(); &#125;&#125; 当执行线程的sleep、wait、join等方法的时候 如果这个线程被中断了(interrupt方法) 线程是会抛出InterruptedException的 具体如何处理InterruptedException这个实际上还是交给线程自己来处理 你可以选择忽略 也可以选择终止线程 12345678910111213141516171819public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; while (true) &#123; try &#123; Thread.sleep(10000); &#125;catch (InterruptedException e) &#123; //一旦抛出了这个异常 jvm会自动的将这个线程的中断状态给复位 所以此时调用Thread.currentThread().isInterrupted() 返回的是false System.out.println(&quot;抛出InterruptedException&quot;); System.out.println(Thread.currentThread().isInterrupted()); &#125; &#125; &#125;); t1.start(); Thread.sleep(1000); t1.interrupt(); //设置线程中断标志位 t1.join(); &#125;&#125; 利用lockInterruptibly()方法来中断正在获取锁的线程 一般情况下 如果一个线程正在获取锁 它是没有办法被打断的 但是如果采用的是lock的可重入锁 则可以利用lock.lockInterruptibly()方法来中断正在抢锁的线程 (需要抢锁的线程先执行interrupt()方法设置标志位) 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Client &#123; public static void main(String[] args) throws Exception &#123; Lock lock = new ReentrantLock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;t1 start&quot;); lock.lock(); try &#123; System.out.println(&quot;t1 running&quot;); Thread.sleep(10000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;t1 end&quot;); lock.unlock(); &#125; &#125; &#125;); t1.start(); Thread.sleep(1000); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;t2 start&quot;); try &#123; //这个方法可以中断获取锁的线程 lock.lockInterruptibly(); System.out.println(&quot;t2 running&quot;); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; System.out.println(&quot;t2 end&quot;); &#125; &#125;); t2.start(); Thread.sleep(1000); t2.interrupt(); System.out.println(&quot;t2 interrupt&quot;); &#125;&#125; 五 如何优雅的结束一个线程 利用线程自带的stop方法结束线程 这种方式比较粗暴 已经被废弃了 这是因为stop方法在结束线程前 会释放所有的锁 并且不做善后工作 这样就容易出现因为释放锁而导致数据不一致的问题 123456789101112131415161718192021public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(&quot;running&quot;); Thread.sleep(1000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); t1.start(); Thread.sleep(5000); t1.stop(); &#125;&#125; suspend和resume方法 这两个方法一个是暂停线程(suspend)一个是恢复线程(resume) 但是这两个方法容易引起死锁的问题 因为suspend方法不会释放锁 另外suspend/resume 只能是暂停一个线程 并不能结束一个线程 1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(&quot;running&quot;); Thread.sleep(1000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); t1.start(); Thread.sleep(5000); t1.suspend(); //暂停线程 但是不会释放锁 Thread.sleep(3000); t1.resume(); //恢复线程 &#125;&#125; 利用Volatile结束线程 这个是结束线程最常用也是一种优雅结束线程的方式 1234567891011121314151617181920212223242526272829public class Client &#123; private static volatile boolean flag = true; public static void main(String[] args) throws Exception &#123; AtomicInteger count = new AtomicInteger(0); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (flag) &#123; try &#123; count.incrementAndGet(); System.out.println(&quot;sleep前 count = &quot; + count.get()); Thread.sleep(1000); System.out.println(&quot;sleep后 count = &quot; + count.get()); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;end count = &quot; + count.get()); &#125; &#125;); t1.start(); Thread.sleep(5000); flag = false; //结束线程 Thread.sleep(3000); &#125;&#125; 利用interrupt方法来结束线程 123456789101112131415161718192021222324252627282930public class Client &#123; public static void main(String[] args) throws Exception &#123; AtomicInteger count = new AtomicInteger(0); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (!Thread.interrupted()) &#123; count.incrementAndGet(); Long start = System.currentTimeMillis(); //模拟业务操作的耗时 System.out.println(&quot;sleep执行前 count = &quot; + count); while (true) &#123; Long end = System.currentTimeMillis(); if (end - start &gt; 1000) &#123; break; &#125; &#125; System.out.println(&quot;sleep执行后 count = &quot; + count); &#125; System.out.println(&quot;end2 count = &quot; + count.get()); &#125; &#125;); t1.start(); Thread.sleep(5000); t1.interrupt(); Thread.sleep(3000); &#125;&#125; ​ volatile和interrupt都不能精确的控制线程的结束 它们都必须等到线程执行到读取interrupted方法或者vaolatile变量的时候 线程才能结束如果需要更精确的控制线程的结束则需要用到锁","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"模板方法模式","slug":"设计模式-模板方法","date":"2022-03-21T14:25:16.627Z","updated":"2022-04-06T12:43:58.908Z","comments":false,"path":"2022/03/21/设计模式-模板方法/","link":"","permalink":"http://example.com/2022/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/","excerpt":"","text":"模板方法模式是指定义一个操作中的算法框架 而将一些步骤延迟到子类去实现。模板方法模式实际上封装了一个固定的流程，该流程有几个步骤组成，具体的步骤可以有子类进行不同的实现。典型的应用案例是JdbcTemplate 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//抽象的模板类public abstract class AbstractCourse &#123; public final void createCourse() &#123; //发布预习资料 postPreResource(); //制作PPT课件 createPPT(); //在线直播 liveVideo(); //布置作业 postHomework(); &#125; protected abstract void postHomework(); protected abstract void liveVideo(); protected abstract void createPPT(); protected abstract void postPreResource();&#125;public class JavaCourse extends AbstractCourse &#123; @Override protected void postHomework() &#123; System.out.println(&quot;布置java家庭作业&quot;); &#125; @Override protected void liveVideo() &#123; System.out.println(&quot;java课程在线直播&quot;); &#125; @Override protected void createPPT() &#123; System.out.println(&quot;制作java课程PPT&quot;); &#125; @Override protected void postPreResource() &#123; System.out.println(&quot;发布java课程预习资料&quot;); &#125;&#125;public class PythonCourse extends AbstractCourse &#123; @Override protected void postHomework() &#123; System.out.println(&quot;布置python家庭作业&quot;); &#125; @Override protected void liveVideo() &#123; System.out.println(&quot;python课程在线直播&quot;); &#125; @Override protected void createPPT() &#123; System.out.println(&quot;制作python课程PPT&quot;); &#125; @Override protected void postPreResource() &#123; System.out.println(&quot;发布python课程预习资料&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; PythonCourse c1 = new PythonCourse(); c1.createCourse(); JavaCourse c2 = new JavaCourse(); c2.createCourse(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"poi-tl生成Word文档","slug":"FAQ-poi-tl生成Word文档","date":"2022-03-19T12:51:53.618Z","updated":"2022-04-06T13:17:42.069Z","comments":false,"path":"2022/03/19/FAQ-poi-tl生成Word文档/","link":"","permalink":"http://example.com/2022/03/19/FAQ-poi-tl%E7%94%9F%E6%88%90Word%E6%96%87%E6%A1%A3/","excerpt":"","text":"poi-tl 是word模板引擎 可以根据word模板和数据生成word文档 利用poi-tl可以生成很多样式丰富的word poi-tl官方文档 一 poi-tl依赖12345&lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.11.1&lt;/version&gt;&lt;/dependency&gt; 使用poi-tl的时候因为有word模板文件 maven默认是不会打包的 所以需要设置一下maven的资源目录的配置 以便能够将doc文件打包到classpath下 12345678910111213141516171819&lt;!-- 资源目录 --&gt;&lt;resources&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.docx&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.docx&lt;/exclude&gt; &lt;/excludes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 二 项目结构 完整的项目依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.poi.tl.test&lt;/groupId&gt; &lt;artifactId&gt;poi-tl-test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.11.1&lt;/version&gt; &lt;exclusions&gt; &lt;!--需要排除xalan依赖 不然会报错 Not supported: http://javax.xml.XMLConstants/property/accessExternalDTD--&gt; &lt;exclusion&gt; &lt;artifactId&gt;xalan&lt;/artifactId&gt; &lt;groupId&gt;xalan&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.docx&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.docx&lt;/exclude&gt; &lt;/excludes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 三 示例 文本 在word模板文件中使用&#123;&#123;var&#125;&#125;来表示一段文本 其中文本的数据类型包括 String 普通文本 TextRenderData 有样式的文本 HyperlinkTextRenderData 超链接和锚点文本 Object 调用 toString() 方法转化为文本 文本换行使用\\n字符 代码示例 12345678910111213141516171819202122232425262728293031323334@RequestMapping(path = &quot;/download&quot;, method = RequestMethod.GET)public void download(HttpServletRequest request, HttpServletResponse response) &#123; OutputStream out = null; XWPFTemplate template = null; BufferedOutputStream bos = null; try &#123; String title = &quot;测试.docx&quot;; title = URLEncoder.encode(title, StandardCharsets.UTF_8.toString()); response.reset(); //设置doc输出时中文不会乱码 response.setContentType(&quot;application/octet-stream; charset=UTF-8&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename*=utf-8&#x27;&#x27;&quot; + title); out = response.getOutputStream(); bos = new BufferedOutputStream(out); //template.docx是word模板文件 template = XWPFTemplate //compile 编译模板 .compile(Objects.requireNonNull(DocController.class.getClassLoader() .getResourceAsStream(&quot;template.docx&quot;))) //render 渲染数据 .render(new HashMap&lt;String, Object&gt;()&#123;&#123; put(&quot;name&quot;, &quot;张三&quot;); put(&quot;author&quot;, new TextRenderData(&quot;000000&quot;, &quot;张三&quot;)); put(&quot;link&quot;, new HyperlinkTextRenderData(&quot;poi-tl官网&quot;, &quot;http://deepoove.com&quot;)); &#125;&#125;); //write 输出到流 template.write(bos); bos.flush(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; PoitlIOUtils.closeQuietlyMulti(template, bos, out); &#125;&#125; 模板 下面是word模板文件中(template.docx)的内容 生成的word(测试.docx)的内容 图片 在word模板文件中使用&#123;&#123;&#64;var&#125;&#125;来表示图片 其中图片的数据类型包括 String 图片的url或本地路径 默认使用图片自身尺寸 PictureRenderData 推荐使用工厂 Pictures构建图片模型 代码示例 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(path = &quot;/download&quot;, method = RequestMethod.GET) public void download(HttpServletRequest request, HttpServletResponse response) &#123; OutputStream out = null; XWPFTemplate template = null; BufferedOutputStream bos = null; try &#123; String title = &quot;测试.docx&quot;; title = URLEncoder.encode(title, StandardCharsets.UTF_8.toString()); response.reset(); //设置doc输出时中文不会乱码 response.setContentType(&quot;application/octet-stream; charset=UTF-8&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename*=utf-8&#x27;&#x27;&quot; + title); out = response.getOutputStream(); bos = new BufferedOutputStream(out); BufferedImage bufferImage = new BufferedImage(100, 100, BufferedImage.TYPE_BYTE_GRAY); template = XWPFTemplate .compile(Objects.requireNonNull(DocController.class.getClassLoader().getResourceAsStream(&quot;template.docx&quot;))) .render(new HashMap&lt;String, Object&gt;()&#123;&#123; put(&quot;image&quot;, &quot;/xx/xx/poi-tl-test/target/classes/static/logo.png&quot;); // 指定图片路径 put(&quot;image1&quot;, Pictures.ofLocal(&quot;/xx/xx/test/poi-tl-test/target/classes/static/logo.png&quot;).size(120, 120).create()); // 设置图片宽高 put(&quot;streamImg&quot;, Pictures.ofStream(new FileInputStream(&quot;/xx/xx/poi-tl-test/target/classes/static/logo.jpeg&quot;), PictureType.JPEG) // 图片流 .size(100, 120).create()); put(&quot;urlImg&quot;, Pictures.ofUrl(&quot;http://deepoove.com/images/icecream.png&quot;) // 网络图片(注意网络耗时对系统可能的性能影响) .size(100, 100).create()); put(&quot;svg&quot;, &quot;https://img.shields.io/badge/jdk-1.6%2B-orange.svg&quot;); // svg图片 put(&quot;buffered&quot;, Pictures.ofBufferedImage(bufferImage, PictureType.PNG) //java图片 .size(100, 100).create()); &#125;&#125;); template.write(bos); bos.flush(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; PoitlIOUtils.closeQuietlyMulti(template, bos, out); &#125; &#125; 模板 生成的word(测试.docx)的内容 表格 在word模板文件中使用 &#123;&#123;&#35;var&#125;&#125;来表示表格 其中表格的数据类型包括 TableRenderData 推荐使用工厂Tables、Rows 和 Cells构建表格模型 代码示例 12345// 一个2行2列的表格put(&quot;table0&quot;, Tables.of(new String[][] &#123; new String[] &#123; &quot;00&quot;, &quot;01&quot; &#125;, new String[] &#123; &quot;10&quot;, &quot;11&quot; &#125; &#125;).border(BorderStyle.DEFAULT).create()); 12345// 第0行居中且背景为蓝色的表格RowRenderData row0 = Rows.of(&quot;姓名&quot;, &quot;学历&quot;).textColor(&quot;FFFFFF&quot;) .bgColor(&quot;4472C4&quot;).center().create();RowRenderData row1 = Rows.create(&quot;李四&quot;, &quot;博士&quot;);put(&quot;table1&quot;, Tables.create(row0, row1)); 12345// 合并第1行所有单元格的表格RowRenderData row0 = Rows.of(&quot;列0&quot;, &quot;列1&quot;, &quot;列2&quot;).center().bgColor(&quot;4472C4&quot;).create();RowRenderData row1 = Rows.create(&quot;没有数据&quot;, null, null);MergeCellRule rule = MergeCellRule.builder().map(Grid.of(1, 0), Grid.of(1, 2)).build();put(&quot;table3&quot;, Tables.of(row0, row1).mergeRule(rule).create()); 其他数据类型见官方文档！","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot手写starter","slug":"SpringBoot-手写starter","date":"2022-03-19T09:47:05.233Z","updated":"2022-04-06T13:19:18.447Z","comments":false,"path":"2022/03/19/SpringBoot-手写starter/","link":"","permalink":"http://example.com/2022/03/19/SpringBoot-%E6%89%8B%E5%86%99starter/","excerpt":"","text":"SpringBoot手写starter组件案例 以集成Redisson为例 一、工程搭建这一步只是搭建一个maven项目 不做表述 下面是完整的工程示例 二、依赖maven依赖如下 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.redisson.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;!--optional为true 表明这个依赖是可选的 相当于这个依赖不会被其他项目锁继承--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.16.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--这个是用来配置springboot 配置文件属性自动提示用的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 三、创建相关的配置类 RedissonProperties 本文Redisson的使用不是重点 所以此处只是连接单机redis的一些配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.redisson.spring.boot.config;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;spring.redisson&quot;)public class RedissonProperties &#123; private String host = &quot;localhost&quot;; private int port = 6379; private int timeout = 10000; private boolean ssl; private String password; public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public int getTimeout() &#123; return timeout; &#125; public void setTimeout(int timeout) &#123; this.timeout = timeout; &#125; public boolean isSsl() &#123; return ssl; &#125; public void setSsl(boolean ssl) &#123; this.ssl = ssl; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; RedissonAutoConfiguration 这个类相当于是starter的一个入口类 123456789101112131415161718192021222324252627282930313233343536package com.redisson.spring.boot;import com.redisson.spring.boot.config.RedissonProperties;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.config.Config;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnClass(Redisson.class)//@EnableConfigurationProperties作用是使得@ConfigurationProperties 注解的类生效@EnableConfigurationProperties(RedissonProperties.class)public class RedissonAutoConfiguration &#123; @Bean RedissonClient redissonClient(RedissonProperties redissonProperties) &#123; Config config = new Config(); // 判断是否启用ssl String prefix = redissonProperties.isSsl() ? &quot;rediss://&quot; : &quot;redis://&quot;; String host = redissonProperties.getHost(); int port = redissonProperties.getPort(); int timeout = redissonProperties.getTimeout(); String password = redissonProperties.getPassword(); config.useSingleServer() .setAddress(prefix + host + &quot;:&quot; + port) .setConnectTimeout(timeout) .setPassword(password); return Redisson.create(config); &#125;&#125; 四、创建配置文件 spring.factories 这个文件是Spring SPI机制的核心文件 SpringBoot 在启动时会扫描这个文件 并将其中配置的类装配为bean 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.redisson.spring.boot.RedissonAutoConfiguration additional-spring-configuration-metadata.json 这个文件也可以不加 加了可以对自动提示的文件做一些注释的说明 123456789101112131415161718192021222324252627&#123; &quot;properties&quot;: [ &#123; &quot;name&quot;: &quot;spring.redissin.host&quot;, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;description&quot;: &quot;redis服务器地址.&quot;, &quot;defaultValue&quot;: &quot;localhost&quot; &#125;, &#123; &quot;name&quot;: &quot;spring.redisson.port&quot;, &quot;type&quot;: &quot;java.lang.Integer&quot;, &quot;description&quot;: &quot;redis服务器端口.&quot;, &quot;defaultValue&quot;: 6379 &#125;, &#123; &quot;name&quot;: &quot;spring.redisson.timeout&quot;, &quot;type&quot;: &quot;java.lang.Integer&quot;, &quot;description&quot;: &quot;redis连接超时时间&quot;, &quot;defaultValue&quot;: 1000 &#125;, &#123; &quot;name&quot;: &quot;spring.redisson.ssl&quot;, &quot;type&quot;: &quot;java.lang.Boolean&quot;, &quot;description&quot;: &quot;redis 连接是否是佛那个ssl&quot; &#125; ]&#125; 以上两个配置文件都要在starter的META-INF文件夹下新建","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"类加载机制与getResource()路径分析","slug":"FAQ-类加载机制与getResource()路径分析","date":"2022-03-16T15:35:21.329Z","updated":"2022-04-06T12:48:28.286Z","comments":false,"path":"2022/03/16/FAQ-类加载机制与getResource()路径分析/","link":"","permalink":"http://example.com/2022/03/16/FAQ-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EgetResource()%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/","excerpt":"","text":"一 类加载过程一个类在JVM中的生命周期主要要包括以下几个阶段 分别是 装载、链接、初始化、实例化、 使用、卸载 装载阶段 这个阶段主要是将class文件加载到JVM的方法区/元空间 连接阶段 这个阶段又被细分为3个阶段 分别是 验证、准备、解析 连接阶段的主要作用是将class文件中变量的符号引用 转为直接引用 验证 确认读取文件类型的正确性，即class是否符合Java规范并且不会损害JVM的完整性。主要是检查代码是否有格式错误。 准备 为静态成员变量分配内存同时设置默认初始值。静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。(仅包含类变量,不包含实例变量) 解析 把符号引用转为直接引用的过程。例如将变量名转为内存地址。以后使用这个成员变量时，就直接去这个内存地址去找了。同时类的成员方法也会被映射到某个内存地址以待调用。 初始化阶段 类的初始化阶段会为静态成员变量赋予正确的初始值，并且调用类中所有的静态代码块。—调用静态成员变量的初始化代码。例如类中定义了一个静态成员变量static int a = 1; 之前准备阶段已经为变量a分配了内存空间，并且将a的值设为了0，此时才会将a的值设为1。—调用类中所有的静态代码块。static{……} 事实上，编译阶段Java编译器会把类中所有的静态变量初始化代码和静态代码块封装到一个方法中去，此时JVM会调用这个方法。方法程序员不能调用，只能被JVM调用。方法只在初始化阶段执行且只被执行一次。因此静态变量只被初始化一次，静态方法只被执行一次。 实例化阶段 在类的初始化完成之后，这个类就随时可以使用了。但是此时只能使用该类的静态成员(变量和方法)。当创建一个类的对象时(例：使用new关键字)，此时进行的是类的实例化操作。 在堆中为实例变量分配内存空间。 调用类中所有的实例代码块。{……} 调用相应的构造方法。 事实上，编译阶段Java编译器会把类中所有的实例变量初始化代码和实例代码块封装到一个方法中去，此时JVM会调用这个方法。方法程序员不能调用，只能被JVM调用。方法在每次实例化时都会被执行。实例代码块按源文件顺序执行，最后才执行构造方法 并不是所有时候这七个阶段都是顺序进行的，其中加载、验证、准备、初始化、卸载是固定顺序开始的，解析阶段不一定。解析在某些情况下可以在初始化阶段之后再开始，这也是为了支持运行时绑定（也成为动态绑定） 概念剖析 符号引用 其实就是我们在写代码的过程中声明的那些变量 直接引用 直接引用是将这些符号引用 变成了一个个的真实的内存地址 主动使用 JAVA中对类的使用有两种方式 分别是主动使用和被动使用 第一次主动使用才进行初始化,之后就不再初始化 主动使用包含7种情况 创建类的实例 new 操作符 访问某个类或接口的静态变量 或者对静态变量进行赋值 静态常量是不会触发类的初始化的 调用类的静态方法 反射 Class.forName(“com.xxx.xxx”) 初始化一个类的子类 父类会初始化 Java虚拟机启动时被标明为启动类的类 包含main方法的类 JDK7开始提供的动态语言支持,java.lang.invoke.MethodHandle 被动使用 除了主动使用的7种情况,其他使用Java类的方式都被看作是对类的被动使用,都不会导致类的初始化,但是依然会对类进行装载和连接 类的主动使用和被动使用案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Test2 &#123; static &#123; System.out.println(&quot;this is Test2&quot;); &#125; public static void main(String[] args) throws Throwable &#123; //类的主动使用案例 //第一种 使用new 操作符 触发类的初始化 //People people = new People(); //第二种 访问类的静态变量 触发初始化 如果访问的是静态常量是不会触发初始化的 //String attr = People.attr; //第二种的变种 为类的静态变量赋值 触发类的初始化 //People.attr2 = &quot;This is People attr2&quot;; //第三种 子类初始化 触发父类初始化 //Man man = new Man(); //第四种 调用类的静态方法 触发初始化 //People.sayHello(); //第五种 反射触发类的初始化 //Class&lt;?&gt; people = Class.forName(&quot;com.springboot.test.test1.People&quot;); //第六种 执行一个类的main方法 触发类的初始化 //前面5种示例都会先输出一句话 this is Test2 证明Test2类是最先被初始化的 //类的被动使用案例 //第一种 这种不会触发类的初始化 是类的被动使用 People[] people = new People[2]; //第二种 //System.out.println(People.attr3); &#125;&#125;class People &#123; static &#123; System.out.println(&quot;This is People&quot;); &#125; public static String attr = &quot;This is People attr&quot;; public static String attr2; public final static String attr3 = &quot;This is People attr3&quot;; public static void sayHello() &#123; System.out.println(&quot;Hello&quot;); &#125; public String sayHello2(String name) &#123; return &quot;Hello2&quot; + name; &#125;&#125;class Man extends People &#123; static &#123; System.out.println(&quot;This is Man&quot;); &#125;&#125; 二 getResource() 的几种路径在Java中获取资源的时候，经常用到getResource和getResourceAsStream，下面总结一下这两种资源获取源文件的路径差异 Class.getResource(String path) path 不以/开头时 就是以该class文件所在包作为资源的根路径 path 以/开头的时候 就是从classpath根路径去获取资源 12345678public class Test&#123; public static void main(String[] args) &#123; System.out.println(Test.class.getResource(&quot;&quot;)); System.out.println(Test.class.getResource(&quot;/&quot;)); &#125;&#125; Class.getClassLoader().getResource(String path) 这种情况下path不能以/开头 通过类加载器去获取资源时 是使用的逐级向上委托的形式加载的 此时的/表示Boot ClassLoader 因为这个类加载器是C++实现的，所以加载范围为null 所以这种方式不能以/开头 12345678public class Test&#123; public static void main(String[] args) &#123; System.out.println(Test.class.getClassLoader().getResource(&quot;&quot;)); //classpath根路径 System.out.println(Test.class.getClassLoader().getResource(&quot;/&quot;)); &#125;&#125; Class.getResourceAsStream(String path) path 不以/开头时，默认是指所在类的相对路径，从这个相对路径下取资源 path 以/开头时 则是从项目的classpath根下获取资源，就是要写相对于classpath根下的绝对路径 12345678910111213com |-github |-demo | |-A.class | |-1.txt |-B.class |-2.txt#上面是模拟的文件树 相对路径：InputStream is= A.class.getResourceAsStream(&quot;1.txt&quot;)路径不是以/开头，说明这是一个相对路径，相对的是A.class这个文件，所以，这里的“1.txt”所指的正确位置是与A.class处于同一目录下的1.txt文件，这一文件是存在的，所引不会报错。如果我们按相对路径的方式通过A去加载2.txt，则路径应该这样描述：InputStream is= A.class.getResourceAsStream(&quot;../2.txt&quot;)用..表示上一级目录。 Clss.getClassLoader().getResourceAsStream(String path) path不能以/开头，默认则是从classpath根路径获取资源 如果以‘/’ 开头，则 返回的是classLoader加载器Boot ClassLoader的加载范围，所以返回的也是null，所以不能以/开头","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot自动装配核心原理(二)","slug":"SpringBoot-自动装配核心原理02","date":"2022-03-15T13:58:46.248Z","updated":"2022-04-06T13:19:44.562Z","comments":false,"path":"2022/03/15/SpringBoot-自动装配核心原理02/","link":"","permalink":"http://example.com/2022/03/15/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%8602/","excerpt":"","text":"一 SpringBoot自动装配流程分析在上一节中我们已经知道了SpringBoot框架的入口在@EnableAutoConfiguration注解中 下面是EnableAutoConfiguration注解的源码 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 通过上一讲已经知道@Import注解的作用 所以SpringBoot框架真正的核心入口在AutoConfigurationImportSelector类的selectImports方法中 12345678910111213141516171819202122232425262728293031323334@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; //getAutoConfigurationEntry方法会去查找spring.factories文件 并将文件中的类装配到容器中 AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125;protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; //获取EnableAutoConfiguration注解定义的属性exclude、excludeName与他们对应的值 AnnotationAttributes attributes = getAttributes(annotationMetadata); //查找类路径下(classpath)/META-INF/spring.factories文件 并将这些文件中key为 //org.springframework.boot.autoconfigure.EnableAutoConfiguration的类权限定名加载进来 只会加载 //EnableAutoConfiguration这个key下的类 其他的key不会被加载 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //删除一些重复的对象 底层是一个LinkedHashMap configurations = removeDuplicates(configurations); //得到需要排除的类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); //校验排除的这些类是否正确(类路径下是否能找到这些类) checkExcludedClasses(configurations, exclusions); //把要排除的类从configurations中删除 configurations.removeAll(exclusions); //根据META-INF/spring-autoconfigure-metadata.properties文件来排除掉 //spring.factories文件中EnableAutoConfigurationKey中需要满足特定条件装配的bean configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); &#125; 二 自动装配要点排除指定的类 12345678//通过在@SpringBootApplication注解中设置exclude属性可以排除掉指定的对象@SpringBootApplication(exclude = RedisAutoConfiguration.class)public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 自动装配中条件的解析 SpringBoot自动装配的筛选条件源码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//在getConfigurationClassFilter().filter(configurations)方法中 下面是filter方法的源码List&lt;String&gt; filter(List&lt;String&gt; configurations) &#123; long startTime = System.nanoTime(); //candidates是META/spring.factories文件配置的key为EnableAutoConfiguration的类的名称 String[] candidates = StringUtils.toStringArray(configurations); boolean skipped = false; //这里的filter一共有三个 分别是OnClassCondition OnWebApplicationCondition OnBeanCondition for (AutoConfigurationImportFilter filter : this.filters) &#123; //这里则是开始进行匹配 spring-autoconfigure-metadata.properties文件中配置的条件 match源码在下面 boolean[] match = filter.match(candidates, this.autoConfigurationMetadata); for (int i = 0; i &lt; match.length; i++) &#123; if (!match[i]) &#123; candidates[i] = null; skipped = true; &#125; &#125; &#125; //以下省略若干代码 &#125;//OnClassCondition match方法源码public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123; ConditionEvaluationReport report = ConditionEvaluationReport.find(this.beanFactory); //这里是以spring.factories文件中配置的内容+.ConditionalOnClass做key去spring-autoconfigure-metadata.properties //对应的class 然后判断这个条件class在类路径下是否存在 如果存在match为true 否则match为false ConditionOutcome[] outcomes = getOutcomes(autoConfigurationClasses, autoConfigurationMetadata); boolean[] match = new boolean[outcomes.length]; for (int i = 0; i &lt; outcomes.length; i++) &#123; match[i] = (outcomes[i] == null || outcomes[i].isMatch()); if (!match[i] &amp;&amp; outcomes[i] != null) &#123; logOutcome(autoConfigurationClasses[i], outcomes[i]); if (report != null) &#123; report.recordConditionEvaluation(autoConfigurationClasses[i], this, outcomes[i]); &#125; &#125; &#125; return match;&#125;private ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, int start, int end, AutoConfigurationMetadata autoConfigurationMetadata) &#123; ConditionOutcome[] outcomes = new ConditionOutcome[end - start]; for (int i = start; i &lt; end; i++) &#123; String autoConfigurationClass = autoConfigurationClasses[i]; if (autoConfigurationClass != null) &#123; String candidates = autoConfigurationMetadata.get(autoConfigurationClass, &quot;ConditionalOnClass&quot;); if (candidates != null) &#123; outcomes[i - start] = getOutcome(candidates); &#125; &#125; &#125; return outcomes;&#125;@Overridepublic String get(String className, String key, String defaultValue) &#123; String value = this.properties.getProperty(className + &quot;.&quot; + key); return (value != null) ? value : defaultValue;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"SpringBoot集成XXL-JOB","slug":"SpringBoot-集成xxlJob","date":"2022-03-12T04:03:27.735Z","updated":"2022-04-06T13:18:55.567Z","comments":false,"path":"2022/03/12/SpringBoot-集成xxlJob/","link":"","permalink":"http://example.com/2022/03/12/SpringBoot-%E9%9B%86%E6%88%90xxlJob/","excerpt":"","text":"一 xxl-job搭建xxl-job框架是一个分布式的任务调度平台，其核心包括两个角色调度中心和执行器 调度中心其实就是xxl-job的控制台 而执行器则是具体的业务工程。xxl-job中文文档 xxl-job架构图 下载xxl-job 地址如下 1https://github.com/xuxueli/xxl-job.git 初始化数据库 xxl-job依赖数据库 其源码中自带了sql 配置调度中心(xxl-job-admin) 调度中心配置文件地址如下 1/xxl-job/xxl-job-admin/src/main/resources/application.properties 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758### 调度中心的端口server.port=8181server.context-path=/xxl-job-admin### actuatormanagement.context-path=/actuatormanagement.health.mail.enabled=false### resourcesspring.mvc.servlet.load-on-startup=0spring.mvc.static-path-pattern=/static/**spring.resources.static-locations=classpath:/static/### freemarkerspring.freemarker.templateLoaderPath=classpath:/templates/spring.freemarker.suffix=.ftlspring.freemarker.charset=UTF-8spring.freemarker.request-context-attribute=requestspring.freemarker.settings.number_format=0.############# mybatismybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml### xxl-job, datasource spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxljob?Unicode=true&amp;characterEncoding=UTF-8spring.datasource.username=数据库用户名spring.datasource.password=数据库密码spring.datasource.driver-class-name=org.gjt.mm.mysql.Driverspring.datasource.type=org.apache.tomcat.jdbc.pool.DataSourcespring.datasource.tomcat.max-wait=10000spring.datasource.tomcat.max-active=30spring.datasource.tomcat.test-on-borrow=truespring.datasource.tomcat.validation-query=SELECT 1spring.datasource.tomcat.validation-interval=30000### xxl-job email(报警用的告警邮箱 如果不需要告警可以不配)spring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### xxl-job, access token(访问的accessToken 不用访问令牌的话可以不设置)xxl.job.accessToken=### xxl-job, i18n (default empty as chinese, &quot;en&quot; as english)xxl.job.i18n=zh_CN## 调度线程池最大线程配置【必填】xxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能xxl.job.logretentiondays=30 关于访问令牌(Token)说明 为提升系统安全性，调度中心和执行器进行安全性校验，双方AccessToken匹配才允许通讯；调度中心和执行器，可通过配置项 “xxl.job.accessToken” 进行AccessToken的设置。调度中心和执行器，如果需要正常通讯，只有两种设置； 设置一：调度中心和执行器，均不设置AccessToken；关闭安全性校验； 设置二：调度中心和执行器，设置了相同的AccessToken； 编译/打包/运行调度中心 将xxl-job-admin项目利用mvn package命令打成jar包 然后通过java -jar的方式启动 或者 直接在IDEA中直接启动xxl-job-admin即可 启动后输入 http://localhost:8181/xxl-job-admin 即可访问xxl-job调度中心 默认的账户密码为admin/123456 至此单机版调度中心搭建完成 如果需要提高系统的稳定性和容错性可以搭建调度中心集群 关于调度中心集群的说明 调度中心支持集群部署，提升调度系统容灾和可用性。调度中心集群部署时，几点要求和建议： DB配置保持一致； 集群机器时钟保持一致（单机集群忽视） 建议：推荐通过nginx为调度中心集群做负载均衡，分配域名。调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。 二 部署执行器xxl-job源码中提供了很多执行器的案例 这里只对SpringBoot执行器进行说明 导入依赖 xxl-job执行器需要导入xxl-job-core依赖 123456&lt;!-- xxl-job-core 版本自己定 建议和xxl-job-admin中依赖的xxl-job-core版本保持一致--&gt;&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt;&lt;/dependency&gt; 进行执行器配置 对执行器进行配置 主要包含两个方面 一是配置文件 二是xxlJobExecutor配置 执行器配置文件如下 12345678910111213141516### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；这个配置为空则需要在xxl-job-admin控制台中手动的配置执行器 如果这个配置填了则是自动注册xxl.job.admin.addresses=http://127.0.0.1:8181/xxl-job-admin### 执行器通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册xxl.job.executor.appname=xxl-job-executor-sample### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。xxl.job.executor.address=### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；xxl.job.executor.ip=### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；xxl.job.executor.port=9999### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；xxl.job.executor.logretentiondays=30 xxlJobExecutor配置 下面配置中的ip和token一般都可以不用 ip执行器会自动去获取 没有必要手动指定 token只有在调度中心也配置了token的情况下才会使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appName; @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;) private String ip; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;) private String accessToken; @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;) private String logPath; @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppName(appName); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125; /** * 针对多网卡、容器内部署等情况，可借助 &quot;spring-cloud-commons&quot; 提供的 &quot;InetUtils&quot; 组件灵活定制注册IP； * * 1、引入依赖： * &lt;dependency&gt; * &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; * &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt; * &lt;version&gt;$&#123;version&#125;&lt;/version&gt; * &lt;/dependency&gt; * * 2、配置文件，或者容器启动变量 * spring.cloud.inetutils.preferred-networks: &#x27;xxx.xxx.xxx.&#x27; * * 3、获取IP * String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress(); */&#125; 在执行器中新建任务 下面是demoJob的示例 123456789101112131415161718192021222324@Componentpublic class SampleXxlJob &#123; private static Logger logger = LoggerFactory.getLogger(SampleXxlJob.class); /** * 1、简单任务示例（Bean模式） * xxl-job的任务包含很多种模式 这里是最简单的bean类型模式 */ @XxlJob(&quot;demoJobHandler&quot;) public ReturnT&lt;String&gt; demoJobHandler(String param) throws Exception &#123; XxlJobLogger.log(&quot;XXL-JOB, Hello World.&quot;); for (int i = 0; i &lt; 5; i++) &#123; XxlJobLogger.log(&quot;beat at:&quot; + i); TimeUnit.SECONDS.sleep(2); &#125; return ReturnT.FAIL; &#125;&#125; 关于xxl-job任务类型的说明 xxl-job的任务类型有很多种具体可以见官方文档 编译/打包/运行执行器 这一步就是将你的springboot项目跑起来 配置任务 首先需要在执行器列表中新建执行器 然后在任务管理界面新增任务","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"XXL-JOB","slug":"XXL-JOB","permalink":"http://example.com/tags/XXL-JOB/"}]},{"title":"ForkJoin与并行流","slug":"FAQ-ForkJoin与并行流","date":"2022-03-09T14:12:44.763Z","updated":"2022-04-06T13:17:07.698Z","comments":false,"path":"2022/03/09/FAQ-ForkJoin与并行流/","link":"","permalink":"http://example.com/2022/03/09/FAQ-ForkJoin%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%B5%81/","excerpt":"","text":"一 ForkJoin简介ForkJoin线程池可以执行一种特殊的任务 它可以把一个大任务拆分成N个小任务并行执行 然后再将多个小任务的结果合并起来 组成大任务的执行结果，ForkJoin其实就是一种分治的思想，ForkJoin线程池是JDK1.7之后引入的。 ForkJoin框架提供了两个主要的子类用于实现ForkJoin任务 12RecursiveAction：用于没有返回结果的任务。RecursiveTask ：用于有返回结果的任务。 ForkJoin示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class Compute &#123; public static void main(String[] args) throws Exception &#123; int[] array = init(100); int val_1 = compute(array); //普通计算 100s左右 int val_2 = computeBinary(array); //普通二分 20s左右 int val_3 = computeForForkJoin(array); //forkjoin集散 5s左右 System.out.println(val_1 == val_2); System.out.println(val_1 == val_3); &#125; private static int[] init(int len) &#123; int[] array = new int[len]; for (int i = 0; i &lt; len; i++) &#123; array[i] = i; &#125; return array; &#125; /** * 没有采用ForkJoin线程池的计算方式 * @param array * @return * @throws Exception */ private static int compute(int[] array) throws Exception &#123; Long start = System.currentTimeMillis(); int val = 0; for (int i = 0; i &lt; array.length; i++) &#123; val+=array[i]; Thread.sleep(100); //模拟计算的耗时 时间太短与ForkJoin差别不明显 &#125; Long end = System.currentTimeMillis(); System.out.println(&quot;不采用forkJoin框架数组求和耗时&quot; + (end - start) + &quot;毫秒&quot;); return val; &#125; /** * 没有采用ForkJoin线程池的计算方式 普通二分 * @param array * @return * @throws Exception */ private static int computeBinary(int[] array) throws Exception &#123; Long start = System.currentTimeMillis(); int val = computeBinary(array, 0, array.length - 1); Long end = System.currentTimeMillis(); System.out.println(&quot;不采用forkJoin框架时 采用二分法对数组求和耗时&quot; + (end - start) + &quot;毫秒&quot;); return val; &#125; private static int computeBinary(int[] array, int start, int end) throws Exception &#123; Thread.sleep(100); //模拟计算的耗时 时间太短与ForkJoin差别不明显 //表示数组只有一个元素需要计算 if (end - start == 0) &#123; return array[start]; &#125; int mid = start + (end - start) / 2; //计算左半部分的数组的和 int left = computeBinary(array, start, mid); //计算右半部分的数组的和 int right = computeBinary(array, mid+1, end); return left + right; &#125; private static int computeForForkJoin(int[] array)&#123; Long start = System.currentTimeMillis(); //初始化一个ForkJoin的线程池 默认会计算机CPU核心数量的线程用于执行子任务 ForkJoinPool pool = new ForkJoinPool(); MyRecursiveTask task1 = new MyRecursiveTask(array, 0, array.length - 1); Integer val = pool.invoke(task1); //forkJoin执行任务 Long end = System.currentTimeMillis(); System.out.println(&quot;采用forkJoin框架数组求和耗时&quot; + (end - start) + &quot;毫秒&quot;); return val; &#125;&#125;class MyRecursiveTask extends RecursiveTask&lt;Integer&gt; &#123; private static final long serialVersionUID = 7391964389420391553L; private int[] array; private int start; private int end; /** * @param array 待求和的数组 * @param start 待求和的数组的起始位置 * @param end 待求和的数组的结束位置 */ public MyRecursiveTask(int[] array, int start, int end) &#123; this.array = array; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; try&#123; Thread.sleep(100); //模拟计算的耗时 时间太短与ForkJoin差别不明显 &#125;catch (Exception e) &#123; // &#125; //表示数组只有一个元素需要计算 if (end - start == 0) &#123; return array[start]; &#125; int mid = start + (end - start) / 2; //计算前半段的数组的和 MyRecursiveTask subTask_1 = new MyRecursiveTask(array, start, mid); //计算后半段的数组的和 MyRecursiveTask subTask_2 = new MyRecursiveTask(array, mid+1, end); //通过fork方法来执行子任务 subTask_1.fork(); subTask_2.fork(); //子任务的结果合并 Integer val_1 = subTask_1.join(); Integer val_2 = subTask_2.join(); return val_1 + val_2; &#125;&#125; 二 java8 ParallelStreamsjava8中的并行流内部采用的其实就是ForkJoinPool 它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available- Processors()得到的。 但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common. parallelism来改变线程池大小，如下所示： System.setProperty(“java.util.concurrent.ForkJoinPool.common.parallelism”,”12”); 这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个 并行流指定这个值。一般而言，让ForkJoinPool`的大小等于处理器数量是个不错的默认值， 除非你有很好的理由，否则我们强烈建议你不要修改它。","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot自动装配核心原理(一)","slug":"SpringBoot-自动装配核心原理01","date":"2022-03-02T14:14:20.003Z","updated":"2022-04-06T13:19:30.448Z","comments":false,"path":"2022/03/02/SpringBoot-自动装配核心原理01/","link":"","permalink":"http://example.com/2022/03/02/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%8601/","excerpt":"","text":"首先我们需要从SpringBoot启动类进行入手 开始分析 12345678910//自动装配的核心入口是这个注解@SpringBootApplicationpublic class App &#123; public static void main(String[] args) throws Exception&#123; //这行代码只是将对象装载到IOC容器中 这里的核心逻辑与Spring的启动流程是一模一样的 //这行代码最终会调用Spring的AbstractApplicationContext.refresh()方法中 SpringApplication.run(App.class, args); &#125;&#125; 如上所示 SpringBoot自动装配的入口在**@SpringBootApplication**注解中 下面是其源码 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; //省略其他代码&#125; @Target(ElementType.TYPE)、@Retention(RetentionPolicy.RUNTIME)、@Documented、@Inherited这四个是元注解 可以忽略 @ComponentScan 这个注解主要是用来做包扫描的 它会对指定包及其子包下的类进行扫描 如果该类包含@Component注解 则将这个类装配到IOC容器中 如果没有指明basePackages属性的话 则会去扫描该注解修饰的类所在的包及其子包 @SpringBootConfiguration @SpringBootConfiguration注解源码如下 可以看到这个注解就是用来标识某个类是Spring的配置类 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration //标识配置类的@Indexed //这个是为了提升Spring项目性能的 因为当一个项目足够复杂的时候 @ComponentScan需要扫描的时候就会需要进行多次IO操作 比较耗费性能 这个注解能将@Component修饰的类直接在编译器就生成好索引文件 @ComponentScan就不需要再单独的去扫描了public @interface SpringBootConfiguration &#123; //省略其他代码&#125; @Indexed @Indexed是Spring 5.0出现的 这个注解可以提升@ComponentScan注解的扫描效率，它需要配合spring-context-indexer包来使用 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;&lt;/dependency&gt; 需要注意的是@Component注解已经内置了@Indexed注解了 如果我们希望@Indexed注解生效 只需要添加spring-conetxt-indexer依赖即可 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Indexedpublic @interface Component &#123; String value() default &quot;&quot;;&#125; 至此**@SpringBootApplication**注解就只剩下@EnableAutoConfiguration注解了 该注解是SpringBoot自动装配的核心注解 其源码如下 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; //省略若干代码&#125; @AutoConfigurationPackage 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;//省略若干代码&#125; @AutoConfigurationPackage内部只也包含了一个**@Import注解 从这里可以看出核心注解是@Import** @Import @Import注解的作用是将一个类或者多个类导入到Spring容器中 如下面的示例(import的静态导入) 1234567891011121314151617181920212223242526272829303132//Student类并没有添加@Component注解@Datapublic class Student &#123; private String name = &quot;张三&quot;; private Integer age = 18;&#125;//Teacher类并没有添加@Component注解@Datapublic class Teacher &#123; private String name = &quot;李四&quot;; private Integer age = 20;&#125;//通过@Import注解将Student和Teacher类注入到容器中@Import(&#123;Student.class, Teacher.class&#125;)@SpringBootApplicationpublic class App01 &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(App01.class, args); Student student = context.getBean(Student.class); System.out.println(student.getName()); Teacher teacher = context.getBean(Teacher.class); System.out.println(teacher.getName()); &#125;&#125; 如果**@Import**注解中引入的类是实现了ImportSelector接口的类 那么该类不会被导入到Spring容器中 而是会把ImportSelector接口的selectImports()方法的返回值(返回值应该是类的全限定名)作为bean注入到spring容器中 示例如下:(import的动态导入) 12345678910111213141516171819202122232425262728293031323334353637@Datapublic class Student &#123; private String name = &quot;张三&quot;; private Integer age = 18;&#125;@Datapublic class Teacher &#123; private String name = &quot;李四&quot;; private Integer age = 20;&#125;//实现了ImportSelector接口public class MyImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;Student.class.getName(), Teacher.class.getName()&#125;; &#125;&#125;@Import(MyImportSelector.class) //这个import就比较像SpringBoot容器启动时引入的配置了@SpringBootApplicationpublic class App01 &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(App01.class, args); Student student = context.getBean(Student.class); System.out.println(student.getName()); Teacher teacher = context.getBean(Teacher.class); System.out.println(teacher.getName()); //这里会报bean不存在 MyImportSelector myImportSelector = context.getBean(MyImportSelector.class); &#125;&#125; 如果**@Import**注解导入的类实现了ImportBeanDefinitionRegistrar接口 那么这个类也不会导入到Spring容器中而是会执行registerBeanDefinitions()方法 将你需要导入的bean转成BeanDefinition对象注入到容器中 示例如下: 12345678910111213141516171819202122232425262728293031323334353637383940@Datapublic class Student &#123; private String name = &quot;张三&quot;; private Integer age = 18;&#125;@Datapublic class Teacher &#123; private String name = &quot;李四&quot;; private Integer age = 20;&#125;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; RootBeanDefinition student = new RootBeanDefinition(Student.class); registry.registerBeanDefinition(&quot;student&quot;, student); //向容器中注入student RootBeanDefinition teacher = new RootBeanDefinition(Teacher.class); registry.registerBeanDefinition(&quot;teacher&quot;, teacher); //向容器中注入teacher &#125;&#125;@Import(MyImportBeanDefinitionRegistrar.class)@SpringBootApplicationpublic class App01 &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(App01.class, args); Student student = context.getBean(Student.class); System.out.println(student.getName()); Teacher teacher = context.getBean(Teacher.class); System.out.println(teacher.getName()); //这里会报bean不存在 MyImportBeanDefinitionRegistrar myImportBeanDefinitionRegistrar = context.getBean(MyImportBeanDefinitionRegistrar.class); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"桥接模式","slug":"设计模式-桥接模式","date":"2022-02-12T14:50:03.144Z","updated":"2022-04-06T12:44:13.526Z","comments":false,"path":"2022/02/12/设计模式-桥接模式/","link":"","permalink":"http://example.com/2022/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述桥接模式的主要目的是通过组合的方式建立两个类之间的联系，而不是继承，但是又类似多重继承的方案。但是多重继承违背了类的单一职责原则，其复用性较差，桥接模式是比多重继承更好的替代方案，桥接模式的核心在于把抽象和实现进行解耦。 当一个对象拥有两个及以上维度变化的时候 可以考虑用桥接模式来拼接这个复合对象 如 对于一个几何图形来说 它有形状 和 颜色两个维度。如下图，如果通过继承的方式来组织，那么再增加一个菱形，又得扩展N个子类(每种颜色一个子类) 会造成子类过多。 二 桥接模式的结构桥接模式主要包含如下角色 抽象角色 定义抽象类,并包含一个实现化对象的引用 (是一个抽象类) 扩展抽象角色 是抽象角色的子类 实现父类中的业务方法 并通过组合关系调用实现化角色中的业务方法 实现化角色 定义实现化角色的接口，扩展抽象化角色调用 (一般是一个抽象类或者是一个接口) 具体实现化角色 给出实现化角色接口的具体实现 三 桥接模式案例需要开发一个跨平台的视频播放器，可以在不同的操作系统(Windows、Mac、Linux)上播放多种视频文件，常见的视频格式包括RMVB、AVI、MWV等，该播放器包括了2个维度，操作系统和视频格式 适合使用桥接模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//测试类public class Client &#123; public static void main(String[] args) &#123; VideoFile rmvbVideoFile = new RMVBVideoFile(); WindowsOS windows = new WindowsOS(rmvbVideoFile); windows.play(&quot;测试.rmvb&quot;); System.out.println(&quot;=======================&quot;); VideoFile aviVideoFile = new RMVBVideoFile(); MacOS mac = new MacOS(aviVideoFile); mac.play(&quot;测试.avi&quot;); System.out.println(&quot;=======================&quot;); MacOS mac2 = new MacOS(rmvbVideoFile); mac2.play(&quot;测试.rmvb&quot;); &#125;&#125;//实现化角色public interface VideoFile &#123; void decode(String fileName);&#125;//具体实现化角色public class AVIVideoFile implements VideoFile &#123; @Override public void decode(String fileName) &#123; System.out.println(&quot;AVI视频 文件名为 &quot; + fileName); &#125;&#125;//具体实现化角色public class RMVBVideoFile implements VideoFile&#123; @Override public void decode(String fileName) &#123; System.out.println(&quot;RMVB视频 文件名为&quot; + fileName); &#125;&#125;//抽象角色public abstract class OS &#123; //实现化角色的引用 protected VideoFile videoFile; public OS(VideoFile videoFile) &#123; this.videoFile = videoFile; &#125; public abstract void play(String fileName);&#125;//扩展抽象化角色public class MacOS extends OS &#123; public MacOS(VideoFile videoFile) &#123; super(videoFile); &#125; @Override public void play(String fileName) &#123; System.out.print(&quot;mac系统 播放&quot;); videoFile.decode(fileName); &#125;&#125;//扩展抽象化角色public class WindowsOS extends OS&#123; public WindowsOS(VideoFile videoFile) &#123; super(videoFile); &#125; @Override public void play(String fileName) &#123; System.out.print(&quot;windows系统 播放&quot;); videoFile.decode(fileName); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"设计模式-适配器模式","date":"2022-02-11T13:46:40.814Z","updated":"2022-04-06T12:44:36.028Z","comments":false,"path":"2022/02/11/设计模式-适配器模式/","link":"","permalink":"http://example.com/2022/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述适配器模式又叫做变压器模式，它的功能是将一个类的接口变成客户端所期望的另一种接口，从而使得原本因接口不匹配而导致无法在一起工作的两个类能够在一起工作。适配器模式适用于以下业务场景 已存在的类，它的方法和需求不匹配 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护、由于不同产品、不同厂家造成功能类似而接口不同情况下的解决方案，有种亡羊补牢的感觉。 适配器模式有主要有两种模式 一 类适配器 二 对象适配器 适配器模式一般包含三个角色 目标角色 也就是我们期望的接口 适配者(Adaptee) 也可以叫做源角色 即功能上可以满足客户需要 但是需要通过适配器将适配者转换位目标对象 适配器(Adapter) 将是适配者转换位目标角色的类 二 类适配器案例类适配器的原理就是通过继承来实现适配器的功能，具体的做法是让适配器实现目标接口同时继承Adaptee，这样适配器就具备了目标接口和适配者两者的功能，这样适配器就可以将两者转换。 类适配器实现的核心 继承适配者 同时实现目标接口 案例 现有一台电脑只能读取SD卡,而要让电脑能读取TF卡中的内容，则需要一个读卡器(适配器)将TF卡的内容转成SD卡的内容格式 读取出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//目标接口public interface SDCard &#123; String readSD(); void writeSD(String message);&#125;//目标接口的实现 于本例没什么关系public class SDCardImpl implements SDCard&#123; @Override public String readSD() &#123; return &quot;read msg from sd card&quot;; &#125; @Override public void writeSD(String message) &#123; System.out.println(&quot;write message to sd card&quot;); &#125;&#125;//适配者public class TFCard &#123; public String readTF() &#123; System.out.println(&quot;read msg from tf card&quot;); return &quot;hello world&quot;; &#125; public void writeTF(String message) &#123; System.out.println(&quot;write &quot; + message + &quot; to tf card&quot;); &#125;&#125;//适配器public class SDCardAdapter extends TFCard implements SDCard&#123; @Override public String readSD() &#123; //读取TF卡的信息 String message = readTF(); //模拟将TF卡的信息转换为SD卡的信息格式 System.out.println(&quot;trans msg to sd card&quot;); return message; &#125; @Override public void writeSD(String message) &#123; //模拟将sd格式的信息转为tf格式的信息 System.out.println(&quot;trans msg to tf&quot;); writeTF(message); &#125;&#125;//客户端public class Computer &#123; //模拟电脑读取sd card数据 public String readSD(SDCard sdCard)&#123; return sdCard.readSD(); &#125; //模拟电脑写sd card数据 public void writeSD(SDCard sdCard, String message)&#123; sdCard.writeSD(message); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; SDCard sdCard = new SDCardAdapter(); Computer computer = new Computer(); String message = computer.readSD(sdCard); System.out.println(message); System.out.println(&quot;======================&quot;); computer.writeSD(sdCard, &quot;hello world&quot;); &#125;&#125; 三 对象适配器对象适配器的原理就是通过组合来实现适配器的功能。具体做法是让Adapter实现目标接口,然后内部再持有Adaptee实例。对象适配器的处理方式和静态代理与装饰器模式比较像。实际开发中一般较少用类适配器 而是用对象适配器居多。还是以上面的去读卡器为例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//目标接口public interface SDCard &#123; String readSD(); void writeSD(String message);&#125;//适配者public class TFCard &#123; public String readTF() &#123; System.out.println(&quot;read msg from tf card&quot;); return &quot;hello world&quot;; &#125; public void writeTF(String message) &#123; System.out.println(&quot;write &quot; + message + &quot; to tf card&quot;); &#125;&#125;//适配器public class SDCardAdapter implements SDCard&#123; private TFCard tfCard; public SDCardAdapter(TFCard tfCard)&#123; this.tfCard = tfCard; &#125; @Override public String readSD() &#123; //读取TF卡的信息 String message = tfCard.readTF(); //模拟将TF卡的信息转换为SD卡的信息格式 System.out.println(&quot;trans msg to sd card&quot;); return message; &#125; @Override public void writeSD(String message) &#123; //模拟将sd格式的信息转为tf格式的信息 System.out.println(&quot;trans msg to tf&quot;); tfCard.writeTF(message); &#125;&#125;//客户端public class Computer &#123; //模拟电脑读取sd card数据 public String readSD(SDCard sdCard)&#123; return sdCard.readSD(); &#125; //模拟电脑写sd card数据 public void writeSD(SDCard sdCard, String message)&#123; sdCard.writeSD(message); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; SDCard sdCard = new SDCardAdapter(new TFCard()); Computer computer = new Computer(); String message = computer.readSD(sdCard); System.out.println(message); System.out.println(&quot;======================&quot;); computer.writeSD(sdCard, &quot;hello world&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"设计模式-组合模式","date":"2022-02-10T13:19:32.606Z","updated":"2022-04-06T12:47:11.786Z","comments":false,"path":"2022/02/10/设计模式-组合模式/","link":"","permalink":"http://example.com/2022/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述组合模式又叫整体-部分模式，它主要适用于树形结构，组合模式出现的场景一般是树形结构出现的地方，比如文件目录显示，多级目录，公司组织架构、菜单树展示等呈现等树形结构的操作。组合模式将对象组织到树形结构中，顶层的节点被称之为根节点，根节点下包括树枝节点和叶子节点。树枝节点下也可以包含树枝节点和叶子节点。 二 组合模式案例如下图 我们在访问阿里云的控制台的时候，可以看到类似下面的菜单树，一个菜单可以包含菜单项(菜单项是指不包含其他菜单的菜单条目) 也可以包含子菜单，现在需要打印如下图这样的菜单树。像这种针对树形结构的操作 我们就可以采用组合模式。 代码示例 抽象根节点 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class AbstractMenu &#123; //菜单名称 protected String name; //菜单级别 protected Integer level; public AbstractMenu(String name, Integer level) &#123; this.name = name; this.level = level; &#125; //打印菜单树的方法 public abstract void print(); /** * 添加子菜单 对于菜单项来说 这就是不允许的才做 * @param child */ public void addChild(AbstractMenu child)&#123; throw new UnSupportOperationException(&quot;不允许的操作&quot;); &#125; /** * 删除子菜单 对于菜单项来说 这就是不允许的才做 * @param child */ public void remove(AbstractMenu child) &#123; throw new UnSupportOperationException(&quot;不允许的操作&quot;); &#125; /** * 根据索引获取某个子菜单 * @param index * @return */ public AbstractMenu getChild(int index) &#123; throw new UnSupportOperationException(&quot;不允许的操作&quot;); &#125;&#125; 树枝节点 123456789101112131415161718192021222324252627282930public class Menu extends AbstractMenu&#123; //子菜单或菜单项 private List&lt;AbstractMenu&gt; children = new ArrayList&lt;&gt;(); public Menu(String name, Integer level) &#123; super(name, level); &#125; @Override public void addChild(AbstractMenu child) &#123; children.add(child); &#125; @Override public AbstractMenu getChild(int index) &#123; return children.get(index); &#125; @Override public void print() &#123; for (int i = 0 ; i&lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); for (AbstractMenu child : children) &#123; child.print(); &#125; &#125;&#125; 叶子节点 1234567891011121314public class MenuItem extends AbstractMenu&#123; public MenuItem(String name, Integer level) &#123; super(name, level); &#125; @Override public void print() &#123; for (int i = 0 ; i&lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); &#125;&#125; 异常类 12345678public class UnSupportOperationException extends RuntimeException &#123; private static final long serialVersionUID = 4229569507118124299L; public UnSupportOperationException(String message) &#123; super(message); &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Client &#123; public static void main(String[] args) &#123; //图中的根节点是看不见的 所以菜单名为&quot;&quot; AbstractMenu root = new Menu(&quot;/&quot;, 1); //概览菜单项 AbstractMenu overView = new MenuItem(&quot;概览&quot;, 2); //应用型负载均衡ALB AbstractMenu alb = new Menu(&quot;应用型负载均衡ALB&quot;, 2); AbstractMenu instance = new MenuItem(&quot;实例&quot;, 3); AbstractMenu server = new MenuItem(&quot;服务器组&quot;, 3); AbstractMenu healthCheck = new MenuItem(&quot;健康检查&quot;, 3); AbstractMenu control = new MenuItem(&quot;访问控制&quot;, 3); AbstractMenu strategy = new MenuItem(&quot;TSL安全策略&quot;, 3); AbstractMenu albPackage = new MenuItem(&quot;ALB资源包&quot;, 3); alb.addChild(instance); alb.addChild(server); alb.addChild(healthCheck); alb.addChild(control); alb.addChild(strategy); alb.addChild(albPackage); //传统型负载均衡CLB AbstractMenu clb = new Menu(&quot;传统型负载均衡CLB(原SLB)&quot;, 2); AbstractMenu instanceMgm = new MenuItem(&quot;实例管理&quot;, 3); AbstractMenu recycleBin = new MenuItem(&quot;回收站&quot;, 3); AbstractMenu certificate = new MenuItem(&quot;证书管理&quot;, 3); AbstractMenu logMgm = new Menu(&quot;日志管理&quot;, 3); AbstractMenu operation = new MenuItem(&quot;操作日志&quot;, 4); AbstractMenu access = new MenuItem(&quot;访问日志&quot;, 4); logMgm.addChild(operation); logMgm.addChild(access); clb.addChild(instanceMgm); clb.addChild(recycleBin); clb.addChild(certificate); clb.addChild(control); //添加访问控制菜单项 clb.addChild(logMgm); root.addChild(overView); root.addChild(alb); root.addChild(clb); //打印菜单树 root.print(); &#125;&#125; 测试结果","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBoot统一参数校验","slug":"SpringBoot-参数校验","date":"2022-02-09T14:23:38.803Z","updated":"2022-04-06T13:18:44.198Z","comments":false,"path":"2022/02/09/SpringBoot-参数校验/","link":"","permalink":"http://example.com/2022/02/09/SpringBoot-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"Spring Boot 项目实现统一参数校验需要进行如下几步 导入依赖 Spring Boot 2.3 1 之后，spring-boot-starter-validation 已经不包括在了 spring-boot-starter-web 中，需要我们手动加上！ 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 测试Controller @Validated注解的作用是用来告诉spring去校验方法的参数 123456789@RestController@RequestMapping(&quot;/api/person&quot;)@Validatedpublic class PersonController &#123; @PostMapping public ResponseEntity&lt;PersonRequest&gt; save(@RequestBody @Valid PersonRequest personRequest) &#123; return ResponseEntity.ok().body(personRequest); &#125;&#125; 测试request对象 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class PersonRequest &#123; @NotNull(message = &quot;classId 不能为空&quot;) private String classId; @Size(max = 33) @NotNull(message = &quot;name 不能为空&quot;) private String name; @Pattern(regexp = &quot;(^Man$|^Woman$|^UGM$)&quot;, message = &quot;sex 值不在可选范围&quot;) @NotNull(message = &quot;sex 不能为空&quot;) private String sex;&#125; 正则表达式说明： ^string : 匹配以 string 开头的字符串 string$ ：匹配以 string 结尾的字符串 ^string$ ：精确匹配 string 字符串 (^Man$|^Woman$|^UGM$) : 值只能在 Man,Woman,UGM 这三个值中选择 全局异常处理器 需要定义一个全局异常处理器来控制参数校验失败后的输出 1234567891011121314151617181920212223@ControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 参数校验异常处理 * @param req * @param e * @return */ @ResponseBody @ExceptionHandler(value = MethodArgumentNotValidException.class) public String methodArgumentNotValidHandler(HttpServletRequest req, MethodArgumentNotValidException e) &#123; BindingResult bindingResult = e.getBindingResult(); StringBuilder sb = new StringBuilder(&quot;参数校验失败:&quot;); for (FieldError fieldError : bindingResult.getFieldErrors()) &#123; sb.append(fieldError.getDefaultMessage()).append(&quot;;&quot;); &#125; return sb.toString(); &#125;&#125; 上面是基于Controller层的参数校验 如果希望把参数校验放到service层 通过使用@Validated和@Valid注释的组合即可实现这一需求，只需要如下配置Service类即可 @Validated注解的作用是用来告诉spring去校验方法的参数 1234567@Service@Validatedpublic class PersonService &#123; public void validatePersonRequest(@Valid PersonRequest personRequest) &#123; // do something &#125;&#125; 另外全局异常处理器需要变一下 不再是捕获MethodArgumentNotValidException了而是捕获ConstraintViolationException 1234567891011121314151617181920212223@ControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 参数校验异常处理 * @param req * @param e * @return */ @ResponseBody @ExceptionHandler(value = ConstraintViolationException.class) public String constraintViolationExceptionHandler(HttpServletRequest req, ConstraintViolationException e) &#123; StringBuilder sb = new StringBuilder(&quot;参数校验失败:&quot;); for (ConstraintViolation constraintViolation : e.getConstraintViolations()) &#123; sb.append(constraintViolation.getMessage()).append(&quot;;&quot;); &#125; return sb.toString(); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"享元模式","slug":"设计模式-享元模式","date":"2022-02-09T13:25:13.045Z","updated":"2022-04-06T12:44:55.802Z","comments":false,"path":"2022/02/09/设计模式-享元模式/","link":"","permalink":"http://example.com/2022/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述享元模式又叫做轻量级模式，是对象池的一种实现。类似线程池，其宗旨是共享细粒度对象，将多个对同一对象的访问集中起来，不必要为每个访问者都创建一个单独的对象，以此来降低内存的消耗。享元模式把一个对象的状态分为内部状态和外部状态 内部状态是不变的 外部状态是变化的，通过共享不变的部分，达到减少对象数量并节约内存的目的。享元模式的本质是缓存共享对象，降低内存消耗。 二 享元模式的角色 抽象享元角色 它是享元对象的抽象基类或者接口 同时定义出享元对象的外部状态和内部状态的接口或实现 具体享元角色 它是抽象享元角色的实现 该角色的内部状态应该与环境无关 享元工厂 负责管理享元对象池和创建享元对象 三 享元模式案例下面的图片是俄罗斯方块游戏中常见的几种形状，如果每个不同的方块都是一个实例对象，那么这些对象就要占用很多的内存空间，这个时候就可以利用享元模式来优化。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//抽象享元角色public abstract class AbstractBox &#123; //这里shape是对象的内部状态 是享元对象的共性 public abstract String shape(); //而color是享元对象的外部状态 它由参数传递进来 public void display(String color) &#123; System.out.println( &quot;形状 : &quot; + shape() + &quot; 颜色 : &quot; + color); &#125;&#125;//具体享元角色public class Ibox extends AbstractBox&#123; @Override public String shape() &#123; return &quot;I&quot;; &#125;&#125;//具体享元角色public class Jbox extends AbstractBox&#123; @Override public String shape() &#123; return &quot;J&quot;; &#125;&#125;//具体享元角色public class Zbox extends AbstractBox&#123; @Override public String shape() &#123; return &quot;Z&quot;; &#125;&#125;//享元工厂public class BoxFactory &#123; private static final BoxFactory instance = new BoxFactory(); private Map&lt;String, AbstractBox&gt; map = new HashMap&lt;&gt;(); private BoxFactory()&#123; map.put(&quot;I&quot;, new Ibox()); map.put(&quot;J&quot;, new Jbox()); map.put(&quot;Z&quot;, new Zbox()); &#125; public static BoxFactory getInstance() &#123; return instance; &#125; public AbstractBox getBox(String key)&#123; return map.get(key); &#125;&#125;//场景类public class Client &#123; public static void main(String[] args) &#123; BoxFactory factory = BoxFactory.getInstance(); AbstractBox i = factory.getBox(&quot;I&quot;); i.display(&quot;灰色&quot;); AbstractBox j = factory.getBox(&quot;J&quot;); j.display(&quot;绿色&quot;); AbstractBox z = factory.getBox(&quot;Z&quot;); z.display(&quot;黄色&quot;); AbstractBox j2 = factory.getBox(&quot;J&quot;); j2.display(&quot;紫色&quot;); System.out.println(j == j2); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰器模式","slug":"设计模式-装饰器模式","date":"2022-02-08T13:00:59.961Z","updated":"2022-04-06T12:46:58.260Z","comments":false,"path":"2022/02/08/设计模式-装饰器模式/","link":"","permalink":"http://example.com/2022/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述装饰器模式(Decorator Pattern) 也叫包装器模式，装饰器模式是指在不改变原有对象的基础上，动态的给一个对象添加一些额外的职责。装饰器模式是继承的一个替代方案。装饰器模式与静态代理很像，需要注意它们的区别。 二 装饰器引入我们先来看一个快餐店的例子，快餐店有炒饭、炒面，同时这些炒饭、炒面里可以加鸡蛋、培根这些配菜。当然加配菜需要往外加钱，每个配菜的价格通常是不一样的。这样计算快餐的总价就比较麻烦。下面来看通过继承的方式来实现快餐店的功能。 如上图 如果使用继承来实现，那么当新增一个配菜的时候 我们就需要新增两个配菜的子类 如果再多一个大类别(比如说炒河粉) 那就要新增所有的配菜子类了 鸡蛋炒河粉、培根炒河粉，切针对继承这种方式如果我要计算 一个炒饭+2个鸡蛋+1份培根这种 单靠继承是无法解决的 必须要单独新增计算方法。 三 装饰器模式结构装饰器模式主要有4个角色 抽象构建角色(Component) 定义一个抽象接口以规范待装饰的对象的行为 具体构建角色(Concrete Component) 它实际上就是待装饰的对象 它实现了抽象构建角色的接口 抽象装饰角色(Decorator) 抽象装饰角色 需要集成抽象构建角色 并且需要聚合具体构建角色的实例 具体装饰角色(ConcreteDecorator) 实现了抽象装饰角色的相关方法，并给具体的构建对象添加额外的功能 装饰器模式的通用写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Client &#123; public static void main(String[] args) &#123; Component c = new ConcreteComponent(); Decorator decoratorA = new ConCreteDecoratorA(c); Decorator decoratorB = new ConCreteDecoratorB(c); decoratorA.operation(); System.out.println(&quot;===========================&quot;); decoratorB.operation(); &#125;&#125;//抽象构建角色abstract class Component&#123; //示例方法 也就是装饰器和被装饰的对象需要共同实现的方法 public abstract void operation();&#125;//具体构建角色class ConcreteComponent extends Component &#123; @Override public void operation() &#123; System.out.println(&quot;处理业务逻辑&quot;); &#125;&#125;//抽象装饰角色class Decorator extends Component &#123; protected Component component; //通过构造方法传递具体的构建角色 public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; component.operation(); &#125;&#125;//具体的装饰角色Aclass ConCreteDecoratorA extends Decorator &#123; //通过构造方法传递具体的构建角色 public ConCreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void operation() &#123; before(); component.operation(); after(); &#125; private void before()&#123; System.out.println(&quot;方法增强 before&quot;); &#125; private void after()&#123; System.out.println(&quot;方法增强 after&quot;); &#125;&#125;//具体的装饰角色Aclass ConCreteDecoratorB extends Decorator &#123; //通过构造方法传递具体的构建角色 public ConCreteDecoratorB(Component component) &#123; super(component); &#125; @Override public void operation() &#123; before(); component.operation(); after(); &#125; private void before()&#123; System.out.println(&quot;方法增强 before&quot;); &#125; private void after()&#123; System.out.println(&quot;方法增强 after&quot;); &#125;&#125; 四 利用装饰器模式改造快餐店123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//测试类public class Client &#123; public static void main(String[] args) &#123; FastFood fastFood = new FriedRice(); fastFood = new Egg(fastFood); System.out.println(fastFood.getDesc() + &quot; 价格为 &quot; + fastFood.cost() + &quot;元&quot;); System.out.println(&quot;========================================&quot;); fastFood = new Bacon(fastFood); System.out.println(fastFood.getDesc() + &quot; 价格为 &quot; + fastFood.cost() + &quot;元&quot;); System.out.println(&quot;========================================&quot;); fastFood = new Bacon(fastFood); System.out.println(fastFood.getDesc() + &quot; 价格为 &quot; + fastFood.cost() + &quot;元&quot;); &#125;&#125;//快餐类 也就是抽象构建角色@Datapublic abstract class FastFood &#123; private float price; private String desc; public FastFood(float price, String desc) &#123; this.price = price; this.desc = desc; &#125; public abstract float cost();&#125;//炒饭类 也就是具体构建角色public class FriedRice extends FastFood &#123; public FriedRice() &#123; super(10.f, &quot;炒饭&quot;); &#125; @Override public float cost() &#123; return getPrice(); &#125;&#125;//配菜 也就是抽象装角色public abstract class Dish extends FastFood &#123; protected FastFood fastFood; public Dish(FastFood fastFood, float price, String desc) &#123; super(price, desc); this.fastFood = fastFood; &#125; public FastFood getFastFood() &#123; return fastFood; &#125; public void setFastFood(FastFood fastFood) &#123; this.fastFood = fastFood; &#125;&#125;//鸡蛋类 也就是具体装饰角色public class Egg extends Dish &#123; public Egg(FastFood fastFood) &#123; super(fastFood, 1.0f, &quot;鸡蛋&quot;); &#125; @Override public float cost() &#123; return getFastFood().cost() + getPrice(); &#125; @Override public String getDesc() &#123; return getFastFood().getDesc() + &quot;加&quot; + super.getDesc(); &#125;&#125;//培根类 也是具体装饰角色public class Bacon extends Dish &#123; public Bacon(FastFood fastFood) &#123; super(fastFood, 2.0f, &quot;培根&quot;); &#125; @Override public float cost() &#123; return getFastFood().cost() + getPrice(); &#125; @Override public String getDesc() &#123; return getFastFood().getDesc() + &quot;加&quot; + super.getDesc(); &#125;&#125; 五 装饰器模式使用场景 当不能采用继承的方式对系统进行扩充的时候 当类被final修饰时 不能被继承 该扩展相对独立 放在继承类中不合适的时候 当对象的功能要求可以动态的增加 也可以动态的撤销的时候 如上面快餐店的场景中 添加多份鸡蛋的时候 JDK源码解析 IO流中的缓冲流就使用了装饰器模式 类图如下 六 静态代理与装饰器模式的区别 它们的目的不一样 代理模式侧重于对被代理对象的控制 而装饰器模式则主要是对被装饰对象的增强 它们的用法有差别 代理模式对于被代理对象有控制权 可以执行也可以不执行 而装饰器模式 对于被装饰的对象没有控制权 它一定会执行 使用代理模式的情况下 客户端更关注于被代理对象(真实角色)的功能 而 装饰器模式下则更关注的是装饰器新增的功能 有些人人为 在代理模式下一般真实对象是很难获得的 而装饰器模式下 你是可以比较容易的获得被装饰的对象 体现在装饰器模式下 被装饰的对象是通过装饰器的构造器来传递被装饰对象的","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"门面模式","slug":"设计模式-门面模式","date":"2022-02-07T12:44:25.697Z","updated":"2022-04-06T12:43:46.819Z","comments":false,"path":"2022/02/07/设计模式-门面模式/","link":"","permalink":"http://example.com/2022/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"门面模式也叫外观设计模式，门面模式主要作用是可以屏蔽底层子系统的调用，降低使用者的难度。由门面来负责整合底层子系统的调用。该模式对外会有一个统一的接口，外部应用程序不用关心内部子系统的具体细节，这样可以降低程序的复杂度，提高了程序的可维护性。门面模式是迪米特法则的一个典型应用。门面模式在生活中一个很典型的例子就是基金 基金相当于就是一个门面, 买基金的人相当于是客户端，基金中包含的各种股票、债券等相当于一个个的子系统。客户并不需要了解各种基金中包含的这些股票和债券。 一 结构门面(Facade)模式主要包含以下角色: 门面(Facade)角色 为各个子系统提供一个共同的接口 子系统(Sub System)角色 实现系统的部分功能，客户可以通过门面来访问它 二 门面模式的优缺点优点: 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类 对客户端屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加的容易 缺点 门面模式不符合开闭原则，子系统如果有变更或者扩展 门面也需要相应的变更 三 门面模式的通用写法1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Client &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.doA(); facade.doB(); facade.doC(); &#125;&#125;class SubStemA&#123; public void doA()&#123; System.out.println(&quot;do A&quot;); &#125;&#125;class SubStemB&#123; public void doB()&#123; System.out.println(&quot;do B&quot;); &#125;&#125;class SubStemC&#123; public void doC()&#123; System.out.println(&quot;do C&quot;); &#125;&#125;class Facade &#123; private SubStemA a = new SubStemA(); private SubStemB b = new SubStemB(); private SubStemC c = new SubStemC(); public void doA()&#123; this.a.doA(); &#125; public void doB()&#123; this.b.doB(); &#125; public void doC()&#123; this.c.doC(); &#125;&#125; 四 门面模式案例小明的爷爷已经60岁了，一个人在家生活，每次都需要打开灯，打开电视，打开空调，睡觉前需要关闭灯，关闭电视，关闭空调，操作起来比较麻烦，所以小明给爷爷买了智能音箱，通过语音来控制这些家电的开启和关闭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class AirCondition &#123; public void on() &#123; System.out.println(&quot;空调开了&quot;); &#125; public void off() &#123; System.out.println(&quot;空调关了&quot;); &#125;&#125;public class Light &#123; public void on() &#123; System.out.println(&quot;灯开了&quot;); &#125; public void off() &#123; System.out.println(&quot;灯关了&quot;); &#125;&#125;public class TV &#123; public void on() &#123; System.out.println(&quot;电视开了&quot;); &#125; public void off() &#123; System.out.println(&quot;电视关了&quot;); &#125;&#125;public class SmartApplicationFacade &#123; private Light light = new Light(); private TV tv = new TV(); private AirCondition airCondition = new AirCondition(); public void say(String message) &#123; if (message.contains(&quot;打开电灯&quot;)) &#123; light.on(); return; &#125; if (message.contains(&quot;打开电视&quot;)) &#123; tv.on(); return; &#125; if (message.contains(&quot;打开空调&quot;)) &#123; airCondition.on(); return; &#125; if (message.contains(&quot;打开所有家电&quot;)) &#123; on(); return; &#125; if (message.contains(&quot;关闭电灯&quot;)) &#123; light.off(); return; &#125; if (message.contains(&quot;关闭电视&quot;)) &#123; tv.off(); return; &#125; if (message.contains(&quot;关闭空调&quot;)) &#123; airCondition.off(); return; &#125; if (message.contains(&quot;关闭所有家电&quot;)) &#123; off(); return; &#125; System.out.println(&quot;我听不懂你在说什么&quot;); &#125; private void on()&#123; this.airCondition.on(); this.tv.on(); this.light.on(); &#125; private void off()&#123; this.airCondition.off(); this.tv.off(); this.light.off(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; SmartApplicationFacade facade = new SmartApplicationFacade(); facade.say(&quot;打开所有家电&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"UML","slug":"设计模式-UML","date":"2022-01-31T08:19:09.025Z","updated":"2022-04-06T12:47:22.970Z","comments":false,"path":"2022/01/31/设计模式-UML/","link":"","permalink":"http://example.com/2022/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML/","excerpt":"","text":"一 UML图中的六种关系UML将事物之间的联系归纳为6种 分别是 关联关系、聚合关系、组合关系、泛化关系、实现关系、依赖关系 关联关系 关联关系 是对象之间的一种引用关系，表示一个类和另一个类之间的联系。关联关系有单向的也有双向的，在UML类图中 单向关联用一个带箭头的实线表示，双向关联用没有箭头的实线来表示 (一个类A的成员变量包含了另一个类B 则该A与B之间是关联关系 类A与类B在同一个层次) 聚合关系 聚合关系其实也是关联关系的一种 即它也满足 (一个类A的成员变量包含了另一个类B) 聚合关系与关联关系最大的区别是 类A与类B不是同一个层次 这是一个逻辑上的概念 代码中无法呈现。成员是整体的一部分，成员也可以脱离整体而存在。在UML类图中，用带空心菱形的实线来表示聚合关系，菱形指向整体。 组合关系 组合关系首先也是关联关系的一种 同时也是聚合关系的一种 即它满足(一个类A的成员变量包含了另一个类B 且 A 与 B不是同一个层次) 它与聚合关系最大的区别是聚合关系中类B是可以单独存在的 而组合关系中类B不能单独存在(能否单独存在 也是一个逻辑上的概念 代码无法区分) 在UML类图中，用带实心菱形的实线来表示组合关系，菱形指向整体 下图中 大脑是身体的一个组成部分 且大脑 不能脱离身体而存在 泛化关系 泛化关系表示的就是类与类之间的继承关系，在UML类图中，用带空心三角箭头的实线来表示泛化关系，箭头从子类指向父类 依赖关系 依赖关系通常表现为一个类(A)的某个方法的参数或者方法中的局部变量使用了另外一个类的对象，注意关联关系讲的是成员变量 而 依赖关系讲的是 局部变量或者方法参数。在UML类图中，依赖关系用带箭头的虚线表示，箭头从使用类指向被依赖的类 实现关系 实现关系就是接口和实现类之间的关系，在UML类图中，用带空心三角箭头的虚线来表示实现关系，箭头从实现类指向接口。 二 时序图时序图是用来描述对象之间消息的发送顺序，横轴表示对象，纵轴表示时间，消息(行为的说明)在各个对象之间横向传递，按照时间顺序排列。时序图的组成元素主要包括 角色(Actor)、对象(Object)、生命线(Lifeline)、控制焦点和消息。 角色 时序图的角色 可以是人、机器、其他系统、子系统 对象 可以理解为执行的主体 他可以是java中的对象 也可以是某个组件、平台、机构等等 消息 消息有同步调用、异步调用、方法返回 同步调用 用实心箭头实线来表示 方法返回 用空心箭头虚线来表示 异步调用 用空心箭头实线来表示 时序图还有一个很重要的概念就是组合片段，组合片段是用来解决交互执行的条件和方式，它允许在时序图中直接表示某段逻辑，时序图的组合片段一共有13种 常用的有如下几种 抉择(Alt) 相当于if else的逻辑 选项(Opt) 仅当提供的条件为真时才执行片段。 相当于只有一条迹线的alt 循环(Loop) 片段可以执行多次，并且防护指示迭代的基础 并行(Par) 每个片段并行运行 时序图常用图例 同步调用 方法返回 异步调用 抉择 选项 选项就是一个单次的Alt 相当于没有else的Alt 满足条件就进来 不满足条件 不做任何处理 走后续的流程 循环","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理","slug":"设计模式-代理模式","date":"2022-01-26T14:49:18.927Z","updated":"2022-04-06T12:41:51.735Z","comments":false,"path":"2022/01/26/设计模式-代理模式/","link":"","permalink":"http://example.com/2022/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式主要是在用户端与目标对象中间 产生一个代理对象，通过代理对象来保护目标对象或者对目标对象的功能进行增强。 一 静态代理通用写法所谓静态代理 就是代理类是固定存在的(在编译期就已经生成了的) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//目标对象需要被代理的接口public interface ISubject &#123; //目标对象(被代理对象)核心方法 void execute(String request);&#125;//目标对象public class RealSubject implements ISubject &#123; @Override public void execute(String request) &#123; System.out.println(&quot;目标对象执行request请求&quot;); &#125;&#125;//代理对象public class Proxy implements ISubject&#123; private ISubject target; //代理接口的一个好处就是可以实现代理的代理 这样可以进行代理的组合 //静态代理的第二种写法就是将目标对象直接在代理类中实例化 这样可以避免客户端直接访问真实对象 private Proxy(ISubject target)&#123; this.target = target; &#125; public static Proxy getInstance(ISubject subject) &#123; return new Proxy(subject); &#125; @Override public void execute(String request) &#123; before(target); target.execute(request); //目标对象执行execute方法 after(target); &#125; private void before(ISubject subject) &#123; System.out.println(&quot;前置处理&quot;); &#125; private void after(ISubject subject) &#123; System.out.println(&quot;后置处理&quot;); &#125;&#125;//测试public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = Proxy.getInstance(new RealSubject()); proxy.execute(&quot;测试&quot;); &#125;&#125; 二 JDK动态代理示例动态代理是指代理类是在运行期动态生成的 JDK动态代理核心是要创建一个代理类(代理类必须实现InvocationHandler接口) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//要代理的接口public interface IPerson &#123; //相亲 void findLove(String name);&#125;//真实对象public class Person implements IPerson &#123; private String name; public Person(String name)&#123; this.name = name; &#125; @Override public void findLove(String miss) &#123; System.out.println(name + &quot;和&quot; + miss + &quot;相亲&quot;); &#125;&#125;//通用的代理类public class Proxy implements InvocationHandler &#123; private Object target; private Proxy(Object target) &#123; this.target = target; &#125; //这里对jdk动态代理做了一点变动 本来是应该放在场景内中去使用的 被抽离道理代理类中 public static Object getInstance(Object target, Class&lt;?&gt;[] interfaces) &#123; Proxy proxy = new Proxy(target); return java.lang.reflect.Proxy.newProxyInstance(target。getClass().getClassLoader(), interfaces, proxy); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); after(); return result; &#125; public void before() &#123; System.out.println(&quot;前置处理&quot;); &#125; public void after()&#123; System.out.println(&quot;后置处理&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //设置系统属性保留生成的代理类文件 System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;); IPerson person = (IPerson) Proxy.getInstance(new Person(&quot;张三&quot;), new Class[]&#123;IPerson.class&#125;); person.findLove(&quot;李四&quot;); &#125;&#125; 三 Cglib动态代理导入cglib依赖 123456&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Person &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void findLove(String miss) &#123; System.out.println(name + &quot;和&quot; + miss + &quot;相亲&quot;); &#125;&#125;public class Proxy implements MethodInterceptor &#123; public Person getPerson() &#123; //Enhancer 类似于JDK动态代理的Proxy类 它负责创建代理类 Enhancer enhancer = new Enhancer(); //设置代理类的父类(就是真实/目标对象) enhancer.setSuperclass(Person.class); //设置回调函数 这个类似于JDK动态代理的InvocationHandler接口的实现 enhancer.setCallback(this); return (Person)enhancer.create(); &#125; /** * * @param o 这个参数是Cglib代理类的实例 类似于JDK的InvocationHandler接口的proxy参数 * @param method method为正在被调用的方法 * @param args args为方法参数 * @param proxy proxy 为生成的代理类对方法的代理引用 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; before(); proxy.invokeSuper(o, args); after(); return null; &#125; private void before()&#123; System.out.println(&quot;执行前置处理&quot;); &#125; private void after()&#123; System.out.println(&quot;执行后置处理&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); Person person = proxy.getPerson(); person.setName(&quot;李四&quot;); person.findLove(&quot;张三&quot;); &#125;&#125; 四 三种代理的对比在JDK1.6、JDK1.7、JDK1.8逐步对JDK进行动态代理优化之后，在调用次数较少的情况下, JDK代理的效率比Cglib效率高，当大量调用的时候,JDK1.6、JDK1.7的效率比Cglib效率低。但是JDK1.8的时候，JDK代理效率高于Cglib代理，所以如果有接口使用JDK动态代理，没有接口用Cglib代理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者","slug":"设计模式-建造者模式","date":"2022-01-25T15:44:06.884Z","updated":"2022-04-06T12:43:35.886Z","comments":false,"path":"2022/01/25/设计模式-建造者模式/","link":"","permalink":"http://example.com/2022/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式和工厂模式很像，建造者模式主要偏重于创建复杂对象，它一般被设计为链式调用，一般会在复杂对象中创建一个builder的静态内部类，同时提供一个build方法 示例如下 建造者模式还有一个重要的作用是控制对象变量设值的顺序 在某些需要控制对象属性构建的顺序的场景下比较适用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//测试类public class Client &#123; public static void main(String[] args) &#123; Course.CourseBuilder builder = new Course.CourseBuilder(); Course course = builder.addName(&quot;java&quot;).addNote(new Note(&quot;java笔记&quot;)).addVideo(new Video(&quot;java视频&quot;)).build(); System.out.println(course); &#125;&#125;@Data@ToStringclass Course &#123; private String courseName; private Note note; private Video video; private Course()&#123; &#125; //在建造者模式中builder类一般设计为静态内部类 public static class CourseBuilder &#123; Course course = new Course(); //builder类被设计为允许链式调用 public CourseBuilder addName(String name)&#123; course.setCourseName(name); return this; &#125; public CourseBuilder addNote(Note note)&#123; course.setNote(note); return this; &#125; public CourseBuilder addVideo(Video video) &#123; course.setVideo(video); return this; &#125; public Course build() &#123; return course; &#125; &#125;&#125;@Data@AllArgsConstructor@ToStringclass Note &#123; private String name;&#125;@Data@AllArgsConstructor@ToStringclass Video &#123; private String name;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"设计模式-原型模式","date":"2022-01-25T13:59:39.849Z","updated":"2022-04-06T12:45:07.889Z","comments":false,"path":"2022/01/25/设计模式-原型模式/","link":"","permalink":"http://example.com/2022/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型设计模式的本质其实就是以系统中已存在的一个对象为原型 复制出若干的相同的对象 原型模式复制的对象是基于二进制流来复制的，不会经过构造器，所以其效率比直接new对象要高。 涉及到对象的克隆就不得不说Object的clonalbe接口 实现该接口 则可以进行浅克隆 浅克隆对引用对象无效(它只会复制引用对象的地址) 而java中进行深克隆有两种办法 一种是对引用对象单独进行复制(这个要求引用对象本身也实现了clonealbe接口 且引用对象中没有引用对象了) 第二种则是通过序列化的方式来实现深克隆 一 原型模式(浅克隆)12345678910111213141516171819202122232425262728293031323334353637public class Prototype &#123; public static void main(String[] args) throws Exception&#123; List&lt;String&gt; hobbies = new ArrayList&lt;&gt;(); hobbies.add(&quot;打篮球&quot;); hobbies.add(&quot;打乒乓&quot;); A a = new A(&quot;张三&quot;, hobbies); System.out.println(a); A a2 = a.clone(); a2.getHobbies().add(&quot;打羽毛球&quot;); System.out.println(a2); //a2的hobbies有3个元素 System.out.println(a); //a的hobbies也有3个元素 &#125;&#125;@Data@AllArgsConstructorclass A implements Cloneable&#123; private String name; private List&lt;String&gt; hobbies; //原型模式的核心方法clone @Override public A clone() throws CloneNotSupportedException &#123; return (A)super.clone(); &#125; @Override public String toString() &#123; return &quot;A&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, hobbies=&quot; + hobbies + &#x27;&#125;&#x27;; &#125;&#125; 二原型模式(深克隆)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Prototype &#123; public static void main(String[] args) throws Exception&#123; List&lt;String&gt; hobbies = new ArrayList&lt;&gt;(); hobbies.add(&quot;打篮球&quot;); hobbies.add(&quot;打乒乓&quot;); A a = new A(&quot;张三&quot;, hobbies); System.out.println(a); A a2 = a.copy(); a2.getHobbies().add(&quot;打羽毛球&quot;); System.out.println(a2); System.out.println(a); &#125;&#125;@Data@AllArgsConstructorclass A implements Serializable &#123; private static final long serialVersionUID = -7362917628271346772L; private String name; private List&lt;String&gt; hobbies; public A copy() throws Exception&#123; ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try &#123; bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); return (A)ois.readObject(); &#125;finally &#123; if(ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125; @Override public String toString() &#123; return &quot;A&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, hobbies=&quot; + hobbies + &#x27;&#125;&#x27;; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂","slug":"设计模式-抽象工厂","date":"2022-01-23T15:17:16.828Z","updated":"2022-04-06T12:41:35.784Z","comments":false,"path":"2022/01/23/设计模式-抽象工厂/","link":"","permalink":"http://example.com/2022/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","excerpt":"","text":"抽象工厂可以看做是工厂方法的集合 工厂方法中 一个工厂只能生产一种产品 而抽象工厂中 一个具体的工厂则可以生产多个产品 所谓的产品可以理解为一个接口 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//抽象工厂public interface Course &#123; Note getNote(); //如果抽象工厂中 只包含一个产品(接口)的创建 那么它就是工厂方法 Video getVideo();&#125;//抽象产品Apublic interface Note &#123; void note();&#125;//抽象产品Bpublic interface Video &#123; void play();&#125;//A产品族public class JavaCourse implements Course&#123; @Override public Note getNote() &#123; return new JavaNote(); &#125; @Override public Video getVideo() &#123; return new JavaVideo(); &#125;&#125;//B产品族public class PythonCourse implements Course&#123; @Override public Note getNote() &#123; return new PythonNote(); &#125; @Override public Video getVideo() &#123; return new PythonVideo(); &#125;&#125;//A产品族中的A产品public class JavaNote implements Note&#123; @Override public void note() &#123; System.out.println(&quot;java课堂笔记&quot;); &#125;&#125;//A产品族中的B产品public class JavaVideo implements Video&#123; @Override public void play() &#123; System.out.println(&quot;java课堂视频&quot;); &#125;&#125;//B产品族中的A产品public class PythonNote implements Note&#123; @Override public void note() &#123; System.out.println(&quot;python课堂笔记&quot;); &#125;&#125;//B产品族中的B产品public class PythonVideo implements Video&#123; @Override public void play() &#123; System.out.println(&quot;python课堂视频&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; JavaCourse javaCourse = new JavaCourse(); javaCourse.getVideo().play(); javaCourse.getNote().note(); PythonCourse pythonCourse = new PythonCourse(); pythonCourse.getNote().note(); pythonCourse.getVideo().play(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法","slug":"设计模式-工厂方法","date":"2022-01-23T09:43:37.149Z","updated":"2022-04-06T12:42:51.823Z","comments":false,"path":"2022/01/23/设计模式-工厂方法/","link":"","permalink":"http://example.com/2022/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/","excerpt":"","text":"工厂方法模式区别于简单工厂，最主要的区别是简单工厂只有一个工厂类，而在工厂方法中，会有一个抽象的工厂(接口/抽象类) 同时会有若干个具体的工厂 但是抽象的产品只会有一个。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//抽象的工厂接口public interface IFactory &#123; IProduct createProduct();&#125;//抽象的产品接口public interface IProduct &#123; void productInfo();&#125;//产品Apublic class ProductA implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//产品Bpublic class ProductB implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//工厂Apublic class FactoryA implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductA(); &#125;&#125;//工厂Bpublic class FactoryB implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductB(); &#125;&#125;//这个可以理解为工厂的工厂 实际它不算在工厂方法设计模式中public class FactoryHelper &#123; private static final Map&lt;Class&lt;? extends IFactory&gt;, IFactory&gt; factories = new ConcurrentHashMap&lt;&gt;(); static &#123; registry(FactoryA.class, new FactoryA()); registry(FactoryB.class, new FactoryB()); &#125; public static IFactory getFactory(Class&lt;? extends IFactory&gt; clazz)&#123; return factories.get(clazz); &#125; public static void registry(Class&lt;? extends IFactory&gt; clazz, IFactory factory) &#123; factories.put(clazz, factory); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; IProduct productA = FactoryHelper.getFactory(FactoryA.class).createProduct(); productA.productInfo(); IProduct productB = FactoryHelper.getFactory(FactoryB.class).createProduct(); productB.productInfo(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计原则","slug":"设计模式-设计原则","date":"2022-01-22T13:40:18.206Z","updated":"2022-04-06T12:44:24.695Z","comments":false,"path":"2022/01/22/设计模式-设计原则/","link":"","permalink":"http://example.com/2022/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"开闭原则 是指一个软件实体 如类、模块、函数应该对扩展开放，对修改关闭。 依赖倒置原则 是指代码之间的发生依赖的时候 应该依赖其抽象(接口) 这样可以降低类与类之间的耦合性，提高系统稳定性 单一职责原则 是指一个类只能拥有一个变动的因素 也就是一个类只负责一个职责 单一职责其实就是告诉我们 类和方法都要设计的足够的小 接口隔离原则 一个类对另一个类的依赖应该建立在最小接口上；建立单一的接口 不要建立过于庞大的接口 迪米特法则 又叫最少知道原则 是指一个对象应该尽量降低与其他类的耦合；迪米特法则其实也是告诉我们要依赖最小接口 而不是实现 里氏替换原则 它强调的是对父类与子类的一个约束 简单来说就是在声明变量(成员变量、局部变量、方法参数)的时候 应该要用父类引用指向子类对象 里氏替换原则要求 1、子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法 2、子类可以增加自己特有的方法，3、子类在重载父类方法的时候 方法的参数要比父类更宽松 4、当子类实现父类方法的时候 方法的返回要比父类更加的严格。 合成复用原则 强调的是我们应该尽量减少通过继承的方式来进行代码的复用 更多的应该通过聚合或者组合的形式来进行代码复用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"简单工厂","slug":"设计模式-简单工厂","date":"2022-01-05T13:37:32.895Z","updated":"2022-04-06T12:43:24.329Z","comments":false,"path":"2022/01/05/设计模式-简单工厂/","link":"","permalink":"http://example.com/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/","excerpt":"","text":"简单工厂区别于其他工厂最主要的特征就是有一个具体的工厂类 下面是简单工厂的类图 工厂主要是为了灵活的控制生产过程 可以对对象的创建赋予权限 不同的权限获取不同的对象 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//产品接口public interface Product &#123; void display();&#125;//具体产品Apublic class ProductA implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//具体产品Bpublic class ProductB implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//具体产品Cpublic class ProductC implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品C&quot;); &#125;&#125;//简单工厂public class Factory &#123; private Factory() &#123; &#125; public static Factory getInstance() &#123; return Inner.instance; &#125; public Product createProduct(Class&lt;? extends Product&gt; clazz) throws Exception&#123; if (clazz == null) &#123; return null; &#125; Product product = clazz.newInstance(); //此处省略若干创建对象时的所需要的操作 因为一般工厂模式创建对象都是创建复杂对象 return product; &#125; private static class Inner &#123; private static final Factory instance = new Factory(); &#125;&#125;//测试类public class FactoryTest &#123; public static void main(String[] args) throws Exception &#123; Factory factory = Factory.getInstance(); Product product = factory.createProduct(ProductA.class); product.display(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"tk.mybatis集成多数据源","slug":"FAQ-tk.mybatis集成多数据源","date":"2021-12-30T06:37:52.813Z","updated":"2022-04-06T13:18:33.214Z","comments":false,"path":"2021/12/30/FAQ-tk.mybatis集成多数据源/","link":"","permalink":"http://example.com/2021/12/30/FAQ-tk.mybatis%E9%9B%86%E6%88%90%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/","excerpt":"","text":"pom 依赖123456789101112131415161718 &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--分页可以不要--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 配置类主数据源 12345678910111213141516171819202122232425262728293031323334353637383940414243@Configuration@MapperScan(basePackages = &#123;&quot;com.xxx.dao.gmp&quot;&#125;, sqlSessionTemplateRef = &quot;druidSqlSessionTemplate&quot;,markerInterface = BaseMapper.class)public class DataSourceConfig &#123; @Bean @Primary @ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;) public DataSourceProperties druidDataSourceProperties() &#123; return new DataSourceProperties(); &#125; @Bean @Primary public DataSource druidDataSource(@Qualifier(&quot;druidDataSourceProperties&quot;) DataSourceProperties druidDataSourceProperties) &#123; return druidDataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean @Primary public DataSourceTransactionManager druidTransactionManager(@Qualifier(&quot;druidDataSource&quot;) DataSource druidDataSource) &#123; return new DataSourceTransactionManager(druidDataSource); &#125; @Bean @Primary public SqlSessionTemplate druidSqlSessionTemplate(@Qualifier(&quot;druidSqlSessionFactory&quot;) SqlSessionFactory druidSqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(druidSqlSessionFactory); &#125; @Bean @Primary public SqlSessionFactory druidSqlSessionFactory(@Qualifier(&quot;druidDataSource&quot;) DataSource druidDataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); bean.setDataSource(druidDataSource); bean.setConfiguration(configuration); //手动指定mapp.xml的位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/gmp/*Mapper.xml&quot;)); return bean.getObject(); &#125;&#125; 第二数据源 1234567891011121314151617181920212223242526272829303132333435363738@Configuration@MapperScan(basePackages = &#123;&quot;com.xxx.dao.cmd&quot;&#125;, sqlSessionTemplateRef = &quot;cmdSqlSessionTemplate&quot;,markerInterface = BaseMapper.class)public class CMDDataSourceConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource.cmd&quot;) public DataSourceProperties cmdDataSourceProperties() &#123; return new DataSourceProperties(); &#125; @Bean public DataSource cmdDataSource(@Qualifier(&quot;cmdDataSourceProperties&quot;) DataSourceProperties cmdDataSourceProperties) &#123; return cmdDataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean public DataSourceTransactionManager cmdTransactionManager(@Qualifier(&quot;cmdDataSource&quot;) DataSource cmdDataSource) &#123; return new DataSourceTransactionManager(cmdDataSource); &#125; @Bean public SqlSessionTemplate cmdSqlSessionTemplate(@Qualifier(&quot;cmdSqlSessionFactory&quot;) SqlSessionFactory cmdSqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(cmdSqlSessionFactory); &#125; @Bean public SqlSessionFactory cmdSqlSessionFactory(@Qualifier(&quot;cmdDataSource&quot;) DataSource cmdDataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); bean.setDataSource(cmdDataSource); bean.setConfiguration(configuration); //手动指定mapp.xml的位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/cmd/*Mapper.xml&quot;)); return bean.getObject(); &#125;&#125; mapper 12345import com.gzhc365.arch.gmp.po.CMDServerInfo;import tk.mybatis.mapper.common.Mapper;public interface CMDServerInfoDAO extends Mapper&lt;CMDServerInfo&gt; &#123;&#125; 12345import com.gzhc365.arch.gmp.po.Application;import tk.mybatis.mapper.common.Mapper;public interface ApplicationDAO extends Mapper&lt;Application&gt; &#123;&#125; 配置 1234567891011#主数据源配置spring.datasource.druid.url = jdbc:mysql://xxx:3306/xxdb?allowPublicKeyRetrieval=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=truespring.datasource.druid.username = xxxspring.datasource.druid.password = xxxspring.datasource.druid.driver-class-name = com.mysql.jdbc.Driver#第二数据源配置spring.datasource.cmd.url = jdbc:mysql://xxx:3306/yyDb?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.cmd.username = yyyspring.datasource.cmd.password = yyyspring.datasource.cmd.driver-class-name = com.mysql.jdbc.Driver 多数据源的配置主要是相关配置类和properties配置文件的配置","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot配置文件属性自动提示","slug":"SpringBoot-配置文件属性自动提示","date":"2021-12-30T06:24:09.936Z","updated":"2022-04-06T13:19:07.685Z","comments":false,"path":"2021/12/30/SpringBoot-配置文件属性自动提示/","link":"","permalink":"http://example.com/2021/12/30/SpringBoot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA/","excerpt":"","text":"spring-boot-configuration-processor的作用 当我们再springboot的配置文件如application.properties 或者 application.yaml文件去填充配置的时候 会发现springboot配置文件会自动提示，但是我们自己自定义的一些配置无法提示。如图 要使得我们自定义的配置也能达到这样的效果(自动提示) 需要借助spring-boot-configuration-processor 这个jar 同时需要配和使用@ConfigurationProperties注解来实现 spring-boot-configuration-processor的作用是生成配置的元数据信息，即在classes目录下的META-INF目录下生成spring-configuration-metadata.json文件，从而告诉spring这个jar包中有哪些自定义的配置 还可以在resources目录下手动添加META-INF/additional-spring-configuration-metadata.json文件，这个文件是手动添加的，用于对spring-configuration-metadata.json进行补充，编译后会合并到spring-configuration-metadata.json中 示例 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt; 配置好之后一定要先编译 不然是不会生效的(执行maven的package或者install命令) 效果如下 自定义的配置 hc.custom.xx 博客链接 1https://www.cnblogs.com/tonglin0325/p/5344129.html","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"maven依赖冲突如何解决","slug":"FAQ-maven依赖冲突解决方案","date":"2021-12-30T03:39:39.989Z","updated":"2022-04-06T13:17:31.610Z","comments":false,"path":"2021/12/30/FAQ-maven依赖冲突解决方案/","link":"","permalink":"http://example.com/2021/12/30/FAQ-maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"问题启动时项目时报错如下 1NoClassDefFoundError org/mybatis/logging/LoggerFactory 明明已经集成了mybatis相关依赖 还报找不到类定义 检查完pom之后 确认依赖没问题以后 可以借助idea的maven helper插件 查看下当前的mybatis依赖是否有冲突 解决办法 利用maven helper插件排除多余的依赖 重新更新maven依赖(reimport ) 即可","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"策略模式","slug":"设计模式-策略","date":"2021-12-19T12:00:24.342Z","updated":"2022-04-06T12:41:16.829Z","comments":false,"path":"2021/12/19/设计模式-策略/","link":"","permalink":"http://example.com/2021/12/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/","excerpt":"","text":"策略模式 可以用来替代if else这种逻辑判断 核心是抽象出来一个公共的策略接口 下面的示例是一个利用策略模式 简单实现的一个计算器 一 策略接口123public interface Executor &#123; Number execute(Number p1, Number p2);&#125; 二 策略实现1234567891011121314public class AddExecutor implements Executor &#123; @Override public Number execute(Number p1, Number p2) &#123; return p1.doubleValue() + p2.doubleValue(); &#125;&#125;public class SubExecutor implements Executor &#123; @Override public Number execute(Number p1, Number p2) &#123; return p1.doubleValue() - p2.doubleValue(); &#125;&#125; 三 策略的容器Calculator 类主要是提供一个或者一些方法来应用策略 123456public class Calculator &#123; public static Number calculate(Number a, Number b, Executor executor) &#123; return executor.execute(a, b); &#125;&#125; 四 测试12345678public class StrategyTest &#123; public static void main(String[] args) &#123; Number result = Calculator.calculate(1, 2, new AddExecutor()); Number result2 = Calculator.calculate(1, 2, new SubExecutor()); System.out.println(result); System.out.println(result2); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例","slug":"设计模式-单例","date":"2021-12-19T08:02:05.637Z","updated":"2022-04-06T12:41:59.718Z","comments":false,"path":"2021/12/19/设计模式-单例/","link":"","permalink":"http://example.com/2021/12/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/","excerpt":"","text":"单例模式的核心点是构造器私有化 并提供一个全局访问点 一 饿汉式123456789101112public class Singleton01 &#123; private static final Singleton01 instance = new Singleton01(); private Singleton01() &#123; &#125; public static Singleton01 getInstance() &#123; return instance; &#125;&#125; 二 懒汉式 双重检测锁的实现12345678910111213141516171819public class Singleton02 &#123; private static volatile Singleton02 instance; private Singleton02 ()&#123; &#125; public static Singleton02 getInstance()&#123; if (instance == null) &#123; synchronized (Singleton02.class) &#123; if (instance == null) &#123; instance = new Singleton02(); &#125; &#125; &#125; return instance; &#125;&#125; 三 懒汉式 静态内部类实现1234567891011121314public class Singleton03 &#123; private Singleton03() &#123; &#125; public static Singleton03 getInstance()&#123; return Singleton03Holder.instance; &#125; private static class Singleton03Holder &#123; static Singleton03 instance = new Singleton03(); &#125;&#125; 四 枚举实现单例java规范规定 枚举类是没有构造方法 所以这种写法可以防止通过java反射 利用构造器去创建对象 上面的三种方式都无法防止 但是枚举单例可以 12345678public enum Singleton04 &#123; INSTANCE; //其他业务方法 public void sayHello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 枚举单例序列化测试 1234567891011121314151617181920212223242526272829303132333435363738//枚举默认是实现了序列化接口的 不需要单独的实现序列化接口了public enum Singleton &#123; INSTANCE;&#125;public class Client &#123; public static void main(String[] args) throws Exception&#123; String path = &quot;/Users/liliang/code/test/comon-test/src/main/java/com/liliang/test/test/Singleton02.java&quot;; FileOutputStream fos = null; ObjectOutputStream oos = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fos = new FileOutputStream(path); oos = new ObjectOutputStream(fos); oos.writeObject(Singleton.INSTANCE); fis = new FileInputStream(path); ois = new ObjectInputStream(fis); Object object = ois.readObject(); System.out.println(object.hashCode()); //测试结果 hashcode 与 下面的hashcode是一样的 System.out.println(Singleton.INSTANCE.hashCode()); &#125;finally &#123; //文件流的关闭顺序 后用先关 如果用了处理流 则只需要关闭处理流就行了 节点流不需要关闭。 if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125;&#125; 五 通用防止序列化破坏单例的解决办法上述的的单例实现方式除了枚举 都不能再单例类实现序列化接口后 还保证单例 要想在单例类实现序列化接口后还能保证单例 需要增加一个readResolve()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Singleton implements Serializable &#123; private static final long serialVersionUID = 7518189569602396628L; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return Inner.instance; &#125; //必须要加readResolve方法 方法名和返回值都不能错 private Object readResolve() &#123; return Inner.instance; &#125; private static class Inner&#123; private static final Singleton instance = new Singleton(); &#125;&#125;public class Client &#123; public static void main(String[] args) throws Exception&#123; String path = &quot;/Users/liliang/code/test/comon-test/src/main/java/com/liliang/test/test/Singleton02.txt&quot;; FileOutputStream fos = null; ObjectOutputStream oos = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fos = new FileOutputStream(path); oos = new ObjectOutputStream(fos); oos.writeObject(Singleton.getInstance()); fis = new FileInputStream(path); ois = new ObjectInputStream(fis); Object object = ois.readObject(); System.out.println(object.hashCode()); System.out.println(Singleton.getInstance().hashCode()); &#125;finally &#123; //文件流的关闭顺序 后用先关 如果用了处理流 则只需要关闭处理流就行了 节点流不需要关闭。 if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"easyexcel使用报错","slug":"FAQ-easyexcel使用报错","date":"2021-11-23T10:32:48.552Z","updated":"2022-04-06T13:16:50.132Z","comments":false,"path":"2021/11/23/FAQ-easyexcel使用报错/","link":"","permalink":"http://example.com/2021/11/23/FAQ-easyexcel%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/","excerpt":"","text":"报错信息 1easyexcel The maximum length of cell contents (text) is 32,767 characters 使用easyexcel向excel中写内容出现了单元格大小不能超过32767的限制，这是因为excel 2007限制单个cell不能超过32767个字符 解决办法 重写poi包下SpreadsheetVersion类在自己的项目文件夹下创建org.apache.poi.ss.SpreadsheetVersion类，复制poi中的该类源码，excel2007中的最后一个值改为int类型最大值。重试导出问题解决。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * @author liliang * @date 2021/11/23 **/public enum SpreadsheetVersion &#123; /** * Excel97 format aka BIFF8 * &lt;ul&gt; * &lt;li&gt;The total number of available rows is 64k (2^16)&lt;/li&gt; * &lt;li&gt;The total number of available columns is 256 (2^8)&lt;/li&gt; * &lt;li&gt;The maximum number of arguments to a function is 30&lt;/li&gt; * &lt;li&gt;Number of conditional format conditions on a cell is 3&lt;/li&gt; * &lt;li&gt;Number of cell styles is 4000&lt;/li&gt; * &lt;li&gt;Length of text cell contents is 32767&lt;/li&gt; * &lt;/ul&gt; */ EXCEL97(0x10000, 0x0100, 30, 3, 4000, 32767), /** * Excel2007 * * &lt;ul&gt; * &lt;li&gt;The total number of available rows is 1M (2^20)&lt;/li&gt; * &lt;li&gt;The total number of available columns is 16K (2^14)&lt;/li&gt; * &lt;li&gt;The maximum number of arguments to a function is 255&lt;/li&gt; * &lt;li&gt;Number of conditional format conditions on a cell is unlimited * (actually limited by available memory in Excel)&lt;/li&gt; * &lt;li&gt;Number of cell styles is 64000&lt;/li&gt; * &lt;li&gt;Length of text cell contents is 32767&lt;/li&gt; * &lt;ul&gt; */ EXCEL2007(Integer.MAX_VALUE, Integer.MAX_VALUE, 255, Integer.MAX_VALUE, 64000, Integer.MAX_VALUE); private final int _maxRows; private final int _maxColumns; private final int _maxFunctionArgs; private final int _maxCondFormats; private final int _maxCellStyles; private final int _maxTextLength; private SpreadsheetVersion(int maxRows, int maxColumns, int maxFunctionArgs, int maxCondFormats, int maxCellStyles, int maxText) &#123; _maxRows = maxRows; _maxColumns = maxColumns; _maxFunctionArgs = maxFunctionArgs; _maxCondFormats = maxCondFormats; _maxCellStyles = maxCellStyles; _maxTextLength = maxText; &#125; /** * @return the maximum number of usable rows in each spreadsheet */ public int getMaxRows() &#123; return _maxRows; &#125; /** * @return the last (maximum) valid row index, equals to &lt;code&gt; getMaxRows() - 1 &lt;/code&gt; */ public int getLastRowIndex() &#123; return _maxRows - 1; &#125; /** * @return the maximum number of usable columns in each spreadsheet */ public int getMaxColumns() &#123; return _maxColumns; &#125; /** * @return the last (maximum) valid column index, equals to &lt;code&gt; getMaxColumns() - 1 &lt;/code&gt; */ public int getLastColumnIndex() &#123; return _maxColumns - 1; &#125; /** * @return the maximum number arguments that can be passed to a multi-arg function (e.g. COUNTIF) */ public int getMaxFunctionArgs() &#123; return _maxFunctionArgs; &#125; /** * @return the maximum number of conditional format conditions on a cell */ public int getMaxConditionalFormats() &#123; return _maxCondFormats; &#125; /** * @return the maximum number of cell styles per spreadsheet */ public int getMaxCellStyles() &#123; return _maxCellStyles; &#125; /** * * @return the last valid column index in a ALPHA-26 representation * (&lt;code&gt;IV&lt;/code&gt; or &lt;code&gt;XFD&lt;/code&gt;). */ public String getLastColumnName() &#123; return CellReference.convertNumToColString(getLastColumnIndex()); &#125; /** * @return the maximum length of a text cell */ public int getMaxTextLength() &#123; return _maxTextLength; &#125;&#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"RestTemplate最佳实践","slug":"FAQ-RestTemplate最佳实践","date":"2021-11-17T13:41:35.214Z","updated":"2022-04-06T13:17:53.115Z","comments":false,"path":"2021/11/17/FAQ-RestTemplate最佳实践/","link":"","permalink":"http://example.com/2021/11/17/FAQ-RestTemplate%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"一 介绍RestTemplate 是Spring提供的一个用于http访问的工具模板 二 依赖使用restTemplate需要导入如下pom依赖 1234567891011&lt;!--restTemplate启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--根据需要导入httpcomponents--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.10&lt;/version&gt;&lt;/dependency&gt; 三 restTemplate配置在使用restTemplate之前 还需要简单的对restTemplate进行配置 配置类如下 123456789101112131415161718@Data@Configuration@ConfigurationProperties(prefix = &quot;xx.xx.xx&quot;)public class RestTemplateConfig &#123; private Long connectionTimeout = 1000L; private Long readTimeout = 1000L; @Bean //将RestTemplate装配为bean public RestTemplate restTemplate(RestTemplateBuilder builder) &#123; return builder .requestFactory(HttpComponentsClientHttpRequestFactory.class) .setConnectTimeout(Duration.ofMillis(connectionTimeout)) //设置http的链接超时时间 .setReadTimeout(Duration.ofMillis(readTimeout)) //设置http的响应超时时间 .build(); &#125;&#125; 四 使用restTemplate12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@RestControllerpublic class TestController &#123; @Autowired private RestTemplate restTemplate; /** * 获取nacos中指定dataId的配置信息 **/ @RequestMapping(path = &quot;/getConfig&quot;, method = RequestMethod.GET) public String getConfig(HttpServletRequest request) &#123; //获取nacos的accessToken String accessToken = getAccessToken(); accessToken = String.valueOf(JSON.parseObject(accessToken, Map.class).get(&quot;accessToken&quot;)); String url = &quot;http://xxxx/nacos/v1/cs/configs?dataId=&#123;dataId&#125;&amp;group=&#123;group&#125;&amp;tenant=&#123;tenant&#125;&amp;accessToken=&#123;accessToken&#125;&amp;namespaceId=&#123;namespaceId&#125;&quot;; Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); paramMap.put(&quot;dataId&quot;,&quot;xxx&quot;); paramMap.put(&quot;group&quot;,&quot;DEFAULT_GROUP&quot;); paramMap.put(&quot;tenant&quot;,&quot;xx&quot;); paramMap.put(&quot;accessToken&quot;, accessToken); paramMap.put(&quot;namespaceId&quot;,&quot;xxx&quot;); //设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(null, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class, paramMap); return response.getBody(); &#125; /** * 获取nacos的accessToken **/ private String getAccessToken() &#123; String url = &quot;http://xxx/nacos/v1/auth/login&quot;; MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;(); paramMap.add(&quot;username&quot;,&quot;nacos&quot;); paramMap.add(&quot;password&quot;,&quot;nacos&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); //请求类型为表单 HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(paramMap, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody(); &#125;&#125; 五 发送POST请求 使用RestTemplate post请求的时候主要可以通过三种方式实现 调用postForObject方法 调用postEntity方法 调用exchange方法 postForObject和postForEntity方法的区别主要在于可以在postForEntity方法中设置header的属性，当需要指定header的属性值的时候，使用postForEntity方法。exchange方法和postForEntity类似，但是更灵活，exchange还可以调用get、put、delete请求。 ContentType是表单 当ContentType的类型为表单类型时(content-type=application/x-www-form-urlencoded等)post请求的body不能是json也不能是map必须是MultiValueMap类型 1234567891011121314private String getAccessToken() &#123; String url = &quot;http://xxx/nacos/v1/auth/login&quot;; //因为ContentType是表单 所以用MultiValueMap去对表单进行设值 MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;(); paramMap.add(&quot;username&quot;,&quot;nacos&quot;); paramMap.add(&quot;password&quot;,&quot;nacos&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); //请求类型为表单 HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(paramMap, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody();&#125; ContentType是JSON 当ContentType是json的时候 就没有这么麻烦了 可以直接填充json格式的参数作为body 12345678910111213@RequestMapping(path = &quot;/test&quot;, method = RequestMethod.GET) public String test() &#123; String url = &quot;https://xxx/web/message/view/unread&quot;; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;coupon&quot;, true); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); //设值contentType是application/json headers.add(&quot;Cookie&quot;, &quot;xxx&quot;); //添加cookie HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(JSON.toJSONString(paramMap), headers); //这里body被转换成了json ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody(); &#125; 六 发送GET请求restTemplate发送GET请求如果需要带参数 必须在url上填充占位符 示例如下 12345678910111213141516171819202122232425/** * 获取nacos中指定dataId的配置信息 **/ @RequestMapping(path = &quot;/getConfig&quot;, method = RequestMethod.GET) public String getConfig(HttpServletRequest request) &#123; //获取nacos的accessToken String accessToken = getAccessToken(); accessToken = String.valueOf(JSON.parseObject(accessToken, Map.class).get(&quot;accessToken&quot;)); String url = &quot;http://xxxx/nacos/v1/cs/configs?dataId=&#123;dataId&#125;&amp;group=&#123;group&#125;&amp;tenant=&#123;tenant&#125;&amp;accessToken=&#123;accessToken&#125;&amp;namespaceId=&#123;namespaceId&#125;&quot;; //注意这里url中的&#123;xx&#125;都是占位符 Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); //这里用map而不用MultiValueMap paramMap.put(&quot;dataId&quot;,&quot;xxx&quot;); paramMap.put(&quot;group&quot;,&quot;DEFAULT_GROUP&quot;); paramMap.put(&quot;tenant&quot;,&quot;xx&quot;); paramMap.put(&quot;accessToken&quot;, accessToken); paramMap.put(&quot;namespaceId&quot;,&quot;xxx&quot;); //设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(null, headers); //注意get请求时 这里填充的是null ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class, paramMap); return response.getBody(); &#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"Spring BeanPostProcessor最佳实践","slug":"FAQ-Spring BeanPostProcessor最佳实践","date":"2021-11-10T13:53:16.193Z","updated":"2022-04-06T13:18:13.581Z","comments":false,"path":"2021/11/10/FAQ-Spring BeanPostProcessor最佳实践/","link":"","permalink":"http://example.com/2021/11/10/FAQ-Spring%20BeanPostProcessor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"BeanPostProcessor接口的作用是在Spring bean 实例化完成后(执行完initializeBean)之后，初始化之前(执行bean的初始化方法)对Bean添加一些自定义的处理逻辑。也就是说执行beanProcessor方法是在bean实例化之后 此时bean的属性值都已经被赋值好了。另外需要注意的是 beanProcessor的实现类一定要被Spring托管才能生效。 一、BeanPostProcessor示例 实体类 12345678910111213141516171819202122232425262728293031323334@Component@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public class DataSourceProperty &#123; private String userName; private String password; /** * 通过@PostConstruct来标记这个init方法为bean的初始化方法 **/ @PostConstruct private void init() &#123; //这条语句会在 beanprocessor的postProcessBeforeInitialization方法执行之后执行 2 System.out.println(&quot;执行初始化方法&quot;); &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 配置 12spring.datasource.username=testspring.datasource.password=12345678 自定义的BeanPostProcessor实现类 1234567891011121314151617181920212223242526272829303132333435363738//这个类一定要被spring容器托管(也就是要能够被spring识别为一个bean) postProcessBeforeInitialization 和 //postProcessAfterInitialization才会生效@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; /** * bean实例化前处理 * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof DataSourceProperty) &#123; //这条语句是最先打印的 1 DataSourceProperty 此时它的两个属性是已经被赋值了的 System.out.println(&quot;dataSourceProperty 初始化前执行 dataSourceProperty&quot; ); &#125; return bean; &#125; /** * bean实例化后处理 * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof DataSourceProperty) &#123; //这条语句是最后打印的 System.out.println(&quot;dataSourceProperty 初始后执行&quot; ); &#125; return bean; &#125;&#125; 结果 二、为什么BeanPostProcessor必须被Spring托管才能生效 关于这一点可以查看源码 第一步 当Spring容器启动时 会先执行AbstractApplicationContext类的refresh方法 通过该方法去初始化我们的Spring容器 源码如下 1234567891011121314151617181920212223public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123; @Override public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //省略前面若干方法 prepareBeanFactory(beanFactory); try &#123; //此处省略若干方法 // 向Spring容器注册beanProstProcessor registerBeanPostProcessors(beanFactory); beanPostProcess.end(); //此处省略若干方法 完成Spring容器刷新工作 finishRefresh(); &#125;catch (BeansException ex) &#123; //此处省略 &#125;finally &#123; //此处生路 &#125; &#125; &#125;&#125; 第二步 从第一步 我们知道了当Spring容器在执行refresh方法的时候 会向容器中注册beanProcessor 下面接着看registerBeanPostProcessors(beanFactory)方法的逻辑 该方法的真正实现是在PostProcessorRegistrationDelegate类中 12345678final class PostProcessorRegistrationDelegate &#123; public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; //核心方法 从beanFactory中获取容器中所有实现了BeanPostProcessor接口的bean的名称 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); //此后省略若干方法 &#125;&#125; 第三步 beanFactory.getBeanNamesForType() 这个方法真正的实现是在DefaultListableBeanFactory中 12345678910111213public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123; @Override public String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit) &#123; if (!isConfigurationFrozen() || type == null || !allowEagerInit) &#123; //真正获取beanPostProcessor的名称的方法 return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit); &#125; //此处省略若干方法 return resolvedBeanNames; &#125;&#125; 第四步 123456789101112131415161718192021public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123; private String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); // 它会遍历Spring容器的beanDefinitionNames for (String beanName : this.beanDefinitionNames) &#123; //此处省略若干方法 //如果类型是指定的类型 则将这个bean的名称加入到list中 //对于BeanPostProcessor来说 此时type就是BeanPostProcessor boolean matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit); //此处省略若干方法 if (matchFound) &#123; result.add(beanName); &#125; //此处省略若干方法 &#125; return StringUtils.toStringArray(result); &#125;&#125; 可以发现它最终还是需要通过遍历Spring容器中所有的beanName才能够将这个bean注册为BeanProcessor 如果这个BeanPostProcessor的实现类都没有被Spring托管 也就不可能被注册为beanProcessor 这也就是为什么beanProcessor的实现类 必须被spring托管才能生效。 三、BeanPostProcessor执行的流程 12345678910111213141516//第一步 容器刷新1、AbstractApplicationContext.refresh()//第二步 完成beanFactory初始化2、AbstractApplicationContext.finishBeanFactoryInitialization(beanFactory); //第三步 默认的beanFactory开始预实例化单例bean3、DefaultListableBeanFactory.preInstantiateSingletons();//第四步 开始根据bean的名称获取bean4、AbstractBeanFactory.getBean(String name);//第五步 执行doCreateBean方法 开始创建bean5、AbstractAutowireCapableBeanFactory.doCreateBean()//第六步 对bean进行初始化AbstractAutowireCapableBeanFactory.initializeBean() //第七步 开始遍历beanProcessor 执行beanProcessor的postProcessBeforeInitialization方法AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization();//第八步 执行beanPostProcessor的后置方法AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(); initializeBean源码 12345678910111213141516171819202122232425protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; //此处省略若干方法 Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //执行beanPostProcessor的前置方法 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //执行bean的初始化方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; //执行beanPostProcessor的后置方法 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; applyBeanPostProcessorsBeforeInitialization源码 123456789101112131415@Override public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; //遍历beanPostProcessor 执行前置方法 for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result; &#125; applyBeanPostProcessorsAfterInitialization源码 1234567891011121314@Override public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessAfterInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result; &#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"ConfigurationProperties注解配置复杂类型","slug":"FAQ-@ConfigurationProperties如何配置复杂类型","date":"2021-11-06T13:50:51.478Z","updated":"2022-04-06T12:48:12.629Z","comments":false,"path":"2021/11/06/FAQ-@ConfigurationProperties如何配置复杂类型/","link":"","permalink":"http://example.com/2021/11/06/FAQ-@ConfigurationProperties%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"@ConfigurationProperties 注解可以以前缀的形式统一注入某个前缀的参数 如下面的示例 示例 12345678910#数据源spring.datasource.druid.write.url=jdbc:mysql://localhost:3306/jpaspring.datasource.druid.write.username=rootspring.datasource.druid.write.password=1spring.datasource.druid.write.driver-class-name=com.mysql.jdbc.Driverspring.datasource.druid.read.url=jdbc:mysql://localhost:3306/jpaspring.datasource.druid.read.username=rootspring.datasource.druid.read.password=1spring.datasource.druid.read.driver-class-name=com.mysql.jdbc.Driver 123456789101112131415161718192021222324@Configurationpublic class DruidDataSourceConfig &#123; /** * DataSource 配置 * @return */ @ConfigurationProperties(prefix = &quot;spring.datasource.druid.read&quot;) @Bean(name = &quot;readDruidDataSource&quot;) public DataSource readDruidDataSource() &#123; return new DruidDataSource(); &#125; /** * DataSource 配置 * @return */ @ConfigurationProperties(prefix = &quot;spring.datasource.druid.write&quot;) @Bean(name = &quot;writeDruidDataSource&quot;) @Primary public DataSource writeDruidDataSource() &#123; return new DruidDataSource(); &#125;&#125; 可以看到示例中的配置其实是有两个前缀 spring.datasource.druid.read、spring.datasource.druid.write 如果需要用一个配置类去接收应该怎么去做？可以参考下面的示例 解决方案 下面的配置实现了将read和write两个不同前缀的配置放在了一个配置类中进行注入 核心思想就是利用了内部类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * @ConfigurationProperties 注解必须配合@Component、@Bean、@Configuration注解一起使用 * 也就是说@ConfigurationProperties注解的类 必须被spring托管 * @date 2021/11/06 **/@Component@ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;)public class DataSourceProperties &#123; //write内部类 用于配置前缀为spring.datasource.druid.write的配置 private Write write = new Write(); //read内部类 用于配置前缀为spring.datasource.druid.read的配置 private Read read = new Read(); public Write getWrite() &#123; return write; &#125; public void setWrite(Write write) &#123; this.write = write; &#125; public Read getRead() &#123; return read; &#125; public void setRead(Read read) &#123; this.read = read; &#125; public class Write &#123; private String url; private String username; private String password; private String driverClassName; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; &#125; public class Read &#123; private String url; private String username; private String password; private String driverClassName; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; &#125;&#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"log4j不打印异常栈","slug":"FAQ-log4j不打印异常栈","date":"2021-11-05T07:17:45.378Z","updated":"2022-04-06T13:17:20.236Z","comments":false,"path":"2021/11/05/FAQ-log4j不打印异常栈/","link":"","permalink":"http://example.com/2021/11/05/FAQ-log4j%E4%B8%8D%E6%89%93%E5%8D%B0%E5%BC%82%E5%B8%B8%E6%A0%88/","excerpt":"","text":"​最近在线上系统的错误日志中发现了一个现象 : 代码里用log4j打印系统运行时异常堆栈信息，在错误日志中无法看到堆栈信息，只有异常信息。后来发现这个是jdk的一个优化。JVM 为了性能会做优化，如果频繁的抛出某个异常，会重新编译，不再打印异常堆栈。解决这个问题也比较简单，如果不想每次都去查前面的 log 去看堆栈，只要在启动参数加上 -XX:-OmitStackTraceInFastThrow，就可以禁用该优化，强制打印异常堆栈。这样可能会导致，log 文件过大，不过产线上今天之前的 log 文件都会被压缩，所以感觉问题也不大。","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]}],"categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"},{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/categories/Algorithm/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"},{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"XXL-JOB","slug":"XXL-JOB","permalink":"http://example.com/tags/XXL-JOB/"}]}