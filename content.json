{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2022-01-31T10:37:45.000Z","updated":"2022-01-31T10:37:45.195Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"FAQ","date":"2022-02-01T12:07:35.000Z","updated":"2022-02-01T12:07:35.327Z","comments":true,"path":"FAQ/index.html","permalink":"http://example.com/FAQ/index.html","excerpt":"","text":""},{"title":"设计模式","date":"2022-02-01T01:21:39.000Z","updated":"2022-02-01T01:21:39.064Z","comments":true,"path":"设计模式/index.html","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-31T08:54:22.000Z","updated":"2022-01-31T09:33:06.311Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"UML","slug":"设计模式-UML","date":"2022-01-31T08:19:09.025Z","updated":"2022-02-01T06:19:18.128Z","comments":false,"path":"2022/01/31/设计模式-UML/","link":"","permalink":"http://example.com/2022/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML/","excerpt":"","text":"一 UML图中的六种关系UML将事物之间的联系归纳为6种 分别是 关联关系、聚合关系、组合关系、泛化关系、实现关系、依赖关系 关联关系 关联关系 是对象之间的一种引用关系，表示一个类和另一个类之间的联系。关联关系有单向的也有双向的，在UML类图中 单向关联用一个带箭头的实线表示，双向关联用没有箭头的实线来表示 (一个类A的成员变量包含了另一个类B 则该A与B之间是关联关系 类A与类B在同一个层次) 聚合关系 聚合关系其实也是关联关系的一种 即它也满足 (一个类A的成员变量包含了另一个类B) 聚合关系与关联关系最大的区别是 类A与类B不是同一个层次 这是一个逻辑上的概念 代码中无法呈现。成员是整体的一部分，成员也可以脱离整体而存在。在UML类图中，用带空心菱形的实线来表示聚合关系，菱形指向整体。 组合关系 组合关系首先也是关联关系的一种 同时也是聚合关系的一种 即它满足(一个类A的成员变量包含了另一个类B 且 A 与 B不是同一个层次) 它与聚合关系最大的区别是聚合关系中类B是可以单独存在的 而组合关系中类B不能单独存在(能否单独存在 也是一个逻辑上的概念 代码无法区分) 在UML类图中，用带实心菱形的实线来表示组合关系，菱形指向整体 下图中 大脑是身体的一个组成部分 且大脑 不能脱离身体而存在 泛化关系 泛化关系表示的就是类与类之间的继承关系，在UML类图中，用带空心三角箭头的实线来表示泛化关系，箭头从子类指向父类 依赖关系 依赖关系通常表现为一个类(A)的某个方法的参数或者方法中的局部变量使用了另外一个类的对象，注意关联关系讲的是成员变量 而 依赖关系讲的是 局部变量或者方法参数。在UML类图中，依赖关系用带箭头的虚线表示，箭头从使用类指向被依赖的类 实现关系 实现关系就是接口和实现类之间的关系，在UML类图中，用带空心三角箭头的虚线来表示实现关系，箭头从实现类指向接口。 二 时序图时序图是用来描述对象之间消息的发送顺序，横轴表示对象，纵轴表示时间，消息(行为的说明)在各个对象之间横向传递，按照时间顺序排列。时序图的组成元素主要包括 角色(Actor)、对象(Object)、生命线(Lifeline)、控制焦点和消息。 角色 时序图的角色 可以是人、机器、其他系统、子系统 对象 可以理解为执行的主体 他可以是java中的对象 也可以是某个组件、平台、机构等等 消息 消息有同步调用、异步调用、方法返回 同步调用 用实心箭头实线来表示 方法返回 用空心箭头虚线来表示 异步调用 用空心箭头实线来表示 时序图还有一个很重要的概念就是组合片段，组合片段是用来解决交互执行的条件和方式，它允许在时序图中直接表示某段逻辑，时序图的组合片段一共有13种 常用的有如下几种 抉择(Alt) 相当于if else的逻辑 选项(Opt) 仅当提供的条件为真时才执行片段。 相当于只有一条迹线的alt 循环(Loop) 片段可以执行多次，并且防护指示迭代的基础 并行(Par) 每个片段并行运行 时序图常用图例 同步调用 方法返回 异步调用 抉择 选项 选项就是一个单次的Alt 相当于没有else的Alt 满足条件就进来 不满足条件 不做任何处理 走后续的流程 循环","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理","slug":"设计模式-代理模式","date":"2022-01-26T14:49:18.927Z","updated":"2022-02-01T08:42:48.287Z","comments":false,"path":"2022/01/26/设计模式-代理模式/","link":"","permalink":"http://example.com/2022/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式主要是在用户端与目标对象中间 产生一个代理对象，通过代理对象来保护目标对象或者对目标对象的功能进行增强。 一 静态代理通用写法所谓静态代理 就是代理类是固定存在的(在编译期就已经生成了的) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//目标对象需要被代理的接口public interface ISubject &#123; //目标对象(被代理对象)核心方法 void execute(String request);&#125;//目标对象public class RealSubject implements ISubject &#123; @Override public void execute(String request) &#123; System.out.println(&quot;目标对象执行request请求&quot;); &#125;&#125;//代理对象public class Proxy implements ISubject&#123; private ISubject target; //静态代理的第二种写法就是将目标对象直接在代理类中实例化 这样可以避免客户端直接访问真实对象 private Proxy(ISubject target)&#123; this.target = target; &#125; public static Proxy getInstance(ISubject subject) &#123; return new Proxy(subject); &#125; @Override public void execute(String request) &#123; before(target); target.execute(request); //目标对象执行execute方法 after(target); &#125; private void before(ISubject subject) &#123; System.out.println(&quot;前置处理&quot;); &#125; private void after(ISubject subject) &#123; System.out.println(&quot;后置处理&quot;); &#125;&#125;//测试public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = Proxy.getInstance(new RealSubject()); proxy.execute(&quot;测试&quot;); &#125;&#125; 二 JDK动态代理示例动态代理是指代理类是在运行期动态生成的 JDK动态代理核心是要创建一个代理类(代理类必须实现InvocationHandler接口) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//要代理的接口public interface IPerson &#123; //相亲 void findLove(String name);&#125;//真实对象public class Person implements IPerson &#123; private String name; public Person(String name)&#123; this.name = name; &#125; @Override public void findLove(String miss) &#123; System.out.println(name + &quot;和&quot; + miss + &quot;相亲&quot;); &#125;&#125;//通用的代理类public class Proxy implements InvocationHandler &#123; private Object target; private Proxy(Object target) &#123; this.target = target; &#125; //这里对jdk动态代理做了一点变动 本来是应该放在场景内中去使用的 被抽离道理代理类中 public static Object getInstance(Object target, Class&lt;?&gt;[] interfaces) &#123; Proxy proxy = new Proxy(target); return java.lang.reflect.Proxy.newProxyInstance(target。getClass().getClassLoader(), interfaces, proxy); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); after(); return result; &#125; public void before() &#123; System.out.println(&quot;前置处理&quot;); &#125; public void after()&#123; System.out.println(&quot;后置处理&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; IPerson person = (IPerson) Proxy.getInstance(new Person(&quot;张三&quot;), new Class[]&#123;IPerson.class&#125;); person.findLove(&quot;李四&quot;); &#125;&#125; 三 Cglib动态代理导入cglib依赖 123456&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Person &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void findLove(String miss) &#123; System.out.println(name + &quot;和&quot; + miss + &quot;相亲&quot;); &#125;&#125;public class Proxy implements MethodInterceptor &#123; public Person getPerson() &#123; //Enhancer 类似于JDK动态代理的Proxy类 它负责创建代理类 Enhancer enhancer = new Enhancer(); //设置代理类的父类(就是真实/目标对象) enhancer.setSuperclass(Person.class); //设置回调函数 这个类似于JDK动态代理的InvocationHandler接口的实现 enhancer.setCallback(this); return (Person)enhancer.create(); &#125; /** * * @param o 这个参数是Cglib代理类的实例 类似于JDK的InvocationHandler接口的proxy参数 * @param method method为正在被调用的方法 * @param args args为方法参数 * @param proxy proxy 为生成的代理类对方法的代理引用 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; before(); proxy.invokeSuper(o, args); after(); return null; &#125; private void before()&#123; System.out.println(&quot;执行前置处理&quot;); &#125; private void after()&#123; System.out.println(&quot;执行后置处理&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); Person person = proxy.getPerson(); person.setName(&quot;李四&quot;); person.findLove(&quot;张三&quot;); &#125;&#125; 四 三种代理的对比在JDK1.6、JDK1.7、JDK1.8逐步对JDK进行动态代理优化之后，在调用次数较少的情况下, JDK代理的效率比Cglib效率高，当大量调用的时候,JDK1.6、JDK1.7的效率比Cglib效率低。但是JDK1.8的时候，JDK代理效率高于Cglib代理，所以如果有接口使用JDK动态代理，没有接口用Cglib代理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者","slug":"设计模式-建造者模式","date":"2022-01-25T15:44:06.884Z","updated":"2022-02-01T06:27:57.522Z","comments":false,"path":"2022/01/25/设计模式-建造者模式/","link":"","permalink":"http://example.com/2022/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式和工厂模式很像，建造者模式主要偏重于创建复杂对象，它一般被设计为链式调用，一般会在复杂对象中创建一个builder的静态内部类，同时提供一个build方法 示例如下 建造者模式还有一个重要的作用是控制对象变量设值的顺序 在某些需要控制对象属性构建的顺序的场景下比较适用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//测试类public class Client &#123; public static void main(String[] args) &#123; Course.CourseBuilder builder = new Course.CourseBuilder(); Course course = builder.addName(&quot;java&quot;).addNote(new Note(&quot;java笔记&quot;)).addVideo(new Video(&quot;java视频&quot;)).build(); System.out.println(course); &#125;&#125;@Data@ToStringclass Course &#123; private String courseName; private Note note; private Video video; private Course()&#123; &#125; //在建造者模式中builder类一般设计为静态内部类 public static class CourseBuilder &#123; Course course = new Course(); //builder类被设计为允许链式调用 public CourseBuilder addName(String name)&#123; course.setCourseName(name); return this; &#125; public CourseBuilder addNote(Note note)&#123; course.setNote(note); return this; &#125; public CourseBuilder addVideo(Video video) &#123; course.setVideo(video); return this; &#125; public Course build() &#123; return course; &#125; &#125;&#125;@Data@AllArgsConstructor@ToStringclass Note &#123; private String name;&#125;@Data@AllArgsConstructor@ToStringclass Video &#123; private String name;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂","slug":"设计模式-抽象工厂","date":"2022-01-23T15:17:16.828Z","updated":"2022-02-01T08:42:58.799Z","comments":false,"path":"2022/01/23/设计模式-抽象工厂/","link":"","permalink":"http://example.com/2022/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","excerpt":"","text":"抽象工厂可以看做是工厂方法的集合 工厂方法中 一个工厂只能生产一种产品 而抽象工厂中 一个具体的工厂则可以生产多个产品 所谓的产品可以理解为一个接口 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//抽象工厂public interface Course &#123; Note getNote(); //如果抽象工厂中 只包含一个产品(接口)的创建 那么它就是工厂方法 Video getVideo();&#125;//抽象产品Apublic interface Note &#123; void note();&#125;//抽象产品Bpublic interface Video &#123; void play();&#125;//A产品族public class JavaCourse implements Course&#123; @Override public Note getNote() &#123; return new JavaNote(); &#125; @Override public Video getVideo() &#123; return new JavaVideo(); &#125;&#125;//B产品族public class PythonCourse implements Course&#123; @Override public Note getNote() &#123; return new PythonNote(); &#125; @Override public Video getVideo() &#123; return new PythonVideo(); &#125;&#125;//A产品族中的A产品public class JavaNote implements Note&#123; @Override public void note() &#123; System.out.println(&quot;java课堂笔记&quot;); &#125;&#125;//A产品族中的B产品public class JavaVideo implements Video&#123; @Override public void play() &#123; System.out.println(&quot;java课堂视频&quot;); &#125;&#125;//B产品族中的A产品public class PythonNote implements Note&#123; @Override public void note() &#123; System.out.println(&quot;python课堂笔记&quot;); &#125;&#125;//B产品族中的B产品public class PythonVideo implements Video&#123; @Override public void play() &#123; System.out.println(&quot;python课堂视频&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; JavaCourse javaCourse = new JavaCourse(); javaCourse.getVideo().play(); javaCourse.getNote().note(); PythonCourse pythonCourse = new PythonCourse(); pythonCourse.getNote().note(); pythonCourse.getVideo().play(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法","slug":"设计模式-工厂方法","date":"2022-01-23T09:43:37.149Z","updated":"2022-02-01T06:21:08.350Z","comments":false,"path":"2022/01/23/设计模式-工厂方法/","link":"","permalink":"http://example.com/2022/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/","excerpt":"","text":"工厂方法模式区别于简单工厂，最主要的区别是简单工厂只有一个工厂类，而在工厂方法中，会有一个抽象的工厂(接口/抽象类) 同时会有若干个具体的工厂 但是抽象的产品只会有一个。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//抽象的工厂接口public interface IFactory &#123; IProduct createProduct();&#125;//抽象的产品接口public interface IProduct &#123; void productInfo();&#125;//产品Apublic class ProductA implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//产品Bpublic class ProductB implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//工厂Apublic class FactoryA implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductA(); &#125;&#125;//工厂Bpublic class FactoryB implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductB(); &#125;&#125;//这个可以理解为工厂的工厂 实际它不算在工厂方法设计模式中public class FactoryHelper &#123; private static final Map&lt;Class&lt;? extends IFactory&gt;, IFactory&gt; factories = new ConcurrentHashMap&lt;&gt;(); static &#123; registry(FactoryA.class, new FactoryA()); registry(FactoryB.class, new FactoryB()); &#125; public static IFactory getFactory(Class&lt;? extends IFactory&gt; clazz)&#123; return factories.get(clazz); &#125; public static void registry(Class&lt;? extends IFactory&gt; clazz, IFactory factory) &#123; factories.put(clazz, factory); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; IProduct productA = FactoryHelper.getFactory(FactoryA.class).createProduct(); productA.productInfo(); IProduct productB = FactoryHelper.getFactory(FactoryB.class).createProduct(); productB.productInfo(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计原则","slug":"设计模式-设计原则","date":"2022-01-22T13:40:18.206Z","updated":"2022-02-01T06:20:03.272Z","comments":false,"path":"2022/01/22/设计模式-设计原则/","link":"","permalink":"http://example.com/2022/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"开闭原则 是指一个软件实体 如类、模块、函数应该对扩展开放，对修改关闭。 依赖倒置原则 是指代码之间的发生依赖的时候 应该依赖其抽象(接口) 这样可以降低类与类之间的耦合性，提高系统稳定性 单一职责原则 是指一个类只能拥有一个变动的因素 也就是一个类只负责一个职责 单一职责其实就是告诉我们 类和方法都要设计的足够的小 接口隔离原则 一个类对另一个类的依赖应该建立在最小接口上；建立单一的接口 不要建立过于庞大的接口 迪米特法则 又叫最少知道原则 是指一个对象应该尽量降低与其他类的耦合；迪米特法则其实也是告诉我们要依赖最小接口 而不是实现 里氏替换原则 它强调的是对父类与子类的一个约束 简单来说就是在声明变量(成员变量、局部变量、方法参数)的时候 应该要用父类引用指向子类对象 里氏替换原则要求 1、子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法 2、子类可以增加自己特有的方法，3、子类在重载父类方法的时候 方法的参数要比父类更宽松 4、当子类实现父类方法的时候 方法的返回要比父类更加的严格。 合成复用原则 强调的是我们应该尽量减少通过继承的方式来进行代码的复用 更多的应该通过聚合或者组合的形式来进行代码复用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"简单工厂","slug":"设计模式-简单工厂","date":"2022-01-05T13:37:32.895Z","updated":"2022-02-01T06:20:27.635Z","comments":false,"path":"2022/01/05/设计模式-简单工厂/","link":"","permalink":"http://example.com/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/","excerpt":"","text":"简单工厂区别于其他工厂最主要的特征就是有一个具体的工厂类 下面是简单工厂的类图 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//产品接口public interface Product &#123; void display();&#125;//具体产品Apublic class ProductA implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//具体产品Bpublic class ProductB implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//具体产品Cpublic class ProductC implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品C&quot;); &#125;&#125;//简单工厂public class Factory &#123; private Factory() &#123; &#125; public static Factory getInstance() &#123; return Inner.instance; &#125; public Product createProduct(Class&lt;? extends Product&gt; clazz) throws Exception&#123; if (clazz == null) &#123; return null; &#125; Product product = clazz.newInstance(); //此处省略若干创建对象时的所需要的操作 因为一般工厂模式创建对象都是创建复杂对象 return product; &#125; private static class Inner &#123; private static final Factory instance = new Factory(); &#125;&#125;//测试类public class FactoryTest &#123; public static void main(String[] args) throws Exception &#123; Factory factory = Factory.getInstance(); Product product = factory.createProduct(ProductA.class); product.display(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"tk.mybatis集成多数据源","slug":"FAQ-tk.mybatis集成多数据源","date":"2021-12-30T06:37:52.813Z","updated":"2022-02-01T12:57:47.846Z","comments":false,"path":"2021/12/30/FAQ-tk.mybatis集成多数据源/","link":"","permalink":"http://example.com/2021/12/30/FAQ-tk.mybatis%E9%9B%86%E6%88%90%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/","excerpt":"","text":"pom 依赖123456789101112131415161718 &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--分页可以不要--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 配置类主数据源 12345678910111213141516171819202122232425262728293031323334353637383940414243@Configuration@MapperScan(basePackages = &#123;&quot;com.xxx.dao.gmp&quot;&#125;, sqlSessionTemplateRef = &quot;druidSqlSessionTemplate&quot;,markerInterface = BaseMapper.class)public class DataSourceConfig &#123; @Bean @Primary @ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;) public DataSourceProperties druidDataSourceProperties() &#123; return new DataSourceProperties(); &#125; @Bean @Primary public DataSource druidDataSource(@Qualifier(&quot;druidDataSourceProperties&quot;) DataSourceProperties druidDataSourceProperties) &#123; return druidDataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean @Primary public DataSourceTransactionManager druidTransactionManager(@Qualifier(&quot;druidDataSource&quot;) DataSource druidDataSource) &#123; return new DataSourceTransactionManager(druidDataSource); &#125; @Bean @Primary public SqlSessionTemplate druidSqlSessionTemplate(@Qualifier(&quot;druidSqlSessionFactory&quot;) SqlSessionFactory druidSqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(druidSqlSessionFactory); &#125; @Bean @Primary public SqlSessionFactory druidSqlSessionFactory(@Qualifier(&quot;druidDataSource&quot;) DataSource druidDataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); bean.setDataSource(druidDataSource); bean.setConfiguration(configuration); //手动指定mapp.xml的位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/gmp/*Mapper.xml&quot;)); return bean.getObject(); &#125;&#125; 第二数据源 1234567891011121314151617181920212223242526272829303132333435363738@Configuration@MapperScan(basePackages = &#123;&quot;com.xxx.dao.cmd&quot;&#125;, sqlSessionTemplateRef = &quot;cmdSqlSessionTemplate&quot;,markerInterface = BaseMapper.class)public class CMDDataSourceConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource.cmd&quot;) public DataSourceProperties cmdDataSourceProperties() &#123; return new DataSourceProperties(); &#125; @Bean public DataSource cmdDataSource(@Qualifier(&quot;cmdDataSourceProperties&quot;) DataSourceProperties cmdDataSourceProperties) &#123; return cmdDataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean public DataSourceTransactionManager cmdTransactionManager(@Qualifier(&quot;cmdDataSource&quot;) DataSource cmdDataSource) &#123; return new DataSourceTransactionManager(cmdDataSource); &#125; @Bean public SqlSessionTemplate cmdSqlSessionTemplate(@Qualifier(&quot;cmdSqlSessionFactory&quot;) SqlSessionFactory cmdSqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(cmdSqlSessionFactory); &#125; @Bean public SqlSessionFactory cmdSqlSessionFactory(@Qualifier(&quot;cmdDataSource&quot;) DataSource cmdDataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); bean.setDataSource(cmdDataSource); bean.setConfiguration(configuration); //手动指定mapp.xml的位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/cmd/*Mapper.xml&quot;)); return bean.getObject(); &#125;&#125; mapper 12345import com.gzhc365.arch.gmp.po.CMDServerInfo;import tk.mybatis.mapper.common.Mapper;public interface CMDServerInfoDAO extends Mapper&lt;CMDServerInfo&gt; &#123;&#125; 12345import com.gzhc365.arch.gmp.po.Application;import tk.mybatis.mapper.common.Mapper;public interface ApplicationDAO extends Mapper&lt;Application&gt; &#123;&#125; 配置 1234567891011#主数据源配置spring.datasource.druid.url = jdbc:mysql://xxx:3306/xxdb?allowPublicKeyRetrieval=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=truespring.datasource.druid.username = xxxspring.datasource.druid.password = xxxspring.datasource.druid.driver-class-name = com.mysql.jdbc.Driver#第二数据源配置spring.datasource.cmd.url = jdbc:mysql://xxx:3306/yyDb?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.cmd.username = yyyspring.datasource.cmd.password = yyyspring.datasource.cmd.driver-class-name = com.mysql.jdbc.Driver 多数据源的配置主要是相关配置类和properties配置文件的配置","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot配置文件属性自动提示","slug":"FAQ-SpringBoot配置文件属性自动提示","date":"2021-12-30T06:24:09.936Z","updated":"2022-02-01T12:56:25.979Z","comments":false,"path":"2021/12/30/FAQ-SpringBoot配置文件属性自动提示/","link":"","permalink":"http://example.com/2021/12/30/FAQ-SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA/","excerpt":"","text":"spring-boot-configuration-processor的作用 当我们再springboot的配置文件如application.properties 或者 application.yaml文件去填充配置的时候 会发现springboot配置文件会自动提示，但是我们自己自定义的一些配置无法提示。如图 要使得我们自定义的配置也能达到这样的效果(自动提示) 需要借助spring-boot-configuration-processor 这个jar 同时需要配和使用@ConfigurationProperties注解来实现 spring-boot-configuration-processor的作用是生成配置的元数据信息，即在classes目录下的META-INF目录下生成spring-configuration-metadata.json文件，从而告诉spring这个jar包中有哪些自定义的配置 还可以在resources目录下手动添加META-INF/additional-spring-configuration-metadata.json文件，这个文件是手动添加的，用于对spring-configuration-metadata.json进行补充，编译后会合并到spring-configuration-metadata.json中 示例 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt; 配置好之后一定要先编译 不然是不会生效的(执行maven的package或者install命令) 效果如下 自定义的配置 hc.custom.xx 博客链接 1https://www.cnblogs.com/tonglin0325/p/5344129.html","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"maven依赖冲突如何解决","slug":"FAQ-maven依赖冲突解决方案","date":"2021-12-30T03:39:39.989Z","updated":"2022-02-01T12:25:40.998Z","comments":false,"path":"2021/12/30/FAQ-maven依赖冲突解决方案/","link":"","permalink":"http://example.com/2021/12/30/FAQ-maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"问题启动时项目时报错如下 1NoClassDefFoundError org/mybatis/logging/LoggerFactory 明明已经集成了mybatis相关依赖 还报找不到类定义 检查完pom之后 确认依赖没问题以后 可以借助idea的maven helper插件 查看下当前的mybatis依赖是否有冲突 解决办法 利用maven helper插件排除多余的依赖 重新更新maven依赖(reimport ) 即可","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"单例","slug":"设计模式-单例","date":"2021-12-19T08:02:05.637Z","updated":"2022-02-01T06:27:54.297Z","comments":false,"path":"2021/12/19/设计模式-单例/","link":"","permalink":"http://example.com/2021/12/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/","excerpt":"","text":"单例模式的核心点是构造器私有化 并提供一个全局访问点 一 饿汉式123456789101112public class Singleton01 &#123; private static final Singleton01 instance = new Singleton01(); private Singleton01() &#123; &#125; public static Singleton01 getInstance() &#123; return instance; &#125;&#125; 二 懒汉式 双重检测锁的实现12345678910111213141516171819public class Singleton02 &#123; private static volatile Singleton02 instance; private Singleton02 ()&#123; &#125; public static Singleton02 getInstance()&#123; if (instance == null) &#123; synchronized (Singleton02.class) &#123; if (instance == null) &#123; instance = new Singleton02(); &#125; &#125; &#125; return instance; &#125;&#125; 三 懒汉式 静态内部类实现1234567891011121314public class Singleton03 &#123; private Singleton03() &#123; &#125; public static Singleton03 getInstance()&#123; return Singleton03Holder.instance; &#125; private static class Singleton03Holder &#123; static Singleton03 instance = new Singleton03(); &#125;&#125; 四 枚举实现单例java规范规定 枚举类是没有构造方法 所以这种写法可以防止通过java反射 利用构造器去创建对象 上面的三种方式都无法防止 但是枚举单例可以 12345678public enum Singleton04 &#123; INSTANCE; //其他业务方法 public void sayHello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 枚举单例序列化测试 1234567891011121314151617181920212223242526272829303132333435363738//枚举默认是实现了序列化接口的 不需要单独的实现序列化接口了public enum Singleton &#123; INSTANCE;&#125;public class Client &#123; public static void main(String[] args) throws Exception&#123; String path = &quot;/Users/liliang/code/test/comon-test/src/main/java/com/liliang/test/test/Singleton02.java&quot;; FileOutputStream fos = null; ObjectOutputStream oos = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fos = new FileOutputStream(path); oos = new ObjectOutputStream(fos); oos.writeObject(Singleton.INSTANCE); fis = new FileInputStream(path); ois = new ObjectInputStream(fis); Object object = ois.readObject(); System.out.println(object.hashCode()); //测试结果 hashcode 与 下面的hashcode是一样的 System.out.println(Singleton.INSTANCE.hashCode()); &#125;finally &#123; //文件流的关闭顺序 后用先关 如果用了处理流 则只需要关闭处理流就行了 节点流不需要关闭。 if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125;&#125; 五 通用防止序列化破坏单例的解决办法上述的的单例实现方式除了枚举 都不能再单例类实现序列化接口后 还保证单例 要想在单例类实现序列化接口后还能保证单例 需要增加一个readResolve()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Singleton implements Serializable &#123; private static final long serialVersionUID = 7518189569602396628L; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return Inner.instance; &#125; //必须要加readResolve方法 方法名和返回值都不能错 private Object readResolve() &#123; return Inner.instance; &#125; private static class Inner&#123; private static final Singleton instance = new Singleton(); &#125;&#125;public class Client &#123; public static void main(String[] args) throws Exception&#123; String path = &quot;/Users/liliang/code/test/comon-test/src/main/java/com/liliang/test/test/Singleton02.txt&quot;; FileOutputStream fos = null; ObjectOutputStream oos = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fos = new FileOutputStream(path); oos = new ObjectOutputStream(fos); oos.writeObject(Singleton.getInstance()); fis = new FileInputStream(path); ois = new ObjectInputStream(fis); Object object = ois.readObject(); System.out.println(object.hashCode()); System.out.println(Singleton.getInstance().hashCode()); &#125;finally &#123; //文件流的关闭顺序 后用先关 如果用了处理流 则只需要关闭处理流就行了 节点流不需要关闭。 if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"easyexcel使用报错","slug":"FAQ-easyexcel使用报错","date":"2021-11-23T10:32:48.552Z","updated":"2022-02-01T12:34:24.753Z","comments":false,"path":"2021/11/23/FAQ-easyexcel使用报错/","link":"","permalink":"http://example.com/2021/11/23/FAQ-easyexcel%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/","excerpt":"","text":"报错信息 1easyexcel The maximum length of cell contents (text) is 32,767 characters 使用easyexcel向excel中写内容出现了单元格大小不能超过32,767的限制，这是因为excel 2007限制单个cell不能超过32767个字符 解决办法 重写poi包下SpreadsheetVersion类在自己的项目文件夹下创建org.apache.poi.ss.SpreadsheetVersion类，复制poi中的该类源码，excel2007中的最后一个值改为int类型最大值。重试导出问题解决。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * @author liliang * @date 2021/11/23 **/public enum SpreadsheetVersion &#123; /** * Excel97 format aka BIFF8 * &lt;ul&gt; * &lt;li&gt;The total number of available rows is 64k (2^16)&lt;/li&gt; * &lt;li&gt;The total number of available columns is 256 (2^8)&lt;/li&gt; * &lt;li&gt;The maximum number of arguments to a function is 30&lt;/li&gt; * &lt;li&gt;Number of conditional format conditions on a cell is 3&lt;/li&gt; * &lt;li&gt;Number of cell styles is 4000&lt;/li&gt; * &lt;li&gt;Length of text cell contents is 32767&lt;/li&gt; * &lt;/ul&gt; */ EXCEL97(0x10000, 0x0100, 30, 3, 4000, 32767), /** * Excel2007 * * &lt;ul&gt; * &lt;li&gt;The total number of available rows is 1M (2^20)&lt;/li&gt; * &lt;li&gt;The total number of available columns is 16K (2^14)&lt;/li&gt; * &lt;li&gt;The maximum number of arguments to a function is 255&lt;/li&gt; * &lt;li&gt;Number of conditional format conditions on a cell is unlimited * (actually limited by available memory in Excel)&lt;/li&gt; * &lt;li&gt;Number of cell styles is 64000&lt;/li&gt; * &lt;li&gt;Length of text cell contents is 32767&lt;/li&gt; * &lt;ul&gt; */ EXCEL2007(Integer.MAX_VALUE, Integer.MAX_VALUE, 255, Integer.MAX_VALUE, 64000, Integer.MAX_VALUE); private final int _maxRows; private final int _maxColumns; private final int _maxFunctionArgs; private final int _maxCondFormats; private final int _maxCellStyles; private final int _maxTextLength; private SpreadsheetVersion(int maxRows, int maxColumns, int maxFunctionArgs, int maxCondFormats, int maxCellStyles, int maxText) &#123; _maxRows = maxRows; _maxColumns = maxColumns; _maxFunctionArgs = maxFunctionArgs; _maxCondFormats = maxCondFormats; _maxCellStyles = maxCellStyles; _maxTextLength = maxText; &#125; /** * @return the maximum number of usable rows in each spreadsheet */ public int getMaxRows() &#123; return _maxRows; &#125; /** * @return the last (maximum) valid row index, equals to &lt;code&gt; getMaxRows() - 1 &lt;/code&gt; */ public int getLastRowIndex() &#123; return _maxRows - 1; &#125; /** * @return the maximum number of usable columns in each spreadsheet */ public int getMaxColumns() &#123; return _maxColumns; &#125; /** * @return the last (maximum) valid column index, equals to &lt;code&gt; getMaxColumns() - 1 &lt;/code&gt; */ public int getLastColumnIndex() &#123; return _maxColumns - 1; &#125; /** * @return the maximum number arguments that can be passed to a multi-arg function (e.g. COUNTIF) */ public int getMaxFunctionArgs() &#123; return _maxFunctionArgs; &#125; /** * @return the maximum number of conditional format conditions on a cell */ public int getMaxConditionalFormats() &#123; return _maxCondFormats; &#125; /** * @return the maximum number of cell styles per spreadsheet */ public int getMaxCellStyles() &#123; return _maxCellStyles; &#125; /** * * @return the last valid column index in a ALPHA-26 representation * (&lt;code&gt;IV&lt;/code&gt; or &lt;code&gt;XFD&lt;/code&gt;). */ public String getLastColumnName() &#123; return CellReference.convertNumToColString(getLastColumnIndex()); &#125; /** * @return the maximum length of a text cell */ public int getMaxTextLength() &#123; return _maxTextLength; &#125;&#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"RestTemplate最佳实践","slug":"FAQ-RestTemplate最佳实践","date":"2021-11-17T13:41:35.214Z","updated":"2022-02-01T12:38:15.190Z","comments":false,"path":"2021/11/17/FAQ-RestTemplate最佳实践/","link":"","permalink":"http://example.com/2021/11/17/FAQ-RestTemplate%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"一 介绍RestTemplate 是Spring提供的一个用于http访问的工具模板 二 依赖使用restTemplate需要导入如下pom依赖 1234567891011&lt;!--restTemplate启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--根据需要导入httpcomponents--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.10&lt;/version&gt;&lt;/dependency&gt; 三 restTemplate配置在使用restTemplate之前 还需要简单的对restTemplate进行配置 配置类如下 123456789101112131415161718@Data@Configuration@ConfigurationProperties(prefix = &quot;xx.xx.xx&quot;)public class RestTemplateConfig &#123; private Long connectionTimeout = 1000L; private Long readTimeout = 1000L; @Bean //将RestTemplate装配为bean public RestTemplate restTemplate(RestTemplateBuilder builder) &#123; return builder .requestFactory(HttpComponentsClientHttpRequestFactory.class) .setConnectTimeout(Duration.ofMillis(connectionTimeout)) //设置http的链接超时时间 .setReadTimeout(Duration.ofMillis(readTimeout)) //设置http的响应超时时间 .build(); &#125;&#125; 四 使用restTemplate12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@RestControllerpublic class TestController &#123; @Autowired private RestTemplate restTemplate; /** * 获取nacos中指定dataId的配置信息 **/ @RequestMapping(path = &quot;/getConfig&quot;, method = RequestMethod.GET) public String getConfig(HttpServletRequest request) &#123; //获取nacos的accessToken String accessToken = getAccessToken(); accessToken = String.valueOf(JSON.parseObject(accessToken, Map.class).get(&quot;accessToken&quot;)); String url = &quot;http://xxxx/nacos/v1/cs/configs?dataId=&#123;dataId&#125;&amp;group=&#123;group&#125;&amp;tenant=&#123;tenant&#125;&amp;accessToken=&#123;accessToken&#125;&amp;namespaceId=&#123;namespaceId&#125;&quot;; Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); paramMap.put(&quot;dataId&quot;,&quot;xxx&quot;); paramMap.put(&quot;group&quot;,&quot;DEFAULT_GROUP&quot;); paramMap.put(&quot;tenant&quot;,&quot;xx&quot;); paramMap.put(&quot;accessToken&quot;, accessToken); paramMap.put(&quot;namespaceId&quot;,&quot;xxx&quot;); //设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(null, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class, paramMap); return response.getBody(); &#125; /** * 获取nacos的accessToken **/ private String getAccessToken() &#123; String url = &quot;http://xxx/nacos/v1/auth/login&quot;; MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;(); paramMap.add(&quot;username&quot;,&quot;nacos&quot;); paramMap.add(&quot;password&quot;,&quot;nacos&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); //请求类型为表单 HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(paramMap, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody(); &#125;&#125; 五 发送POST请求 使用RestTemplate post请求的时候主要可以通过三种方式实现 调用postForObject方法 调用postEntity方法 调用exchange方法 postForObject和postForEntity方法的区别主要在于可以在postForEntity方法中设置header的属性，当需要指定header的属性值的时候，使用postForEntity方法。exchange方法和postForEntity类似，但是更灵活，exchange还可以调用get、put、delete请求。 ContentType是表单 当ContentType的类型为表单类型时(content-type=application/x-www-form-urlencoded等)post请求的body不能是json也不能是map必须是MultiValueMap类型 1234567891011121314private String getAccessToken() &#123; String url = &quot;http://xxx/nacos/v1/auth/login&quot;; //因为ContentType是表单 所以用MultiValueMap去对表单进行设值 MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;(); paramMap.add(&quot;username&quot;,&quot;nacos&quot;); paramMap.add(&quot;password&quot;,&quot;nacos&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); //请求类型为表单 HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(paramMap, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody();&#125; ContentType是JSON 当ContentType是json的时候 就没有这么麻烦了 可以直接填充json格式的参数作为body 12345678910111213@RequestMapping(path = &quot;/test&quot;, method = RequestMethod.GET) public String test() &#123; String url = &quot;https://xxx/web/message/view/unread&quot;; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;coupon&quot;, true); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); //设值contentType是application/json headers.add(&quot;Cookie&quot;, &quot;xxx&quot;); //添加cookie HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(JSON.toJSONString(paramMap), headers); //这里body被转换成了json ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody(); &#125; 六 发送GET请求restTemplate发送GET请求如果需要带参数 必须在url上填充占位符 示例如下 12345678910111213141516171819202122232425/** * 获取nacos中指定dataId的配置信息 **/ @RequestMapping(path = &quot;/getConfig&quot;, method = RequestMethod.GET) public String getConfig(HttpServletRequest request) &#123; //获取nacos的accessToken String accessToken = getAccessToken(); accessToken = String.valueOf(JSON.parseObject(accessToken, Map.class).get(&quot;accessToken&quot;)); String url = &quot;http://xxxx/nacos/v1/cs/configs?dataId=&#123;dataId&#125;&amp;group=&#123;group&#125;&amp;tenant=&#123;tenant&#125;&amp;accessToken=&#123;accessToken&#125;&amp;namespaceId=&#123;namespaceId&#125;&quot;; //注意这里url中的&#123;xx&#125;都是占位符 Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); //这里用map而不用MultiValueMap paramMap.put(&quot;dataId&quot;,&quot;xxx&quot;); paramMap.put(&quot;group&quot;,&quot;DEFAULT_GROUP&quot;); paramMap.put(&quot;tenant&quot;,&quot;xx&quot;); paramMap.put(&quot;accessToken&quot;, accessToken); paramMap.put(&quot;namespaceId&quot;,&quot;xxx&quot;); //设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(null, headers); //注意get请求时 这里填充的是null ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class, paramMap); return response.getBody(); &#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"Spring BeanPostProcessor最佳实践","slug":"FAQ-Spring BeanPostProcessor最佳实践","date":"2021-11-10T13:53:16.193Z","updated":"2022-02-01T12:44:08.848Z","comments":false,"path":"2021/11/10/FAQ-Spring BeanPostProcessor最佳实践/","link":"","permalink":"http://example.com/2021/11/10/FAQ-Spring%20BeanPostProcessor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"BeanPostProcessor接口的作用是在Spring bean 实例化完成后(执行完initializeBean)之后，初始化之前(执行bean的初始化方法)对Bean添加一些自定义的处理逻辑。也就是说执行beanProcessor方法是在bean实例化之后 此时bean的属性值都已经被赋值好了。另外需要注意的是 beanProcessor的实现类一定要被Spring托管才能生效。 一、BeanPostProcessor示例 实体类 12345678910111213141516171819202122232425262728293031323334@Component@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public class DataSourceProperty &#123; private String userName; private String password; /** * 通过@PostConstruct来标记这个init方法为bean的初始化方法 **/ @PostConstruct private void init() &#123; //这条语句会在 beanprocessor的postProcessBeforeInitialization方法执行之后执行 2 System.out.println(&quot;执行初始化方法&quot;); &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 配置 12spring.datasource.username=testspring.datasource.password=12345678 自定义的BeanPostProcessor实现类 1234567891011121314151617181920212223242526272829303132333435363738//这个类一定要被spring容器托管(也就是要能够被spring识别为一个bean) postProcessBeforeInitialization 和 //postProcessAfterInitialization才会生效@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; /** * bean实例化前处理 * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof DataSourceProperty) &#123; //这条语句是最先打印的 1 DataSourceProperty 此时它的两个属性是已经被赋值了的 System.out.println(&quot;dataSourceProperty 初始化前执行 dataSourceProperty&quot; ); &#125; return bean; &#125; /** * bean实例化后处理 * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof DataSourceProperty) &#123; //这条语句是最后打印的 System.out.println(&quot;dataSourceProperty 初始后执行&quot; ); &#125; return bean; &#125;&#125; 结果 二、为什么BeanPostProcessor必须被Spring托管才能生效 关于这一点可以查看源码 第一步 当Spring容器启动时 会先执行AbstractApplicationContext类的refresh方法 通过该方法去初始化我们的Spring容器 源码如下 1234567891011121314151617181920212223public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123; @Override public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //省略前面若干方法 prepareBeanFactory(beanFactory); try &#123; //此处省略若干方法 // 向Spring容器注册beanProstProcessor registerBeanPostProcessors(beanFactory); beanPostProcess.end(); //此处省略若干方法 完成Spring容器刷新工作 finishRefresh(); &#125;catch (BeansException ex) &#123; //此处省略 &#125;finally &#123; //此处生路 &#125; &#125; &#125;&#125; 第二步 从第一步 我们知道了当Spring容器在执行refresh方法的时候 会向容器中注册beanProcessor 下面接着看registerBeanPostProcessors(beanFactory)方法的逻辑 该方法的真正实现是在PostProcessorRegistrationDelegate类中 12345678final class PostProcessorRegistrationDelegate &#123; public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; //核心方法 从beanFactory中获取容器中所有实现了BeanPostProcessor接口的bean的名称 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); //此后省略若干方法 &#125;&#125; 第三步 beanFactory.getBeanNamesForType() 这个方法真正的实现是在DefaultListableBeanFactory中 12345678910111213public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123; @Override public String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit) &#123; if (!isConfigurationFrozen() || type == null || !allowEagerInit) &#123; //真正获取beanPostProcessor的名称的方法 return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit); &#125; //此处省略若干方法 return resolvedBeanNames; &#125;&#125; 第四步 123456789101112131415161718192021public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123; private String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); // 它会遍历Spring容器的beanDefinitionNames for (String beanName : this.beanDefinitionNames) &#123; //此处省略若干方法 //如果类型是指定的类型 则将这个bean的名称加入到list中 //对于BeanPostProcessor来说 此时type就是BeanPostProcessor boolean matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit); //此处省略若干方法 if (matchFound) &#123; result.add(beanName); &#125; //此处省略若干方法 &#125; return StringUtils.toStringArray(result); &#125;&#125; 可以发现它最终还是需要通过遍历Spring容器中所有的beanName才能够将这个bean注册为BeanProcessor 如果这个BeanPostProcessor的实现类都没有被Spring托管 也就不可能被注册为beanProcessor 这也就是为什么beanProcessor的实现类 必须被spring托管才能生效。 三、BeanPostProcessor执行的流程 12345678910111213141516//第一步 容器刷新1、AbstractApplicationContext.refresh()//第二步 完成beanFactory初始化2、AbstractApplicationContext.finishBeanFactoryInitialization(beanFactory); //第三步 默认的beanFactory开始预实例化单例bean3、DefaultListableBeanFactory.preInstantiateSingletons();//第四步 开始根据bean的名称获取bean4、AbstractBeanFactory.getBean(String name);//第五步 执行doCreateBean方法 开始创建bean5、AbstractAutowireCapableBeanFactory.doCreateBean()//第六步 对bean进行初始化AbstractAutowireCapableBeanFactory.initializeBean() //第七步 开始遍历beanProcessor 执行beanProcessor的postProcessBeforeInitialization方法AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization();//第八步 执行beanPostProcessor的后置方法AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(); initializeBean源码 12345678910111213141516171819202122232425protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; //此处省略若干方法 Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //执行beanPostProcessor的前置方法 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //执行bean的初始化方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; //执行beanPostProcessor的后置方法 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; applyBeanPostProcessorsBeforeInitialization源码 123456789101112131415@Override public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; //遍历beanPostProcessor 执行前置方法 for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result; &#125; applyBeanPostProcessorsAfterInitialization源码 1234567891011121314@Override public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessAfterInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result; &#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"ConfigurationProperties注解配置复杂类型","slug":"FAQ @ConfigurationProperties如何配置复杂类型","date":"2021-11-06T13:50:51.478Z","updated":"2022-02-01T12:29:26.199Z","comments":false,"path":"2021/11/06/FAQ @ConfigurationProperties如何配置复杂类型/","link":"","permalink":"http://example.com/2021/11/06/FAQ%20@ConfigurationProperties%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"@ConfigurationProperties 注解可以以前缀的形式统一注入某个前缀的参数 如下面的示例 示例 12345678910#数据源spring.datasource.druid.write.url=jdbc:mysql://localhost:3306/jpaspring.datasource.druid.write.username=rootspring.datasource.druid.write.password=1spring.datasource.druid.write.driver-class-name=com.mysql.jdbc.Driverspring.datasource.druid.read.url=jdbc:mysql://localhost:3306/jpaspring.datasource.druid.read.username=rootspring.datasource.druid.read.password=1spring.datasource.druid.read.driver-class-name=com.mysql.jdbc.Driver 123456789101112131415161718192021222324@Configurationpublic class DruidDataSourceConfig &#123; /** * DataSource 配置 * @return */ @ConfigurationProperties(prefix = &quot;spring.datasource.druid.read&quot;) @Bean(name = &quot;readDruidDataSource&quot;) public DataSource readDruidDataSource() &#123; return new DruidDataSource(); &#125; /** * DataSource 配置 * @return */ @ConfigurationProperties(prefix = &quot;spring.datasource.druid.write&quot;) @Bean(name = &quot;writeDruidDataSource&quot;) @Primary public DataSource writeDruidDataSource() &#123; return new DruidDataSource(); &#125;&#125; 可以看到示例中的配置其实是有两个前缀 spring.datasource.druid.read、spring.datasource.druid.write 如果需要用一个配置类去接收应该怎么去做？可以参考下面的示例 解决方案 下面的配置实现了将read和write两个不同前缀的配置放在了一个配置类中进行注入 核心思想就是利用了内部类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * @ConfigurationProperties 注解必须配合@Component、@Bean、@Configuration注解一起使用 * 也就是说@ConfigurationProperties注解的类 必须被spring托管 * @date 2021/11/06 **/@Component@ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;)public class DataSourceProperties &#123; //write内部类 用于配置前缀为spring.datasource.druid.write的配置 private Write write = new Write(); //read内部类 用于配置前缀为spring.datasource.druid.read的配置 private Read read = new Read(); public Write getWrite() &#123; return write; &#125; public void setWrite(Write write) &#123; this.write = write; &#125; public Read getRead() &#123; return read; &#125; public void setRead(Read read) &#123; this.read = read; &#125; public class Write &#123; private String url; private String username; private String password; private String driverClassName; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; &#125; public class Read &#123; private String url; private String username; private String password; private String driverClassName; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; &#125;&#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"log4j不打印异常栈","slug":"FAQ-log4j不打印异常栈","date":"2021-11-05T07:17:45.378Z","updated":"2022-02-01T12:11:19.005Z","comments":false,"path":"2021/11/05/FAQ-log4j不打印异常栈/","link":"","permalink":"http://example.com/2021/11/05/FAQ-log4j%E4%B8%8D%E6%89%93%E5%8D%B0%E5%BC%82%E5%B8%B8%E6%A0%88/","excerpt":"","text":"​最近在线上系统的错误日志中发现了一个现象 : 代码里用log4j打印系统运行时异常堆栈信息，在错误日志中无法看到堆栈信息，只有异常信息。后来发现这个是jdk的一个优化。JVM 为了性能会做优化，如果频繁的抛出某个异常，会重新编译，不再打印异常堆栈。解决这个问题也比较简单，如果不想每次都去查前面的 log 去看堆栈，只要在启动参数加上 -XX:-OmitStackTraceInFastThrow，就可以禁用该优化，强制打印异常堆栈。这样可能会导致，log 文件过大，不过产线上今天之前的 log 文件都会被压缩，所以感觉问题也不大。","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]}