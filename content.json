{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-01-31T08:54:22.000Z","updated":"2022-01-31T09:33:06.311Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"SpringBoot","date":"2022-03-10T15:14:19.000Z","updated":"2022-03-10T15:14:19.482Z","comments":true,"path":"SpringBoot/index.html","permalink":"http://example.com/SpringBoot/index.html","excerpt":"","text":""},{"title":"FAQ","date":"2022-02-01T12:07:35.000Z","updated":"2022-02-01T12:07:35.327Z","comments":true,"path":"FAQ/index.html","permalink":"http://example.com/FAQ/index.html","excerpt":"","text":""},{"title":"设计模式","date":"2022-02-01T01:21:39.000Z","updated":"2022-02-01T01:21:39.064Z","comments":true,"path":"设计模式/index.html","permalink":"http://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html","excerpt":"","text":""},{"title":"高并发","date":"2022-03-24T15:47:06.000Z","updated":"2022-03-24T15:47:06.196Z","comments":true,"path":"高并发/index.html","permalink":"http://example.com/%E9%AB%98%E5%B9%B6%E5%8F%91/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-31T10:37:45.000Z","updated":"2022-01-31T10:37:45.195Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"观察者模式","slug":"设计模式-观察者模式","date":"2022-03-26T04:35:38.687Z","updated":"2022-03-26T08:05:24.645Z","comments":false,"path":"2022/03/26/设计模式-观察者模式/","link":"","permalink":"http://example.com/2022/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式 又叫发布/订阅模式 或者也叫 源/监听器模式 一个源对象(被观察者)可以被多个监听器(观察者)监听 下面的示例是模拟微信公众号发文 而各个关注者可以收到消息的案例 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//公众号 也就是被观察者public class OfficialAccount &#123; private String name; private List&lt;OASubscription&gt; oaSubscriptions = new ArrayList&lt;&gt;(); public OfficialAccount(String name) &#123; this.name = name; &#125; public void registry(OASubscription OASubscription) &#123; oaSubscriptions.add(OASubscription); System.out.println(&quot;用户&quot;+ OASubscription.getName() + &quot;关注了公众号&quot;); &#125; public void publish(String text)&#123; System.out.println(&quot;公众号发送文章《&quot;+text+&quot;》&quot;); //订阅者订阅消息 oaSubscriptions.forEach(subscription -&gt; &#123; subscription.subscription(new Event.EventBuilder&lt;OfficialAccount&gt;().addSource(this).addMsg(text).build()); &#125;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;//消息订阅的接口(也就是所谓的抽象的监听器接口)public interface Subscription&lt;T&gt; &#123; void subscription(Event&lt;T&gt; event);&#125;//公众号消息订阅对象 也就是具体的监听器接口public class OASubscription implements Subscription&lt;OfficialAccount&gt; &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public void subscription(Event&lt;OfficialAccount&gt; event) &#123; OfficialAccount account = event.getSource(); //获取公众号 System.out.println(&quot;订阅者 : &quot; + name + &quot;收到公众号-&quot;+account.getName() + &quot;发来的文章《&quot; + event.getMsg()+&quot;》&quot;); &#125;&#125;//消息类 也就是事件类public class Event&lt;T&gt; &#123; //消息来源(被观察者) private T source; //消息内容 private String msg; public static class EventBuilder&lt;T&gt; &#123; private final Event&lt;T&gt; event = new Event&lt;&gt;(); public Event&lt;T&gt; build() &#123; return event; &#125; public EventBuilder&lt;T&gt; addSource(T source) &#123; event.source = source; return this; &#125; public EventBuilder&lt;T&gt; addMsg(String msg) &#123; event.msg = msg; return this; &#125; &#125; public T getSource() &#123; return source; &#125; public String getMsg() &#123; return msg; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) throws Exception &#123; //创建一个名为java技术栈的公众号 (被观察者也称之为源) OfficialAccount account = new OfficialAccount(&quot;java技术栈&quot;); //创建三个学生 OASubscription user1 = new OASubscription(); user1.setName(&quot;张三&quot;); OASubscription user2 = new OASubscription(); user2.setName(&quot;李四&quot;); OASubscription user3 = new OASubscription(); user3.setName(&quot;王五&quot;); //模拟学生关注公众号 account.registry(user1); account.registry(user2); account.registry(user3); //模拟公众号发布文章 account.publish(&quot;java入门示例-HelloWord&quot;); &#125;&#125; 结果 1234567用户张三关注了公众号用户李四关注了公众号用户王五关注了公众号公众号发送文章《java入门示例-HelloWord》订阅者 : 张三收到公众号-java技术栈发来的文章《java入门示例-HelloWord》订阅者 : 李四收到公众号-java技术栈发来的文章《java入门示例-HelloWord》订阅者 : 王五收到公众号-java技术栈发来的文章《java入门示例-HelloWord》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","slug":"设计模式-责任链模式","date":"2022-03-25T13:01:32.035Z","updated":"2022-03-26T03:20:00.730Z","comments":false,"path":"2022/03/25/设计模式-责任链模式/","link":"","permalink":"http://example.com/2022/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最基本的责任链模式其实很简单 用一个对象存(Chain)储所有的执行节点 并定义好顺序 然后在Chain中循环执行每一个节点的逻辑即可 这里不做演示 下面是利用责任链模式实现的一个类似SpringMVC中FilterChain的一个操作 它会接收用户的请求 并处理服务器的响应 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//模拟用户请求对象public class Request &#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125;//模拟服务端响应对象public class Response &#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125;//定义好Filter接口用于过滤请求和响应public interface Filter &#123; void doFilter(Request request, Response response, FilterChain filterChain);&#125;//过滤器联调(责任链)public class FilterChain&#123; private int index = 0; private final List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); public void doFilter(Request request, Response response) &#123; if (index == filters.size()) return; Filter filter = filters.get(index); index++; filter.doFilter(request, response, this); &#125; public FilterChain addFilter(Filter filter) &#123; filters.add(filter); return this; &#125;&#125;//第一个过滤器public class FilterOne implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain filterChain) &#123; System.out.println(&quot;requst 经过第一个过滤器 msg = &quot; + request.getMsg()); filterChain.doFilter(request, response); System.out.println(&quot;response 经过第一个过滤器 msg = &quot; + response.getMsg()); &#125;&#125;//第二个过滤器public class FilterTwo implements Filter&#123; @Override public void doFilter(Request request, Response response, FilterChain filterChain) &#123; System.out.println(&quot;requst 经过第二个过滤器 msg = &quot; + request.getMsg()); filterChain.doFilter(request, response); System.out.println(&quot;response 经过第二个过滤器 msg = &quot; + response.getMsg()); &#125;&#125;//第三个过滤器public class FilterThree implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain filterChain) &#123; System.out.println(&quot;requst 经过第三个过滤器 msg = &quot; + request.getMsg()); filterChain.doFilter(request, response); System.out.println(&quot;response 经过第三个过滤器 msg = &quot; + response.getMsg()); &#125;&#125;//测试类 模拟用户请求public class Client &#123; public static void main(String[] args) throws Exception &#123; Request request = new Request(); request.setMsg(&quot;我是请求入参&quot;); Response response = new Response(); response.setMsg(&quot;我是响应出参&quot;); FilterChain filterChain = new FilterChain(); filterChain.addFilter(new FilterOne()).addFilter(new FilterTwo()).addFilter(new FilterThree()); filterChain.doFilter(request, response); &#125;&#125; 结果 过滤器的执行结果顺序如下 123456requst 经过第一个过滤器 msg = 我是请求入参requst 经过第二个过滤器 msg = 我是请求入参requst 经过第三个过滤器 msg = 我是请求入参response 经过第三个过滤器 msg = 我是响应出参response 经过第二个过滤器 msg = 我是响应出参response 经过第一个过滤器 msg = 我是响应出参","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"调停者模式","slug":"设计模式-调停者模式","date":"2022-03-22T13:48:45.941Z","updated":"2022-03-26T03:19:54.761Z","comments":false,"path":"2022/03/22/设计模式-调停者模式/","link":"","permalink":"http://example.com/2022/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B0%83%E5%81%9C%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"调停者模式又叫调解者模式或者中介者模式，用一个中介对象封装一系列的对象的交互 中介者模式是用来降低多个对象和类之间的通信复杂性的 通过提供一个中介者类将系统中的多对多关系变成一对多的关系 中介者模式主要包含4个角色 抽象中介者(Mediator) 它是中介者的接口 提供了同事对象注册与转发同事对象信息的抽象方法 具体中介者(ConcreteMediator) 实现中介者接口 定义一个List来管理同事对象 协调各个同事角色之间的交互关系 抽象同事者类(Colleague) 定义同事类的接口 保存中介者对象 提供同事对象交互的抽象方法 实现所有同事类相互影响的公共功能 具体同事类(ConcreteColleague) 是抽象同事类的实现者 当需要与其他同事类交互时 由中介者对象负责后续的交互 调停者模式与门面模式的区别 门面模式是将内部操作封装起来提供给外部进行调用 而中介者模式更侧重于当内部系统相互之间调用比较复杂时由中介对象与统筹和管理 它们一个是对外 一个是对内 下图左侧的图是使用中介者模式之前的内部系统间的调用关系 右侧是使用中介者之后的内部系统间的调用关系 中介者模式的典型应用就是消息中间件 示例 租房的时候 房主将房屋托管给房屋中介 而租房者从房屋中介获取房屋信息 房屋中介充当租房者和房屋所有者之间的中介 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//抽象的中介者public abstract class Mediator &#123; //和某人联系的方法 public abstract void contact(String message, Person person);&#125;//抽象的同事类public abstract class Person &#123; protected String name; protected Mediator mediator; public Person(String name, Mediator mediator) &#123; this.name = name; this.mediator = mediator; &#125; public abstract void contact(String message);&#125;//具体同事类 房东public class HouseOwner extends Person &#123; public HouseOwner(String name, Mediator mediator) &#123; super(name, mediator); &#125; //和中介联系 public void contact(String message) &#123; mediator.contact(message, this); &#125; //获取信息 public void getMessage(String name, String message) &#123; System.out.println(&quot;房主获取到的信息是: &quot; + name + &quot;说&quot; + message); &#125;&#125;//具体同事类 租客public class Tenant extends Person &#123; public Tenant(String name, Mediator mediator) &#123; super(name, mediator); &#125; //和中介联系 public void contact(String message) &#123; mediator.contact(message, this); &#125; //获取信息 public void getMessage(String name, String message) &#123; System.out.println(&quot;租房者获取到的信息是&quot; + name + &quot;说&quot; + message); &#125;&#125;//具体中介类 房产中介 具体中介者一定要聚合各个具体的同事类对象 这样才能相互交流public class MediatorStructure extends Mediator &#123; //租客 private Tenant tenant; //房东 private HouseOwner houseOwner; @Override public void contact(String message, Person person) &#123; if (tenant == person) &#123; //租客 通过中介获取房东的租房信息 houseOwner.getMessage(person.name, message); &#125; if (houseOwner == person) &#123; //房东通过中介获取租客的信息 tenant.getMessage(person.name, message); &#125; &#125; public Tenant getTenant() &#123; return tenant; &#125; public void setTenant(Tenant tenant) &#123; this.tenant = tenant; &#125; public HouseOwner getHouseOwner() &#123; return houseOwner; &#125; public void setHouseOwner(HouseOwner houseOwner) &#123; this.houseOwner = houseOwner; &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //创建房屋中介 MediatorStructure mediator = new MediatorStructure(); //创建租房者 Tenant tenant = new Tenant(&quot;李四&quot;, mediator); //创建房东 HouseOwner houseOwner = new HouseOwner(&quot;张三&quot;, mediator); //中介者关联房东和租客 mediator.setTenant(tenant); mediator.setHouseOwner(houseOwner); //租客和房产中介联系 表明要租房 tenant.contact(&quot;我要租一个三室两厅的房子&quot;); //房东和房产中介连写 表示要出租 houseOwner.contact(&quot;我这里有三室两厅的房子你要租吗&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"线程基础知识","slug":"高并发-线程基础知识","date":"2022-03-21T15:06:15.808Z","updated":"2022-03-24T15:46:02.361Z","comments":false,"path":"2022/03/21/高并发-线程基础知识/","link":"","permalink":"http://example.com/2022/03/21/%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"一 基本概念 程序 程序简单来说就是一个可执行文件 进程 系统进行资源分配的基本单位 线程 计算机执行的基本单位 基础面试题 123451、单核CPU设置多线程是否有意义 其实是有意义的 因为并不是所有的操作都是需要消耗CPU 有些时候线程执行到某个步骤后需要等待其他线程或者网络资源的响应 这个时候让掉CPU是可以提高整个进程的执行效率的2、线程数设置多少比较合适线程计算公式 Nthread = Ncpu * Ucpu(1+W/C) Ncpu是处理器的核的数目 Ucpu是期望的cpu的使用率 W/C是等待时间与计算时间的比率 在实际开发中一般是先预设线程数是2倍的cpu核心数 - 1 然后通过压测去调整 二 创建线程的5种方法 继承Thread 重写Run方法 1234567public class MyThread extends Thread &#123; @Override public void run() &#123; //实现自己的业务逻辑 super.run(); &#125;&#125; 实现Runnable接口 重写run方法 123456public class MyThread implements Runnable &#123; @Override public void run() &#123; //实现自己的业务逻辑 &#125;&#125; 利用线程池ThreadPoolExecutor/ExecutorService 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; ThreadPoolExecutor pool = new ThreadPoolExecutor( 4, 8, 1, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(100), new ThreadPoolExecutor.CallerRunsPolicy()); pool.execute(new Runnable() &#123; @Override public void run() &#123; //执行业务逻辑 &#125; &#125;); &#125;&#125; 利用Callable接口创建带返回值的线程 123456789101112131415161718//callable接口必须接口Futrue类和线程池一起使用public class Client &#123; public static void main(String[] args) throws Exception&#123; ThreadPoolExecutor pool = new ThreadPoolExecutor( 4, 8, 1, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(100), new ThreadPoolExecutor.CallerRunsPolicy()); Future&lt;String&gt; future = pool.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; //执行业务逻辑 return null; &#125; &#125;); String result = future.get(); &#125;&#125; 利用FutureTask创建带返回值的线程 123456789101112public class Client &#123; public static void main(String[] args) throws Exception&#123; FutureTask&lt;String&gt; future = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return null; &#125; &#125;); new Thread(future).start(); String result = future.get(); &#125;&#125; 三 线程的状态线程有6种状态 NEW 线程刚刚创建(Thread对象刚刚创建好 还没有调用start方法) RUNNABLE 可运行状态 此时需要线程调度器来安排执行 有两个子状态 READ(就绪) 和 RUNNING(运行) WAITING 线程等待被唤醒 TIMED_WAITING 隔一段时间后自动唤醒 最典型的就是sleep BLOCKED 被阻塞 正在等待锁 (抢锁没抢到) TERMINATED 线程结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Client &#123; public static void main(String[] args) throws Exception&#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(&quot;2:&quot; + Thread.currentThread().getState()); //RUNNABLE System.out.println(&quot;go on !&quot;); LockSupport.park(); // 阻塞线程 当调用unpark的时候会释放锁 Thread.sleep(3000); synchronized (Client.class) &#123; System.out.println(&quot;执行同步代码块&quot;); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (Client.class) &#123; try &#123; Thread.sleep(20000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); t2.start(); System.out.println(&quot;1:&quot;+t1.getState()); //NEW t1.start(); Thread.sleep(1000); System.out.println(&quot;3:&quot;+ t1.getState()); //WAITING LockSupport.unpark(t1); //释放锁 Thread.sleep(1000); System.out.println(&quot;4:&quot;+ t1.getState()); //TIMED_WAITING Thread.sleep(5000); System.out.println(&quot;5:&quot;+ t1.getState()); //BLOCKED t1.join(); System.out.println(&quot;6:&quot;+t1.getState()); //TERMINATED &#125;&#125; Lock与Synchronized对于线程状态的区别 lock 会触发线程进入WATING状态 而只有Synchronized(经过了操作系统的调度)关键字才会触发线程进入BLOCKED状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Client &#123; public static void main(String[] args) throws Exception&#123; Lock lock = new ReentrantLock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(&quot;2:&quot; + Thread.currentThread().getState()); //RUNNABLE System.out.println(&quot;go on !&quot;); LockSupport.park(); // 阻塞线程 当调用unpark的时候会释放锁 Thread.sleep(3000); lock.lock(); System.out.println(&quot;执行同步代码块&quot;); lock.unlock(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; lock.lock(); try &#123; Thread.sleep(20000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; lock.unlock(); &#125; &#125;); t2.start(); System.out.println(&quot;1:&quot;+t1.getState()); //NEW t1.start(); Thread.sleep(1000); System.out.println(&quot;3:&quot;+ t1.getState()); //WAITING LockSupport.unpark(t1); //释放锁 Thread.sleep(1000); System.out.println(&quot;4:&quot;+ t1.getState()); //TIMED_WAITING Thread.sleep(5000); System.out.println(&quot;5:&quot;+ t1.getState()); //与上面的例子不一样 这里线程的状态是WAITING状态 t1.join(); System.out.println(&quot;6:&quot;+t1.getState()); //TERMINATED &#125;&#125; 四 线程打断interrupt线程打断的三个方法 1231、interrupt(); //打断某个线程 设置标志位 至于设置了打断标志位后线程该如何处理 是由线程本身控制的(自己写代码去控制)2、isInterrupted(); //查询某个线程是否被打断过 查询标志位3、static interrupted(); //查询当前线程是否被打断过 并重置打断标志 123456789101112131415161718192021222324252627282930313233343536373839public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; while (true) &#123; //如果线程被打断了 if (Thread.currentThread().isInterrupted()) &#123; System.out.println(&quot;Thread is interrupted!&quot;); System.out.println(Thread.currentThread().isInterrupted()); //只是查询是否设置过标志位 true break; &#125; &#125; &#125;); t1.start(); Thread.sleep(1000); t1.interrupt(); //设置线程中断标志位 t1.join(); &#125;&#125;public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; while (true) &#123; //如果线程被打断了 if (Thread.interrupted()) &#123; System.out.println(&quot;Thread is interrupted!&quot;); System.out.println(Thread.interrupted()); //查询并且重置标志位了 所以这里是false break; &#125; &#125; &#125;); t1.start(); Thread.sleep(1000); t1.interrupt(); //设置线程中断标志位 t1.join(); &#125;&#125; 当执行线程的sleep、wait、join等方法的时候 如果这个线程被中断了(interrupt方法) 线程是会抛出InterruptedException的 具体如何处理InterruptedException这个实际上还是交给线程自己来处理 你可以选择忽略 也可以选择终止线程 12345678910111213141516171819public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(() -&gt; &#123; while (true) &#123; try &#123; Thread.sleep(10000); &#125;catch (InterruptedException e) &#123; //一旦抛出了这个异常 jvm会自动的将这个线程的中断状态给复位 所以此时调用Thread.currentThread().isInterrupted() 返回的是false System.out.println(&quot;抛出InterruptedException&quot;); System.out.println(Thread.currentThread().isInterrupted()); &#125; &#125; &#125;); t1.start(); Thread.sleep(1000); t1.interrupt(); //设置线程中断标志位 t1.join(); &#125;&#125; 利用lockInterruptibly()方法来中断正在获取锁的线程 一般情况下 如果一个线程正在获取锁 它是没有办法被打断的 但是如果采用的是lock的可重入锁 则可以利用lock.lockInterruptibly()方法来中断正在抢锁的线程 (需要抢锁的线程先执行interrupt()方法设置标志位) 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Client &#123; public static void main(String[] args) throws Exception &#123; Lock lock = new ReentrantLock(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;t1 start&quot;); lock.lock(); try &#123; System.out.println(&quot;t1 running&quot;); Thread.sleep(10000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;t1 end&quot;); lock.unlock(); &#125; &#125; &#125;); t1.start(); Thread.sleep(1000); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;t2 start&quot;); try &#123; //这个方法可以中断获取锁的线程 lock.lockInterruptibly(); System.out.println(&quot;t2 running&quot;); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; System.out.println(&quot;t2 end&quot;); &#125; &#125;); t2.start(); Thread.sleep(1000); t2.interrupt(); System.out.println(&quot;t2 interrupt&quot;); &#125;&#125; 五 如何优雅的结束一个线程 利用线程自带的stop方法结束线程 这种方式比较粗暴 已经被废弃了 这是因为stop方法在结束线程前 会释放所有的锁 并且不做善后工作 这样就容易出现因为释放锁而导致数据不一致的问题 123456789101112131415161718192021public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(&quot;running&quot;); Thread.sleep(1000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); t1.start(); Thread.sleep(5000); t1.stop(); &#125;&#125; suspend和resume方法 这两个方法一个是暂停线程(suspend)一个是恢复线程(resume) 但是这两个方法容易引起死锁的问题 因为suspend方法不会释放锁 另外suspend/resume 只能是暂停一个线程 并不能结束一个线程 1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(&quot;running&quot;); Thread.sleep(1000); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); t1.start(); Thread.sleep(5000); t1.suspend(); //暂停线程 但是不会释放锁 Thread.sleep(3000); t1.resume(); //恢复线程 &#125;&#125; 利用Volatile结束线程 这个是结束线程最常用也是一种优雅结束线程的方式 1234567891011121314151617181920212223242526272829public class Client &#123; private static volatile boolean flag = true; public static void main(String[] args) throws Exception &#123; AtomicInteger count = new AtomicInteger(0); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (flag) &#123; try &#123; count.incrementAndGet(); System.out.println(&quot;sleep前 count = &quot; + count.get()); Thread.sleep(1000); System.out.println(&quot;sleep后 count = &quot; + count.get()); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;end count = &quot; + count.get()); &#125; &#125;); t1.start(); Thread.sleep(5000); flag = false; //结束线程 Thread.sleep(3000); &#125;&#125; 利用interrupt方法来结束线程 123456789101112131415161718192021222324252627282930public class Client &#123; public static void main(String[] args) throws Exception &#123; AtomicInteger count = new AtomicInteger(0); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; while (!Thread.interrupted()) &#123; count.incrementAndGet(); Long start = System.currentTimeMillis(); //模拟业务操作的耗时 System.out.println(&quot;sleep执行前 count = &quot; + count); while (true) &#123; Long end = System.currentTimeMillis(); if (end - start &gt; 1000) &#123; break; &#125; &#125; System.out.println(&quot;sleep执行后 count = &quot; + count); &#125; System.out.println(&quot;end2 count = &quot; + count.get()); &#125; &#125;); t1.start(); Thread.sleep(5000); t1.interrupt(); Thread.sleep(3000); &#125;&#125; ​ volatile和interrupt都不能精确的控制线程的结束 它们都必须等到线程执行到读取interrupted方法或者vaolatile变量的时候 线程才能结束如果需要更精确的控制线程的结束则需要用到锁","categories":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"模板方法模式","slug":"设计模式-模板方法","date":"2022-03-21T14:25:16.627Z","updated":"2022-03-26T03:21:29.947Z","comments":false,"path":"2022/03/21/设计模式-模板方法/","link":"","permalink":"http://example.com/2022/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/","excerpt":"","text":"模板方法模式是指定义一个操作中的算法框架 而将一些步骤延迟到子类去实现。模板方法模式实际上封装了一个固定的流程，该流程有几个步骤组成，具体的步骤可以有子类进行不同的实现。典型的应用案例是JdbcTemplate 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//抽象的模板类public abstract class AbstractCourse &#123; public final void createCourse() &#123; //发布预习资料 postPreResource(); //制作PPT课件 createPPT(); //在线直播 liveVideo(); //布置作业 postHomework(); &#125; protected abstract void postHomework(); protected abstract void liveVideo(); protected abstract void createPPT(); protected abstract void postPreResource();&#125;public class JavaCourse extends AbstractCourse &#123; @Override protected void postHomework() &#123; System.out.println(&quot;布置java家庭作业&quot;); &#125; @Override protected void liveVideo() &#123; System.out.println(&quot;java课程在线直播&quot;); &#125; @Override protected void createPPT() &#123; System.out.println(&quot;制作java课程PPT&quot;); &#125; @Override protected void postPreResource() &#123; System.out.println(&quot;发布java课程预习资料&quot;); &#125;&#125;public class PythonCourse extends AbstractCourse &#123; @Override protected void postHomework() &#123; System.out.println(&quot;布置python家庭作业&quot;); &#125; @Override protected void liveVideo() &#123; System.out.println(&quot;python课程在线直播&quot;); &#125; @Override protected void createPPT() &#123; System.out.println(&quot;制作python课程PPT&quot;); &#125; @Override protected void postPreResource() &#123; System.out.println(&quot;发布python课程预习资料&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; PythonCourse c1 = new PythonCourse(); c1.createCourse(); JavaCourse c2 = new JavaCourse(); c2.createCourse(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"poi-tl生成Word文档","slug":"FAQ-poi-tl生成Word文档","date":"2022-03-19T12:51:53.618Z","updated":"2022-03-19T16:35:47.965Z","comments":false,"path":"2022/03/19/FAQ-poi-tl生成Word文档/","link":"","permalink":"http://example.com/2022/03/19/FAQ-poi-tl%E7%94%9F%E6%88%90Word%E6%96%87%E6%A1%A3/","excerpt":"","text":"poi-tl 是word模板引擎 可以根据word模板和数据生成word文档 利用poi-tl可以生成很多样式丰富的word poi-tl官方文档 一 poi-tl依赖12345&lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.11.1&lt;/version&gt;&lt;/dependency&gt; 使用poi-tl的时候因为有word模板文件 maven默认是不会打包的 所以需要设置一下maven的资源目录的配置 以便能够将doc文件打包到classpath下 12345678910111213141516171819&lt;!-- 资源目录 --&gt;&lt;resources&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.docx&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.docx&lt;/exclude&gt; &lt;/excludes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 二 项目结构 完整的项目依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.poi.tl.test&lt;/groupId&gt; &lt;artifactId&gt;poi-tl-test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.11.1&lt;/version&gt; &lt;exclusions&gt; &lt;!--需要排除xalan依赖 不然会报错 Not supported: http://javax.xml.XMLConstants/property/accessExternalDTD--&gt; &lt;exclusion&gt; &lt;artifactId&gt;xalan&lt;/artifactId&gt; &lt;groupId&gt;xalan&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.docx&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;!-- 设定主资源目录 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.docx&lt;/exclude&gt; &lt;/excludes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 三 示例 文本 在word模板文件中使用&#123;&#123;var&#125;&#125;来表示一段文本 其中文本的数据类型包括 String 普通文本 TextRenderData 有样式的文本 HyperlinkTextRenderData 超链接和锚点文本 Object 调用 toString() 方法转化为文本 文本换行使用\\n字符 代码示例 12345678910111213141516171819202122232425262728293031323334@RequestMapping(path = &quot;/download&quot;, method = RequestMethod.GET)public void download(HttpServletRequest request, HttpServletResponse response) &#123; OutputStream out = null; XWPFTemplate template = null; BufferedOutputStream bos = null; try &#123; String title = &quot;测试.docx&quot;; title = URLEncoder.encode(title, StandardCharsets.UTF_8.toString()); response.reset(); //设置doc输出时中文不会乱码 response.setContentType(&quot;application/octet-stream; charset=UTF-8&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename*=utf-8&#x27;&#x27;&quot; + title); out = response.getOutputStream(); bos = new BufferedOutputStream(out); //template.docx是word模板文件 template = XWPFTemplate //compile 编译模板 .compile(Objects.requireNonNull(DocController.class.getClassLoader() .getResourceAsStream(&quot;template.docx&quot;))) //render 渲染数据 .render(new HashMap&lt;String, Object&gt;()&#123;&#123; put(&quot;name&quot;, &quot;张三&quot;); put(&quot;author&quot;, new TextRenderData(&quot;000000&quot;, &quot;张三&quot;)); put(&quot;link&quot;, new HyperlinkTextRenderData(&quot;poi-tl官网&quot;, &quot;http://deepoove.com&quot;)); &#125;&#125;); //write 输出到流 template.write(bos); bos.flush(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; PoitlIOUtils.closeQuietlyMulti(template, bos, out); &#125;&#125; 模板 下面是word模板文件中(template.docx)的内容 生成的word(测试.docx)的内容 图片 在word模板文件中使用&#123;&#123;&#64;var&#125;&#125;来表示图片 其中图片的数据类型包括 String 图片的url或本地路径 默认使用图片自身尺寸 PictureRenderData 推荐使用工厂 Pictures构建图片模型 代码示例 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping(path = &quot;/download&quot;, method = RequestMethod.GET) public void download(HttpServletRequest request, HttpServletResponse response) &#123; OutputStream out = null; XWPFTemplate template = null; BufferedOutputStream bos = null; try &#123; String title = &quot;测试.docx&quot;; title = URLEncoder.encode(title, StandardCharsets.UTF_8.toString()); response.reset(); //设置doc输出时中文不会乱码 response.setContentType(&quot;application/octet-stream; charset=UTF-8&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename*=utf-8&#x27;&#x27;&quot; + title); out = response.getOutputStream(); bos = new BufferedOutputStream(out); BufferedImage bufferImage = new BufferedImage(100, 100, BufferedImage.TYPE_BYTE_GRAY); template = XWPFTemplate .compile(Objects.requireNonNull(DocController.class.getClassLoader().getResourceAsStream(&quot;template.docx&quot;))) .render(new HashMap&lt;String, Object&gt;()&#123;&#123; put(&quot;image&quot;, &quot;/xx/xx/poi-tl-test/target/classes/static/logo.png&quot;); // 指定图片路径 put(&quot;image1&quot;, Pictures.ofLocal(&quot;/xx/xx/test/poi-tl-test/target/classes/static/logo.png&quot;).size(120, 120).create()); // 设置图片宽高 put(&quot;streamImg&quot;, Pictures.ofStream(new FileInputStream(&quot;/xx/xx/poi-tl-test/target/classes/static/logo.jpeg&quot;), PictureType.JPEG) // 图片流 .size(100, 120).create()); put(&quot;urlImg&quot;, Pictures.ofUrl(&quot;http://deepoove.com/images/icecream.png&quot;) // 网络图片(注意网络耗时对系统可能的性能影响) .size(100, 100).create()); put(&quot;svg&quot;, &quot;https://img.shields.io/badge/jdk-1.6%2B-orange.svg&quot;); // svg图片 put(&quot;buffered&quot;, Pictures.ofBufferedImage(bufferImage, PictureType.PNG) //java图片 .size(100, 100).create()); &#125;&#125;); template.write(bos); bos.flush(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; PoitlIOUtils.closeQuietlyMulti(template, bos, out); &#125; &#125; 模板 生成的word(测试.docx)的内容 表格 在word模板文件中使用 &#123;&#123;&#35;var&#125;&#125;来表示表格 其中表格的数据类型包括 TableRenderData 推荐使用工厂Tables、Rows 和 Cells构建表格模型 代码示例 12345// 一个2行2列的表格put(&quot;table0&quot;, Tables.of(new String[][] &#123; new String[] &#123; &quot;00&quot;, &quot;01&quot; &#125;, new String[] &#123; &quot;10&quot;, &quot;11&quot; &#125; &#125;).border(BorderStyle.DEFAULT).create()); 12345// 第0行居中且背景为蓝色的表格RowRenderData row0 = Rows.of(&quot;姓名&quot;, &quot;学历&quot;).textColor(&quot;FFFFFF&quot;) .bgColor(&quot;4472C4&quot;).center().create();RowRenderData row1 = Rows.create(&quot;李四&quot;, &quot;博士&quot;);put(&quot;table1&quot;, Tables.create(row0, row1)); 12345// 合并第1行所有单元格的表格RowRenderData row0 = Rows.of(&quot;列0&quot;, &quot;列1&quot;, &quot;列2&quot;).center().bgColor(&quot;4472C4&quot;).create();RowRenderData row1 = Rows.create(&quot;没有数据&quot;, null, null);MergeCellRule rule = MergeCellRule.builder().map(Grid.of(1, 0), Grid.of(1, 2)).build();put(&quot;table3&quot;, Tables.of(row0, row1).mergeRule(rule).create()); 其他数据类型见官方文档！","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot手写starter","slug":"SpringBoot-手写starter","date":"2022-03-19T09:47:05.233Z","updated":"2022-03-19T16:28:06.980Z","comments":false,"path":"2022/03/19/SpringBoot-手写starter/","link":"","permalink":"http://example.com/2022/03/19/SpringBoot-%E6%89%8B%E5%86%99starter/","excerpt":"","text":"SpringBoot手写starter组件案例 以集成Redisson为例 一、工程搭建这一步只是搭建一个maven项目 不做表述 下面是完整的工程示例 二、依赖maven依赖如下 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.redisson.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;!--optional为true 表明这个依赖是可选的 相当于这个依赖不会被其他项目锁继承--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.16.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--这个是用来配置springboot 配置文件属性自动提示用的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 三、创建相关的配置类 RedissonProperties 本文Redisson的使用不是重点 所以此处只是连接单机redis的一些配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.redisson.spring.boot.config;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;spring.redisson&quot;)public class RedissonProperties &#123; private String host = &quot;localhost&quot;; private int port = 6379; private int timeout = 10000; private boolean ssl; private String password; public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public int getTimeout() &#123; return timeout; &#125; public void setTimeout(int timeout) &#123; this.timeout = timeout; &#125; public boolean isSsl() &#123; return ssl; &#125; public void setSsl(boolean ssl) &#123; this.ssl = ssl; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; RedissonAutoConfiguration 这个类相当于是starter的一个入口类 123456789101112131415161718192021222324252627282930313233343536package com.redisson.spring.boot;import com.redisson.spring.boot.config.RedissonProperties;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.config.Config;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnClass(Redisson.class)//@EnableConfigurationProperties作用是使得@ConfigurationProperties 注解的类生效@EnableConfigurationProperties(RedissonProperties.class)public class RedissonAutoConfiguration &#123; @Bean RedissonClient redissonClient(RedissonProperties redissonProperties) &#123; Config config = new Config(); // 判断是否启用ssl String prefix = redissonProperties.isSsl() ? &quot;rediss://&quot; : &quot;redis://&quot;; String host = redissonProperties.getHost(); int port = redissonProperties.getPort(); int timeout = redissonProperties.getTimeout(); String password = redissonProperties.getPassword(); config.useSingleServer() .setAddress(prefix + host + &quot;:&quot; + port) .setConnectTimeout(timeout) .setPassword(password); return Redisson.create(config); &#125;&#125; 四、创建配置文件 spring.factories 这个文件是Spring SPI机制的核心文件 SpringBoot 在启动时会扫描这个文件 并将其中配置的类装配为bean 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.redisson.spring.boot.RedissonAutoConfiguration additional-spring-configuration-metadata.json 这个文件也可以不加 加了可以对自动提示的文件做一些注释的说明 123456789101112131415161718192021222324252627&#123; &quot;properties&quot;: [ &#123; &quot;name&quot;: &quot;spring.redissin.host&quot;, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;description&quot;: &quot;redis服务器地址.&quot;, &quot;defaultValue&quot;: &quot;localhost&quot; &#125;, &#123; &quot;name&quot;: &quot;spring.redisson.port&quot;, &quot;type&quot;: &quot;java.lang.Integer&quot;, &quot;description&quot;: &quot;redis服务器端口.&quot;, &quot;defaultValue&quot;: 6379 &#125;, &#123; &quot;name&quot;: &quot;spring.redisson.timeout&quot;, &quot;type&quot;: &quot;java.lang.Integer&quot;, &quot;description&quot;: &quot;redis连接超时时间&quot;, &quot;defaultValue&quot;: 1000 &#125;, &#123; &quot;name&quot;: &quot;spring.redisson.ssl&quot;, &quot;type&quot;: &quot;java.lang.Boolean&quot;, &quot;description&quot;: &quot;redis 连接是否是佛那个ssl&quot; &#125; ]&#125; 以上两个配置文件都要在starter的META-INF文件夹下新建","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"类加载机制与getResource()路径分析","slug":"FAQ-类加载机制与getResource()路径分析","date":"2022-03-16T15:35:21.329Z","updated":"2022-03-19T16:23:55.768Z","comments":false,"path":"2022/03/16/FAQ-类加载机制与getResource()路径分析/","link":"","permalink":"http://example.com/2022/03/16/FAQ-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8EgetResource()%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/","excerpt":"","text":"一 类加载过程一个类在JVM中的生命周期主要要包括以下几个阶段 分别是 装载、链接、初始化、实例化、 使用、卸载 装载阶段 这个阶段主要是将class文件加载到JVM的方法区/元空间 连接阶段 这个阶段又被细分为3个阶段 分别是 验证、准备、解析 连接阶段的主要作用是将class文件中变量的符号引用 转为直接引用 验证 确认读取文件类型的正确性，即class是否符合Java规范并且不会损害JVM的完整性。主要是检查代码是否有格式错误。 准备 为静态成员变量分配内存同时设置默认初始值。静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。(仅包含类变量,不包含实例变量) 解析 把符号引用转为直接引用的过程。例如将变量名转为内存地址。以后使用这个成员变量时，就直接去这个内存地址去找了。同时类的成员方法也会被映射到某个内存地址以待调用。 初始化阶段 类的初始化阶段会为静态成员变量赋予正确的初始值，并且调用类中所有的静态代码块。—调用静态成员变量的初始化代码。例如类中定义了一个静态成员变量static int a = 1; 之前准备阶段已经为变量a分配了内存空间，并且将a的值设为了0，此时才会将a的值设为1。—调用类中所有的静态代码块。static{……} 事实上，编译阶段Java编译器会把类中所有的静态变量初始化代码和静态代码块封装到一个方法中去，此时JVM会调用这个方法。方法程序员不能调用，只能被JVM调用。方法只在初始化阶段执行且只被执行一次。因此静态变量只被初始化一次，静态方法只被执行一次。 实例化阶段 在类的初始化完成之后，这个类就随时可以使用了。但是此时只能使用该类的静态成员(变量和方法)。当创建一个类的对象时(例：使用new关键字)，此时进行的是类的实例化操作。 在堆中为实例变量分配内存空间。 调用类中所有的实例代码块。{……} 调用相应的构造方法。 事实上，编译阶段Java编译器会把类中所有的实例变量初始化代码和实例代码块封装到一个方法中去，此时JVM会调用这个方法。方法程序员不能调用，只能被JVM调用。方法在每次实例化时都会被执行。实例代码块按源文件顺序执行，最后才执行构造方法 并不是所有时候这七个阶段都是顺序进行的，其中加载、验证、准备、初始化、卸载是固定顺序开始的，解析阶段不一定。解析在某些情况下可以在初始化阶段之后再开始，这也是为了支持运行时绑定（也成为动态绑定） 概念剖析 符号引用 其实就是我们在写代码的过程中声明的那些变量 直接引用 直接引用是将这些符号引用 变成了一个个的真实的内存地址 主动使用 JAVA中对类的使用有两种方式 分别是主动使用和被动使用 第一次主动使用才进行初始化,之后就不再初始化 主动使用包含7种情况 创建类的实例 new 操作符 访问某个类或接口的静态变量 或者对静态变量进行赋值 静态常量是不会触发类的初始化的 调用类的静态方法 反射 Class.forName(“com.xxx.xxx”) 初始化一个类的子类 父类会初始化 Java虚拟机启动时被标明为启动类的类 包含main方法的类 JDK7开始提供的动态语言支持,java.lang.invoke.MethodHandle 被动使用 除了主动使用的7种情况,其他使用Java类的方式都被看作是对类的被动使用,都不会导致类的初始化,但是依然会对类进行装载和连接 类的主动使用和被动使用案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Test2 &#123; static &#123; System.out.println(&quot;this is Test2&quot;); &#125; public static void main(String[] args) throws Throwable &#123; //类的主动使用案例 //第一种 使用new 操作符 触发类的初始化 //People people = new People(); //第二种 访问类的静态变量 触发初始化 如果访问的是静态常量是不会触发初始化的 //String attr = People.attr; //第二种的变种 为类的静态变量赋值 触发类的初始化 //People.attr2 = &quot;This is People attr2&quot;; //第三种 子类初始化 触发父类初始化 //Man man = new Man(); //第四种 调用类的静态方法 触发初始化 //People.sayHello(); //第五种 反射触发类的初始化 //Class&lt;?&gt; people = Class.forName(&quot;com.springboot.test.test1.People&quot;); //第六种 执行一个类的main方法 触发类的初始化 //前面5种示例都会先输出一句话 this is Test2 证明Test2类是最先被初始化的 //类的被动使用案例 //第一种 这种不会触发类的初始化 是类的被动使用 People[] people = new People[2]; //第二种 //System.out.println(People.attr3); &#125;&#125;class People &#123; static &#123; System.out.println(&quot;This is People&quot;); &#125; public static String attr = &quot;This is People attr&quot;; public static String attr2; public final static String attr3 = &quot;This is People attr3&quot;; public static void sayHello() &#123; System.out.println(&quot;Hello&quot;); &#125; public String sayHello2(String name) &#123; return &quot;Hello2&quot; + name; &#125;&#125;class Man extends People &#123; static &#123; System.out.println(&quot;This is Man&quot;); &#125;&#125; 二 getResource() 的几种路径在Java中获取资源的时候，经常用到getResource和getResourceAsStream，下面总结一下这两种资源获取源文件的路径差异 Class.getResource(String path) path 不以/开头时 就是以该class文件所在包作为资源的根路径 path 以/开头的时候 就是从classpath根路径去获取资源 12345678public class Test&#123; public static void main(String[] args) &#123; System.out.println(Test.class.getResource(&quot;&quot;)); System.out.println(Test.class.getResource(&quot;/&quot;)); &#125;&#125; Class.getClassLoader().getResource(String path) 这种情况下path不能以/开头 通过类加载器去获取资源时 是使用的逐级向上委托的形式加载的 此时的/表示Boot ClassLoader 因为这个类加载器是C++实现的，所以加载范围为null 所以这种方式不能以/开头 12345678public class Test&#123; public static void main(String[] args) &#123; System.out.println(Test.class.getClassLoader().getResource(&quot;&quot;)); //classpath根路径 System.out.println(Test.class.getClassLoader().getResource(&quot;/&quot;)); &#125;&#125; Class.getResourceAsStream(String path) path 不以/开头时，默认是指所在类的相对路径，从这个相对路径下取资源 path 以/开头时 则是从项目的classpath根下获取资源，就是要写相对于classpath根下的绝对路径 12345678910111213com |-github |-demo | |-A.class | |-1.txt |-B.class |-2.txt#上面是模拟的文件树 相对路径：InputStream is= A.class.getResourceAsStream(&quot;1.txt&quot;)路径不是以/开头，说明这是一个相对路径，相对的是A.class这个文件，所以，这里的“1.txt”所指的正确位置是与A.class处于同一目录下的1.txt文件，这一文件是存在的，所引不会报错。如果我们按相对路径的方式通过A去加载2.txt，则路径应该这样描述：InputStream is= A.class.getResourceAsStream(&quot;../2.txt&quot;)用..表示上一级目录。 Clss.getClassLoader().getResourceAsStream(String path) path不能以/开头，默认则是从classpath根路径获取资源 如果以‘/’ 开头，则 返回的是classLoader加载器Boot ClassLoader的加载范围，所以返回的也是null，所以不能以/开头","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot自动装配核心原理(二)","slug":"SpringBoot-自动装配核心原理02","date":"2022-03-15T13:58:46.248Z","updated":"2022-03-19T16:29:00.625Z","comments":false,"path":"2022/03/15/SpringBoot-自动装配核心原理02/","link":"","permalink":"http://example.com/2022/03/15/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%8602/","excerpt":"","text":"一 SpringBoot自动装配流程分析在上一节中我们已经知道了SpringBoot框架的入口在@EnableAutoConfiguration注解中 下面是EnableAutoConfiguration注解的源码 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 通过上一讲已经知道@Import注解的作用 所以SpringBoot框架真正的核心入口在AutoConfigurationImportSelector类的selectImports方法中 12345678910111213141516171819202122232425262728293031323334@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; //getAutoConfigurationEntry方法会去查找spring.factories文件 并将文件中的类装配到容器中 AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125;protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; //获取EnableAutoConfiguration注解定义的属性exclude、excludeName与他们对应的值 AnnotationAttributes attributes = getAttributes(annotationMetadata); //查找类路径下(classpath)/META-INF/spring.factories文件 并将这些文件中key为 //org.springframework.boot.autoconfigure.EnableAutoConfiguration的类权限定名加载进来 只会加载 //EnableAutoConfiguration这个key下的类 其他的key不会被加载 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //删除一些重复的对象 底层是一个LinkedHashMap configurations = removeDuplicates(configurations); //得到需要排除的类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); //校验排除的这些类是否正确(类路径下是否能找到这些类) checkExcludedClasses(configurations, exclusions); //把要排除的类从configurations中删除 configurations.removeAll(exclusions); //根据META-INF/spring-autoconfigure-metadata.properties文件来排除掉 //spring.factories文件中EnableAutoConfigurationKey中需要满足特定条件装配的bean configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); &#125; 二 自动装配要点排除指定的类 12345678//通过在@SpringBootApplication注解中设置exclude属性可以排除掉指定的对象@SpringBootApplication(exclude = RedisAutoConfiguration.class)public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 自动装配中条件的解析 SpringBoot自动装配的筛选条件源码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//在getConfigurationClassFilter().filter(configurations)方法中 下面是filter方法的源码List&lt;String&gt; filter(List&lt;String&gt; configurations) &#123; long startTime = System.nanoTime(); //candidates是META/spring.factories文件配置的key为EnableAutoConfiguration的类的名称 String[] candidates = StringUtils.toStringArray(configurations); boolean skipped = false; //这里的filter一共有三个 分别是OnClassCondition OnWebApplicationCondition OnBeanCondition for (AutoConfigurationImportFilter filter : this.filters) &#123; //这里则是开始进行匹配 spring-autoconfigure-metadata.properties文件中配置的条件 match源码在下面 boolean[] match = filter.match(candidates, this.autoConfigurationMetadata); for (int i = 0; i &lt; match.length; i++) &#123; if (!match[i]) &#123; candidates[i] = null; skipped = true; &#125; &#125; &#125; //以下省略若干代码 &#125;//OnClassCondition match方法源码public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) &#123; ConditionEvaluationReport report = ConditionEvaluationReport.find(this.beanFactory); //这里是以spring.factories文件中配置的内容+.ConditionalOnClass做key去spring-autoconfigure-metadata.properties //对应的class 然后判断这个条件class在类路径下是否存在 如果存在match为true 否则match为false ConditionOutcome[] outcomes = getOutcomes(autoConfigurationClasses, autoConfigurationMetadata); boolean[] match = new boolean[outcomes.length]; for (int i = 0; i &lt; outcomes.length; i++) &#123; match[i] = (outcomes[i] == null || outcomes[i].isMatch()); if (!match[i] &amp;&amp; outcomes[i] != null) &#123; logOutcome(autoConfigurationClasses[i], outcomes[i]); if (report != null) &#123; report.recordConditionEvaluation(autoConfigurationClasses[i], this, outcomes[i]); &#125; &#125; &#125; return match;&#125;private ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, int start, int end, AutoConfigurationMetadata autoConfigurationMetadata) &#123; ConditionOutcome[] outcomes = new ConditionOutcome[end - start]; for (int i = start; i &lt; end; i++) &#123; String autoConfigurationClass = autoConfigurationClasses[i]; if (autoConfigurationClass != null) &#123; String candidates = autoConfigurationMetadata.get(autoConfigurationClass, &quot;ConditionalOnClass&quot;); if (candidates != null) &#123; outcomes[i - start] = getOutcome(candidates); &#125; &#125; &#125; return outcomes;&#125;@Overridepublic String get(String className, String key, String defaultValue) &#123; String value = this.properties.getProperty(className + &quot;.&quot; + key); return (value != null) ? value : defaultValue;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"SpringBoot集成XXL-JOB","slug":"SpringBoot-集成xxlJob","date":"2022-03-12T04:03:27.735Z","updated":"2022-03-19T16:27:45.396Z","comments":false,"path":"2022/03/12/SpringBoot-集成xxlJob/","link":"","permalink":"http://example.com/2022/03/12/SpringBoot-%E9%9B%86%E6%88%90xxlJob/","excerpt":"","text":"一 xxl-job搭建xxl-job框架是一个分布式的任务调度平台，其核心包括两个角色调度中心和执行器 调度中心其实就是xxl-job的控制台 而执行器则是具体的业务工程。xxl-job中文文档 xxl-job架构图 下载xxl-job 地址如下 1https://github.com/xuxueli/xxl-job.git 初始化数据库 xxl-job依赖数据库 其源码中自带了sql 配置调度中心(xxl-job-admin) 调度中心配置文件地址如下 1/xxl-job/xxl-job-admin/src/main/resources/application.properties 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758### 调度中心的端口server.port=8181server.context-path=/xxl-job-admin### actuatormanagement.context-path=/actuatormanagement.health.mail.enabled=false### resourcesspring.mvc.servlet.load-on-startup=0spring.mvc.static-path-pattern=/static/**spring.resources.static-locations=classpath:/static/### freemarkerspring.freemarker.templateLoaderPath=classpath:/templates/spring.freemarker.suffix=.ftlspring.freemarker.charset=UTF-8spring.freemarker.request-context-attribute=requestspring.freemarker.settings.number_format=0.############# mybatismybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml### xxl-job, datasource spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxljob?Unicode=true&amp;characterEncoding=UTF-8spring.datasource.username=数据库用户名spring.datasource.password=数据库密码spring.datasource.driver-class-name=org.gjt.mm.mysql.Driverspring.datasource.type=org.apache.tomcat.jdbc.pool.DataSourcespring.datasource.tomcat.max-wait=10000spring.datasource.tomcat.max-active=30spring.datasource.tomcat.test-on-borrow=truespring.datasource.tomcat.validation-query=SELECT 1spring.datasource.tomcat.validation-interval=30000### xxl-job email(报警用的告警邮箱 如果不需要告警可以不配)spring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### xxl-job, access token(访问的accessToken 不用访问令牌的话可以不设置)xxl.job.accessToken=### xxl-job, i18n (default empty as chinese, &quot;en&quot; as english)xxl.job.i18n=zh_CN## 调度线程池最大线程配置【必填】xxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能xxl.job.logretentiondays=30 关于访问令牌(Token)说明 为提升系统安全性，调度中心和执行器进行安全性校验，双方AccessToken匹配才允许通讯；调度中心和执行器，可通过配置项 “xxl.job.accessToken” 进行AccessToken的设置。调度中心和执行器，如果需要正常通讯，只有两种设置； 设置一：调度中心和执行器，均不设置AccessToken；关闭安全性校验； 设置二：调度中心和执行器，设置了相同的AccessToken； 编译/打包/运行调度中心 将xxl-job-admin项目利用mvn package命令打成jar包 然后通过java -jar的方式启动 或者 直接在IDEA中直接启动xxl-job-admin即可 启动后输入 http://localhost:8181/xxl-job-admin 即可访问xxl-job调度中心 默认的账户密码为admin/123456 至此单机版调度中心搭建完成 如果需要提高系统的稳定性和容错性可以搭建调度中心集群 关于调度中心集群的说明 调度中心支持集群部署，提升调度系统容灾和可用性。调度中心集群部署时，几点要求和建议： DB配置保持一致； 集群机器时钟保持一致（单机集群忽视） 建议：推荐通过nginx为调度中心集群做负载均衡，分配域名。调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。 二 部署执行器xxl-job源码中提供了很多执行器的案例 这里只对SpringBoot执行器进行说明 导入依赖 xxl-job执行器需要导入xxl-job-core依赖 123456&lt;!-- xxl-job-core 版本自己定 建议和xxl-job-admin中依赖的xxl-job-core版本保持一致--&gt;&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt;&lt;/dependency&gt; 进行执行器配置 对执行器进行配置 主要包含两个方面 一是配置文件 二是xxlJobExecutor配置 执行器配置文件如下 12345678910111213141516### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；这个配置为空则需要在xxl-job-admin控制台中手动的配置执行器 如果这个配置填了则是自动注册xxl.job.admin.addresses=http://127.0.0.1:8181/xxl-job-admin### 执行器通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册xxl.job.executor.appname=xxl-job-executor-sample### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。xxl.job.executor.address=### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；xxl.job.executor.ip=### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；xxl.job.executor.port=9999### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；xxl.job.executor.logretentiondays=30 xxlJobExecutor配置 下面配置中的ip和token一般都可以不用 ip执行器会自动去获取 没有必要手动指定 token只有在调度中心也配置了token的情况下才会使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appName; @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;) private String ip; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;) private String accessToken; @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;) private String logPath; @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppName(appName); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125; /** * 针对多网卡、容器内部署等情况，可借助 &quot;spring-cloud-commons&quot; 提供的 &quot;InetUtils&quot; 组件灵活定制注册IP； * * 1、引入依赖： * &lt;dependency&gt; * &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; * &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt; * &lt;version&gt;$&#123;version&#125;&lt;/version&gt; * &lt;/dependency&gt; * * 2、配置文件，或者容器启动变量 * spring.cloud.inetutils.preferred-networks: &#x27;xxx.xxx.xxx.&#x27; * * 3、获取IP * String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress(); */&#125; 在执行器中新建任务 下面是demoJob的示例 123456789101112131415161718192021222324@Componentpublic class SampleXxlJob &#123; private static Logger logger = LoggerFactory.getLogger(SampleXxlJob.class); /** * 1、简单任务示例（Bean模式） * xxl-job的任务包含很多种模式 这里是最简单的bean类型模式 */ @XxlJob(&quot;demoJobHandler&quot;) public ReturnT&lt;String&gt; demoJobHandler(String param) throws Exception &#123; XxlJobLogger.log(&quot;XXL-JOB, Hello World.&quot;); for (int i = 0; i &lt; 5; i++) &#123; XxlJobLogger.log(&quot;beat at:&quot; + i); TimeUnit.SECONDS.sleep(2); &#125; return ReturnT.FAIL; &#125;&#125; 关于xxl-job任务类型的说明 xxl-job的任务类型有很多种具体可以见官方文档 编译/打包/运行执行器 这一步就是将你的springboot项目跑起来 配置任务 首先需要在执行器列表中新建执行器 然后在任务管理界面新增任务","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"XXL-JOB","slug":"XXL-JOB","permalink":"http://example.com/tags/XXL-JOB/"}]},{"title":"ForkJoin与并行流","slug":"FAQ-ForkJoin与并行流","date":"2022-03-09T14:12:44.763Z","updated":"2022-03-19T16:23:31.000Z","comments":false,"path":"2022/03/09/FAQ-ForkJoin与并行流/","link":"","permalink":"http://example.com/2022/03/09/FAQ-ForkJoin%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%B5%81/","excerpt":"","text":"一 ForkJoin简介ForkJoin线程池可以执行一种特殊的任务 它可以把一个大任务拆分成N个小任务并行执行 然后再将多个小任务的结果合并起来 组成大任务的执行结果，ForkJoin其实就是一种分治的思想，ForkJoin线程池是JDK1.7之后引入的。 ForkJoin框架提供了两个主要的子类用于实现ForkJoin任务 12RecursiveAction：用于没有返回结果的任务。RecursiveTask ：用于有返回结果的任务。 ForkJoin示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class Compute &#123; public static void main(String[] args) throws Exception &#123; int[] array = init(100); int val_1 = compute(array); //普通计算 100s左右 int val_2 = computeBinary(array); //普通二分 20s左右 int val_3 = computeForForkJoin(array); //forkjoin集散 5s左右 System.out.println(val_1 == val_2); System.out.println(val_1 == val_3); &#125; private static int[] init(int len) &#123; int[] array = new int[len]; for (int i = 0; i &lt; len; i++) &#123; array[i] = i; &#125; return array; &#125; /** * 没有采用ForkJoin线程池的计算方式 * @param array * @return * @throws Exception */ private static int compute(int[] array) throws Exception &#123; Long start = System.currentTimeMillis(); int val = 0; for (int i = 0; i &lt; array.length; i++) &#123; val+=array[i]; Thread.sleep(100); //模拟计算的耗时 时间太短与ForkJoin差别不明显 &#125; Long end = System.currentTimeMillis(); System.out.println(&quot;不采用forkJoin框架数组求和耗时&quot; + (end - start) + &quot;毫秒&quot;); return val; &#125; /** * 没有采用ForkJoin线程池的计算方式 普通二分 * @param array * @return * @throws Exception */ private static int computeBinary(int[] array) throws Exception &#123; Long start = System.currentTimeMillis(); int val = computeBinary(array, 0, array.length - 1); Long end = System.currentTimeMillis(); System.out.println(&quot;不采用forkJoin框架时 采用二分法对数组求和耗时&quot; + (end - start) + &quot;毫秒&quot;); return val; &#125; private static int computeBinary(int[] array, int start, int end) throws Exception &#123; Thread.sleep(100); //模拟计算的耗时 时间太短与ForkJoin差别不明显 //表示数组只有一个元素需要计算 if (end - start == 0) &#123; return array[start]; &#125; int mid = start + (end - start) / 2; //计算左半部分的数组的和 int left = computeBinary(array, start, mid); //计算右半部分的数组的和 int right = computeBinary(array, mid+1, end); return left + right; &#125; private static int computeForForkJoin(int[] array)&#123; Long start = System.currentTimeMillis(); //初始化一个ForkJoin的线程池 默认会计算机CPU核心数量的线程用于执行子任务 ForkJoinPool pool = new ForkJoinPool(); MyRecursiveTask task1 = new MyRecursiveTask(array, 0, array.length - 1); Integer val = pool.invoke(task1); //forkJoin执行任务 Long end = System.currentTimeMillis(); System.out.println(&quot;采用forkJoin框架数组求和耗时&quot; + (end - start) + &quot;毫秒&quot;); return val; &#125;&#125;class MyRecursiveTask extends RecursiveTask&lt;Integer&gt; &#123; private static final long serialVersionUID = 7391964389420391553L; private int[] array; private int start; private int end; /** * @param array 待求和的数组 * @param start 待求和的数组的起始位置 * @param end 待求和的数组的结束位置 */ public MyRecursiveTask(int[] array, int start, int end) &#123; this.array = array; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; try&#123; Thread.sleep(100); //模拟计算的耗时 时间太短与ForkJoin差别不明显 &#125;catch (Exception e) &#123; // &#125; //表示数组只有一个元素需要计算 if (end - start == 0) &#123; return array[start]; &#125; int mid = start + (end - start) / 2; //计算前半段的数组的和 MyRecursiveTask subTask_1 = new MyRecursiveTask(array, start, mid); //计算后半段的数组的和 MyRecursiveTask subTask_2 = new MyRecursiveTask(array, mid+1, end); //通过fork方法来执行子任务 subTask_1.fork(); subTask_2.fork(); //子任务的结果合并 Integer val_1 = subTask_1.join(); Integer val_2 = subTask_2.join(); return val_1 + val_2; &#125;&#125; 二 java8 ParallelStreamsjava8中的并行流内部采用的其实就是ForkJoinPool 它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available- Processors()得到的。 但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common. parallelism来改变线程池大小，如下所示： System.setProperty(“java.util.concurrent.ForkJoinPool.common.parallelism”,”12”); 这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个 并行流指定这个值。一般而言，让ForkJoinPool`的大小等于处理器数量是个不错的默认值， 除非你有很好的理由，否则我们强烈建议你不要修改它。","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot自动装配核心原理(一)","slug":"SpringBoot-自动装配核心原理01","date":"2022-03-02T14:14:20.003Z","updated":"2022-03-19T16:28:40.316Z","comments":false,"path":"2022/03/02/SpringBoot-自动装配核心原理01/","link":"","permalink":"http://example.com/2022/03/02/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%8601/","excerpt":"","text":"首先我们需要从SpringBoot启动类进行入手 开始分析 12345678910//自动装配的核心入口是这个注解@SpringBootApplicationpublic class App &#123; public static void main(String[] args) throws Exception&#123; //这行代码只是将对象装载到IOC容器中 这里的核心逻辑与Spring的启动流程是一模一样的 //这行代码最终会调用Spring的AbstractApplicationContext.refresh()方法中 SpringApplication.run(App.class, args); &#125;&#125; 如上所示 SpringBoot自动装配的入口在**@SpringBootApplication**注解中 下面是其源码 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; //省略其他代码&#125; @Target(ElementType.TYPE)、@Retention(RetentionPolicy.RUNTIME)、@Documented、@Inherited这四个是元注解 可以忽略 @ComponentScan 这个注解主要是用来做包扫描的 它会对指定包及其子包下的类进行扫描 如果该类包含@Component注解 则将这个类装配到IOC容器中 如果没有指明basePackages属性的话 则会去扫描该注解修饰的类所在的包及其子包 @SpringBootConfiguration @SpringBootConfiguration注解源码如下 可以看到这个注解就是用来标识某个类是Spring的配置类 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration //标识配置类的@Indexed //这个是为了提升Spring项目性能的 因为当一个项目足够复杂的时候 @ComponentScan需要扫描的时候就会需要进行多次IO操作 比较耗费性能 这个注解能将@Component修饰的类直接在编译器就生成好索引文件 @ComponentScan就不需要再单独的去扫描了public @interface SpringBootConfiguration &#123; //省略其他代码&#125; @Indexed @Indexed是Spring 5.0出现的 这个注解可以提升@ComponentScan注解的扫描效率，它需要配合spring-context-indexer包来使用 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;&lt;/dependency&gt; 需要注意的是@Component注解已经内置了@Indexed注解了 如果我们希望@Indexed注解生效 只需要添加spring-conetxt-indexer依赖即可 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Indexedpublic @interface Component &#123; String value() default &quot;&quot;;&#125; 至此**@SpringBootApplication**注解就只剩下@EnableAutoConfiguration注解了 该注解是SpringBoot自动装配的核心注解 其源码如下 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; //省略若干代码&#125; @AutoConfigurationPackage 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;//省略若干代码&#125; @AutoConfigurationPackage内部只也包含了一个**@Import注解 从这里可以看出核心注解是@Import** @Import @Import注解的作用是将一个类或者多个类导入到Spring容器中 如下面的示例(import的静态导入) 1234567891011121314151617181920212223242526272829303132//Student类并没有添加@Component注解@Datapublic class Student &#123; private String name = &quot;张三&quot;; private Integer age = 18;&#125;//Teacher类并没有添加@Component注解@Datapublic class Teacher &#123; private String name = &quot;李四&quot;; private Integer age = 20;&#125;//通过@Import注解将Student和Teacher类注入到容器中@Import(&#123;Student.class, Teacher.class&#125;)@SpringBootApplicationpublic class App01 &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(App01.class, args); Student student = context.getBean(Student.class); System.out.println(student.getName()); Teacher teacher = context.getBean(Teacher.class); System.out.println(teacher.getName()); &#125;&#125; 如果**@Import**注解中引入的类是实现了ImportSelector接口的类 那么该类不会被导入到Spring容器中 而是会把ImportSelector接口的selectImports()方法的返回值(返回值应该是类的全限定名)作为bean注入到spring容器中 示例如下:(import的动态导入) 12345678910111213141516171819202122232425262728293031323334353637@Datapublic class Student &#123; private String name = &quot;张三&quot;; private Integer age = 18;&#125;@Datapublic class Teacher &#123; private String name = &quot;李四&quot;; private Integer age = 20;&#125;//实现了ImportSelector接口public class MyImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;Student.class.getName(), Teacher.class.getName()&#125;; &#125;&#125;@Import(MyImportSelector.class) //这个import就比较像SpringBoot容器启动时引入的配置了@SpringBootApplicationpublic class App01 &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(App01.class, args); Student student = context.getBean(Student.class); System.out.println(student.getName()); Teacher teacher = context.getBean(Teacher.class); System.out.println(teacher.getName()); //这里会报bean不存在 MyImportSelector myImportSelector = context.getBean(MyImportSelector.class); &#125;&#125; 如果**@Import**注解导入的类实现了ImportBeanDefinitionRegistrar接口 那么这个类也不会导入到Spring容器中而是会执行registerBeanDefinitions()方法 将你需要导入的bean转成BeanDefinition对象注入到容器中 示例如下: 12345678910111213141516171819202122232425262728293031323334353637383940@Datapublic class Student &#123; private String name = &quot;张三&quot;; private Integer age = 18;&#125;@Datapublic class Teacher &#123; private String name = &quot;李四&quot;; private Integer age = 20;&#125;public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; RootBeanDefinition student = new RootBeanDefinition(Student.class); registry.registerBeanDefinition(&quot;student&quot;, student); //向容器中注入student RootBeanDefinition teacher = new RootBeanDefinition(Teacher.class); registry.registerBeanDefinition(&quot;teacher&quot;, teacher); //向容器中注入teacher &#125;&#125;@Import(MyImportBeanDefinitionRegistrar.class)@SpringBootApplicationpublic class App01 &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(App01.class, args); Student student = context.getBean(Student.class); System.out.println(student.getName()); Teacher teacher = context.getBean(Teacher.class); System.out.println(teacher.getName()); //这里会报bean不存在 MyImportBeanDefinitionRegistrar myImportBeanDefinitionRegistrar = context.getBean(MyImportBeanDefinitionRegistrar.class); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"桥接模式","slug":"设计模式-桥接模式","date":"2022-02-12T14:50:03.144Z","updated":"2022-03-19T16:17:26.161Z","comments":false,"path":"2022/02/12/设计模式-桥接模式/","link":"","permalink":"http://example.com/2022/02/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述桥接模式的主要目的是通过组合的方式建立两个类之间的联系，而不是继承，但是又类似多重继承的方案。但是多重继承违背了类的单一职责原则，其复用性较差，桥接模式是比多重继承更好的替代方案，桥接模式的核心在于把抽象和实现进行解耦。 当一个对象拥有两个及以上维度变化的时候 可以考虑用桥接模式来拼接这个复合对象 如 对于一个几何图形来说 它有形状 和 颜色两个维度。如下图，如果通过继承的方式来组织，那么再增加一个菱形，又得扩展N个子类(每种颜色一个子类) 会造成子类过多。 二 桥接模式的结构桥接模式主要包含如下角色 抽象角色 定义抽象类,并包含一个实现化对象的引用 (是一个抽象类) 扩展抽象角色 是抽象角色的子类 实现父类中的业务方法 并通过组合关系调用实现化角色中的业务方法 实现化角色 定义实现化角色的接口，扩展抽象化角色调用 (一般是一个抽象类或者是一个接口) 具体实现化角色 给出实现化角色接口的具体实现 三 桥接模式案例需要开发一个跨平台的视频播放器，可以在不同的操作系统(Windows、Mac、Linux)上播放多种视频文件，常见的视频格式包括RMVB、AVI、MWV等，该播放器包括了2个维度，操作系统和视频格式 适合使用桥接模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//测试类public class Client &#123; public static void main(String[] args) &#123; VideoFile rmvbVideoFile = new RMVBVideoFile(); WindowsOS windows = new WindowsOS(rmvbVideoFile); windows.play(&quot;测试.rmvb&quot;); System.out.println(&quot;=======================&quot;); VideoFile aviVideoFile = new RMVBVideoFile(); MacOS mac = new MacOS(aviVideoFile); mac.play(&quot;测试.avi&quot;); System.out.println(&quot;=======================&quot;); MacOS mac2 = new MacOS(rmvbVideoFile); mac2.play(&quot;测试.rmvb&quot;); &#125;&#125;//实现化角色public interface VideoFile &#123; void decode(String fileName);&#125;//具体实现化角色public class AVIVideoFile implements VideoFile &#123; @Override public void decode(String fileName) &#123; System.out.println(&quot;AVI视频 文件名为 &quot; + fileName); &#125;&#125;//具体实现化角色public class RMVBVideoFile implements VideoFile&#123; @Override public void decode(String fileName) &#123; System.out.println(&quot;RMVB视频 文件名为&quot; + fileName); &#125;&#125;//抽象角色public abstract class OS &#123; //实现化角色的引用 protected VideoFile videoFile; public OS(VideoFile videoFile) &#123; this.videoFile = videoFile; &#125; public abstract void play(String fileName);&#125;//扩展抽象化角色public class MacOS extends OS &#123; public MacOS(VideoFile videoFile) &#123; super(videoFile); &#125; @Override public void play(String fileName) &#123; System.out.print(&quot;mac系统 播放&quot;); videoFile.decode(fileName); &#125;&#125;//扩展抽象化角色public class WindowsOS extends OS&#123; public WindowsOS(VideoFile videoFile) &#123; super(videoFile); &#125; @Override public void play(String fileName) &#123; System.out.print(&quot;windows系统 播放&quot;); videoFile.decode(fileName); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"适配器模式","slug":"设计模式-适配器模式","date":"2022-02-11T13:46:40.814Z","updated":"2022-03-19T16:17:08.563Z","comments":false,"path":"2022/02/11/设计模式-适配器模式/","link":"","permalink":"http://example.com/2022/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述适配器模式又叫做变压器模式，它的功能是将一个类的接口变成客户端所期望的另一种接口，从而使得原本因接口不匹配而导致无法在一起工作的两个类能够在一起工作。适配器模式适用于以下业务场景 已存在的类，它的方法和需求不匹配 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护、由于不同产品、不同厂家造成功能类似而接口不同情况下的解决方案，有种亡羊补牢的感觉。 适配器模式有主要有两种模式 一 类适配器 二 对象适配器 适配器模式一般包含三个角色 目标角色 也就是我们期望的接口 适配者(Adaptee) 也可以叫做源角色 即功能上可以满足客户需要 但是需要通过适配器将适配者转换位目标对象 适配器(Adapter) 将是适配者转换位目标角色的类 二 类适配器案例类适配器的原理就是通过继承来实现适配器的功能，具体的做法是让适配器实现目标接口同时继承Adaptee，这样适配器就具备了目标接口和适配者两者的功能，这样适配器就可以将两者转换。 类适配器实现的核心 继承适配者 同时实现目标接口 案例 现有一台电脑只能读取SD卡,而要让电脑能读取TF卡中的内容，则需要一个读卡器(适配器)将TF卡的内容转成SD卡的内容格式 读取出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//目标接口public interface SDCard &#123; String readSD(); void writeSD(String message);&#125;//目标接口的实现 于本例没什么关系public class SDCardImpl implements SDCard&#123; @Override public String readSD() &#123; return &quot;read msg from sd card&quot;; &#125; @Override public void writeSD(String message) &#123; System.out.println(&quot;write message to sd card&quot;); &#125;&#125;//适配者public class TFCard &#123; public String readTF() &#123; System.out.println(&quot;read msg from tf card&quot;); return &quot;hello world&quot;; &#125; public void writeTF(String message) &#123; System.out.println(&quot;write &quot; + message + &quot; to tf card&quot;); &#125;&#125;//适配器public class SDCardAdapter extends TFCard implements SDCard&#123; @Override public String readSD() &#123; //读取TF卡的信息 String message = readTF(); //模拟将TF卡的信息转换为SD卡的信息格式 System.out.println(&quot;trans msg to sd card&quot;); return message; &#125; @Override public void writeSD(String message) &#123; //模拟将sd格式的信息转为tf格式的信息 System.out.println(&quot;trans msg to tf&quot;); writeTF(message); &#125;&#125;//客户端public class Computer &#123; //模拟电脑读取sd card数据 public String readSD(SDCard sdCard)&#123; return sdCard.readSD(); &#125; //模拟电脑写sd card数据 public void writeSD(SDCard sdCard, String message)&#123; sdCard.writeSD(message); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; SDCard sdCard = new SDCardAdapter(); Computer computer = new Computer(); String message = computer.readSD(sdCard); System.out.println(message); System.out.println(&quot;======================&quot;); computer.writeSD(sdCard, &quot;hello world&quot;); &#125;&#125; 三 对象适配器对象适配器的原理就是通过组合来实现适配器的功能。具体做法是让Adapter实现目标接口,然后内部再持有Adaptee实例。对象适配器的处理方式和静态代理与装饰器模式比较像。实际开发中一般较少用类适配器 而是用对象适配器居多。还是以上面的去读卡器为例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//目标接口public interface SDCard &#123; String readSD(); void writeSD(String message);&#125;//适配者public class TFCard &#123; public String readTF() &#123; System.out.println(&quot;read msg from tf card&quot;); return &quot;hello world&quot;; &#125; public void writeTF(String message) &#123; System.out.println(&quot;write &quot; + message + &quot; to tf card&quot;); &#125;&#125;//适配器public class SDCardAdapter implements SDCard&#123; private TFCard tfCard; public SDCardAdapter(TFCard tfCard)&#123; this.tfCard = tfCard; &#125; @Override public String readSD() &#123; //读取TF卡的信息 String message = tfCard.readTF(); //模拟将TF卡的信息转换为SD卡的信息格式 System.out.println(&quot;trans msg to sd card&quot;); return message; &#125; @Override public void writeSD(String message) &#123; //模拟将sd格式的信息转为tf格式的信息 System.out.println(&quot;trans msg to tf&quot;); tfCard.writeTF(message); &#125;&#125;//客户端public class Computer &#123; //模拟电脑读取sd card数据 public String readSD(SDCard sdCard)&#123; return sdCard.readSD(); &#125; //模拟电脑写sd card数据 public void writeSD(SDCard sdCard, String message)&#123; sdCard.writeSD(message); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; SDCard sdCard = new SDCardAdapter(new TFCard()); Computer computer = new Computer(); String message = computer.readSD(sdCard); System.out.println(message); System.out.println(&quot;======================&quot;); computer.writeSD(sdCard, &quot;hello world&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"组合模式","slug":"设计模式-组合模式","date":"2022-02-10T13:19:32.606Z","updated":"2022-03-19T16:16:36.696Z","comments":false,"path":"2022/02/10/设计模式-组合模式/","link":"","permalink":"http://example.com/2022/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述组合模式又叫整体-部分模式，它主要适用于树形结构，组合模式出现的场景一般是树形结构出现的地方，比如文件目录显示，多级目录，公司组织架构、菜单树展示等呈现等树形结构的操作。组合模式将对象组织到树形结构中，顶层的节点被称之为根节点，根节点下包括树枝节点和叶子节点。树枝节点下也可以包含树枝节点和叶子节点。 二 组合模式案例如下图 我们在访问阿里云的控制台的时候，可以看到类似下面的菜单树，一个菜单可以包含菜单项(菜单项是指不包含其他菜单的菜单条目) 也可以包含子菜单，现在需要打印如下图这样的菜单树。像这种针对树形结构的操作 我们就可以采用组合模式。 代码示例 抽象根节点 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class AbstractMenu &#123; //菜单名称 protected String name; //菜单级别 protected Integer level; public AbstractMenu(String name, Integer level) &#123; this.name = name; this.level = level; &#125; //打印菜单树的方法 public abstract void print(); /** * 添加子菜单 对于菜单项来说 这就是不允许的才做 * @param child */ public void addChild(AbstractMenu child)&#123; throw new UnSupportOperationException(&quot;不允许的操作&quot;); &#125; /** * 删除子菜单 对于菜单项来说 这就是不允许的才做 * @param child */ public void remove(AbstractMenu child) &#123; throw new UnSupportOperationException(&quot;不允许的操作&quot;); &#125; /** * 根据索引获取某个子菜单 * @param index * @return */ public AbstractMenu getChild(int index) &#123; throw new UnSupportOperationException(&quot;不允许的操作&quot;); &#125;&#125; 树枝节点 123456789101112131415161718192021222324252627282930public class Menu extends AbstractMenu&#123; //子菜单或菜单项 private List&lt;AbstractMenu&gt; children = new ArrayList&lt;&gt;(); public Menu(String name, Integer level) &#123; super(name, level); &#125; @Override public void addChild(AbstractMenu child) &#123; children.add(child); &#125; @Override public AbstractMenu getChild(int index) &#123; return children.get(index); &#125; @Override public void print() &#123; for (int i = 0 ; i&lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); for (AbstractMenu child : children) &#123; child.print(); &#125; &#125;&#125; 叶子节点 1234567891011121314public class MenuItem extends AbstractMenu&#123; public MenuItem(String name, Integer level) &#123; super(name, level); &#125; @Override public void print() &#123; for (int i = 0 ; i&lt; level; i++) &#123; System.out.print(&quot;--&quot;); &#125; System.out.println(name); &#125;&#125; 异常类 12345678public class UnSupportOperationException extends RuntimeException &#123; private static final long serialVersionUID = 4229569507118124299L; public UnSupportOperationException(String message) &#123; super(message); &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Client &#123; public static void main(String[] args) &#123; //图中的根节点是看不见的 所以菜单名为&quot;&quot; AbstractMenu root = new Menu(&quot;/&quot;, 1); //概览菜单项 AbstractMenu overView = new MenuItem(&quot;概览&quot;, 2); //应用型负载均衡ALB AbstractMenu alb = new Menu(&quot;应用型负载均衡ALB&quot;, 2); AbstractMenu instance = new MenuItem(&quot;实例&quot;, 3); AbstractMenu server = new MenuItem(&quot;服务器组&quot;, 3); AbstractMenu healthCheck = new MenuItem(&quot;健康检查&quot;, 3); AbstractMenu control = new MenuItem(&quot;访问控制&quot;, 3); AbstractMenu strategy = new MenuItem(&quot;TSL安全策略&quot;, 3); AbstractMenu albPackage = new MenuItem(&quot;ALB资源包&quot;, 3); alb.addChild(instance); alb.addChild(server); alb.addChild(healthCheck); alb.addChild(control); alb.addChild(strategy); alb.addChild(albPackage); //传统型负载均衡CLB AbstractMenu clb = new Menu(&quot;传统型负载均衡CLB(原SLB)&quot;, 2); AbstractMenu instanceMgm = new MenuItem(&quot;实例管理&quot;, 3); AbstractMenu recycleBin = new MenuItem(&quot;回收站&quot;, 3); AbstractMenu certificate = new MenuItem(&quot;证书管理&quot;, 3); AbstractMenu logMgm = new Menu(&quot;日志管理&quot;, 3); AbstractMenu operation = new MenuItem(&quot;操作日志&quot;, 4); AbstractMenu access = new MenuItem(&quot;访问日志&quot;, 4); logMgm.addChild(operation); logMgm.addChild(access); clb.addChild(instanceMgm); clb.addChild(recycleBin); clb.addChild(certificate); clb.addChild(control); //添加访问控制菜单项 clb.addChild(logMgm); root.addChild(overView); root.addChild(alb); root.addChild(clb); //打印菜单树 root.print(); &#125;&#125; 测试结果","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBoot统一参数校验","slug":"SpringBoot-参数校验","date":"2022-02-09T14:23:38.803Z","updated":"2022-03-19T16:27:06.971Z","comments":false,"path":"2022/02/09/SpringBoot-参数校验/","link":"","permalink":"http://example.com/2022/02/09/SpringBoot-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"Spring Boot 项目实现统一参数校验需要进行如下几步 导入依赖 Spring Boot 2.3 1 之后，spring-boot-starter-validation 已经不包括在了 spring-boot-starter-web 中，需要我们手动加上！ 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 测试Controller @Validated注解的作用是用来告诉spring去校验方法的参数 123456789@RestController@RequestMapping(&quot;/api/person&quot;)@Validatedpublic class PersonController &#123; @PostMapping public ResponseEntity&lt;PersonRequest&gt; save(@RequestBody @Valid PersonRequest personRequest) &#123; return ResponseEntity.ok().body(personRequest); &#125;&#125; 测试request对象 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructorpublic class PersonRequest &#123; @NotNull(message = &quot;classId 不能为空&quot;) private String classId; @Size(max = 33) @NotNull(message = &quot;name 不能为空&quot;) private String name; @Pattern(regexp = &quot;(^Man$|^Woman$|^UGM$)&quot;, message = &quot;sex 值不在可选范围&quot;) @NotNull(message = &quot;sex 不能为空&quot;) private String sex;&#125; 正则表达式说明： ^string : 匹配以 string 开头的字符串 string$ ：匹配以 string 结尾的字符串 ^string$ ：精确匹配 string 字符串 (^Man$|^Woman$|^UGM$) : 值只能在 Man,Woman,UGM 这三个值中选择 全局异常处理器 需要定义一个全局异常处理器来控制参数校验失败后的输出 1234567891011121314151617181920212223@ControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 参数校验异常处理 * @param req * @param e * @return */ @ResponseBody @ExceptionHandler(value = MethodArgumentNotValidException.class) public String methodArgumentNotValidHandler(HttpServletRequest req, MethodArgumentNotValidException e) &#123; BindingResult bindingResult = e.getBindingResult(); StringBuilder sb = new StringBuilder(&quot;参数校验失败:&quot;); for (FieldError fieldError : bindingResult.getFieldErrors()) &#123; sb.append(fieldError.getDefaultMessage()).append(&quot;;&quot;); &#125; return sb.toString(); &#125;&#125; 上面是基于Controller层的参数校验 如果希望把参数校验放到service层 通过使用@Validated和@Valid注释的组合即可实现这一需求，只需要如下配置Service类即可 @Validated注解的作用是用来告诉spring去校验方法的参数 1234567@Service@Validatedpublic class PersonService &#123; public void validatePersonRequest(@Valid PersonRequest personRequest) &#123; // do something &#125;&#125; 另外全局异常处理器需要变一下 不再是捕获MethodArgumentNotValidException了而是捕获ConstraintViolationException 1234567891011121314151617181920212223@ControllerAdvicepublic class GlobalExceptionHandler &#123; private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 参数校验异常处理 * @param req * @param e * @return */ @ResponseBody @ExceptionHandler(value = ConstraintViolationException.class) public String constraintViolationExceptionHandler(HttpServletRequest req, ConstraintViolationException e) &#123; StringBuilder sb = new StringBuilder(&quot;参数校验失败:&quot;); for (ConstraintViolation constraintViolation : e.getConstraintViolations()) &#123; sb.append(constraintViolation.getMessage()).append(&quot;;&quot;); &#125; return sb.toString(); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"享元模式","slug":"设计模式-享元模式","date":"2022-02-09T13:25:13.045Z","updated":"2022-03-19T16:16:11.025Z","comments":false,"path":"2022/02/09/设计模式-享元模式/","link":"","permalink":"http://example.com/2022/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述享元模式又叫做轻量级模式，是对象池的一种实现。类似线程池，其宗旨是共享细粒度对象，将多个对同一对象的访问集中起来，不必要为每个访问者都创建一个单独的对象，以此来降低内存的消耗。享元模式把一个对象的状态分为内部状态和外部状态 内部状态是不变的 外部状态是变化的，通过共享不变的部分，达到减少对象数量并节约内存的目的。享元模式的本质是缓存共享对象，降低内存消耗。 二 享元模式的角色 抽象享元角色 它是享元对象的抽象基类或者接口 同时定义出享元对象的外部状态和内部状态的接口或实现 具体享元角色 它是抽象享元角色的实现 该角色的内部状态应该与环境无关 享元工厂 负责管理享元对象池和创建享元对象 三 享元模式案例下面的图片是俄罗斯方块游戏中常见的几种形状，如果每个不同的方块都是一个实例对象，那么这些对象就要占用很多的内存空间，这个时候就可以利用享元模式来优化。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//抽象享元角色public abstract class AbstractBox &#123; //这里shape是对象的内部状态 是享元对象的共性 public abstract String shape(); //而color是享元对象的外部状态 它由参数传递进来 public void display(String color) &#123; System.out.println( &quot;形状 : &quot; + shape() + &quot; 颜色 : &quot; + color); &#125;&#125;//具体享元角色public class Ibox extends AbstractBox&#123; @Override public String shape() &#123; return &quot;I&quot;; &#125;&#125;//具体享元角色public class Jbox extends AbstractBox&#123; @Override public String shape() &#123; return &quot;J&quot;; &#125;&#125;//具体享元角色public class Zbox extends AbstractBox&#123; @Override public String shape() &#123; return &quot;Z&quot;; &#125;&#125;//享元工厂public class BoxFactory &#123; private static final BoxFactory instance = new BoxFactory(); private Map&lt;String, AbstractBox&gt; map = new HashMap&lt;&gt;(); private BoxFactory()&#123; map.put(&quot;I&quot;, new Ibox()); map.put(&quot;J&quot;, new Jbox()); map.put(&quot;Z&quot;, new Zbox()); &#125; public static BoxFactory getInstance() &#123; return instance; &#125; public AbstractBox getBox(String key)&#123; return map.get(key); &#125;&#125;//场景类public class Client &#123; public static void main(String[] args) &#123; BoxFactory factory = BoxFactory.getInstance(); AbstractBox i = factory.getBox(&quot;I&quot;); i.display(&quot;灰色&quot;); AbstractBox j = factory.getBox(&quot;J&quot;); j.display(&quot;绿色&quot;); AbstractBox z = factory.getBox(&quot;Z&quot;); z.display(&quot;黄色&quot;); AbstractBox j2 = factory.getBox(&quot;J&quot;); j2.display(&quot;紫色&quot;); System.out.println(j == j2); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰器模式","slug":"设计模式-装饰器模式","date":"2022-02-08T13:00:59.961Z","updated":"2022-03-19T16:15:54.692Z","comments":false,"path":"2022/02/08/设计模式-装饰器模式/","link":"","permalink":"http://example.com/2022/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一 概述装饰器模式(Decorator Pattern) 也叫包装器模式，装饰器模式是指在不改变原有对象的基础上，动态的给一个对象添加一些额外的职责。装饰器模式是继承的一个替代方案。装饰器模式与静态代理很像，需要注意它们的区别。 二 装饰器引入我们先来看一个快餐店的例子，快餐店有炒饭、炒面，同时这些炒饭、炒面里可以加鸡蛋、培根这些配菜。当然加配菜需要往外加钱，每个配菜的价格通常是不一样的。这样计算快餐的总价就比较麻烦。下面来看通过继承的方式来实现快餐店的功能。 如上图 如果使用继承来实现，那么当新增一个配菜的时候 我们就需要新增两个配菜的子类 如果再多一个大类别(比如说炒河粉) 那就要新增所有的配菜子类了 鸡蛋炒河粉、培根炒河粉，切针对继承这种方式如果我要计算 一个炒饭+2个鸡蛋+1份培根这种 单靠继承是无法解决的 必须要单独新增计算方法。 三 装饰器模式结构装饰器模式主要有4个角色 抽象构建角色(Component) 定义一个抽象接口以规范待装饰的对象的行为 具体构建角色(Concrete Component) 它实际上就是待装饰的对象 它实现了抽象构建角色的接口 抽象装饰角色(Decorator) 抽象装饰角色 需要集成抽象构建角色 并且需要聚合具体构建角色的实例 具体装饰角色(ConcreteDecorator) 实现了抽象装饰角色的相关方法，并给具体的构建对象添加额外的功能 装饰器模式的通用写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Client &#123; public static void main(String[] args) &#123; Component c = new ConcreteComponent(); Decorator decoratorA = new ConCreteDecoratorA(c); Decorator decoratorB = new ConCreteDecoratorB(c); decoratorA.operation(); System.out.println(&quot;===========================&quot;); decoratorB.operation(); &#125;&#125;//抽象构建角色abstract class Component&#123; //示例方法 也就是装饰器和被装饰的对象需要共同实现的方法 public abstract void operation();&#125;//具体构建角色class ConcreteComponent extends Component &#123; @Override public void operation() &#123; System.out.println(&quot;处理业务逻辑&quot;); &#125;&#125;//抽象装饰角色class Decorator extends Component &#123; protected Component component; //通过构造方法传递具体的构建角色 public Decorator(Component component) &#123; this.component = component; &#125; @Override public void operation() &#123; component.operation(); &#125;&#125;//具体的装饰角色Aclass ConCreteDecoratorA extends Decorator &#123; //通过构造方法传递具体的构建角色 public ConCreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void operation() &#123; before(); component.operation(); after(); &#125; private void before()&#123; System.out.println(&quot;方法增强 before&quot;); &#125; private void after()&#123; System.out.println(&quot;方法增强 after&quot;); &#125;&#125;//具体的装饰角色Aclass ConCreteDecoratorB extends Decorator &#123; //通过构造方法传递具体的构建角色 public ConCreteDecoratorB(Component component) &#123; super(component); &#125; @Override public void operation() &#123; before(); component.operation(); after(); &#125; private void before()&#123; System.out.println(&quot;方法增强 before&quot;); &#125; private void after()&#123; System.out.println(&quot;方法增强 after&quot;); &#125;&#125; 四 利用装饰器模式改造快餐店123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//测试类public class Client &#123; public static void main(String[] args) &#123; FastFood fastFood = new FriedRice(); fastFood = new Egg(fastFood); System.out.println(fastFood.getDesc() + &quot; 价格为 &quot; + fastFood.cost() + &quot;元&quot;); System.out.println(&quot;========================================&quot;); fastFood = new Bacon(fastFood); System.out.println(fastFood.getDesc() + &quot; 价格为 &quot; + fastFood.cost() + &quot;元&quot;); System.out.println(&quot;========================================&quot;); fastFood = new Bacon(fastFood); System.out.println(fastFood.getDesc() + &quot; 价格为 &quot; + fastFood.cost() + &quot;元&quot;); &#125;&#125;//快餐类 也就是抽象构建角色@Datapublic abstract class FastFood &#123; private float price; private String desc; public FastFood(float price, String desc) &#123; this.price = price; this.desc = desc; &#125; public abstract float cost();&#125;//炒饭类 也就是具体构建角色public class FriedRice extends FastFood &#123; public FriedRice() &#123; super(10.f, &quot;炒饭&quot;); &#125; @Override public float cost() &#123; return getPrice(); &#125;&#125;//配菜 也就是抽象装角色public abstract class Dish extends FastFood &#123; protected FastFood fastFood; public Dish(FastFood fastFood, float price, String desc) &#123; super(price, desc); this.fastFood = fastFood; &#125; public FastFood getFastFood() &#123; return fastFood; &#125; public void setFastFood(FastFood fastFood) &#123; this.fastFood = fastFood; &#125;&#125;//鸡蛋类 也就是具体装饰角色public class Egg extends Dish &#123; public Egg(FastFood fastFood) &#123; super(fastFood, 1.0f, &quot;鸡蛋&quot;); &#125; @Override public float cost() &#123; return getFastFood().cost() + getPrice(); &#125; @Override public String getDesc() &#123; return getFastFood().getDesc() + &quot;加&quot; + super.getDesc(); &#125;&#125;//培根类 也是具体装饰角色public class Bacon extends Dish &#123; public Bacon(FastFood fastFood) &#123; super(fastFood, 2.0f, &quot;培根&quot;); &#125; @Override public float cost() &#123; return getFastFood().cost() + getPrice(); &#125; @Override public String getDesc() &#123; return getFastFood().getDesc() + &quot;加&quot; + super.getDesc(); &#125;&#125; 五 装饰器模式使用场景 当不能采用继承的方式对系统进行扩充的时候 当类被final修饰时 不能被继承 该扩展相对独立 放在继承类中不合适的时候 当对象的功能要求可以动态的增加 也可以动态的撤销的时候 如上面快餐店的场景中 添加多份鸡蛋的时候 JDK源码解析 IO流中的缓冲流就使用了装饰器模式 类图如下 六 静态代理与装饰器模式的区别 它们的目的不一样 代理模式侧重于对被代理对象的控制 而装饰器模式则主要是对被装饰对象的增强 它们的用法有差别 代理模式对于被代理对象有控制权 可以执行也可以不执行 而装饰器模式 对于被装饰的对象没有控制权 它一定会执行 使用代理模式的情况下 客户端更关注于被代理对象(真实角色)的功能 而 装饰器模式下则更关注的是装饰器新增的功能 有些人人为 在代理模式下一般真实对象是很难获得的 而装饰器模式下 你是可以比较容易的获得被装饰的对象 体现在装饰器模式下 被装饰的对象是通过装饰器的构造器来传递被装饰对象的","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"门面模式","slug":"设计模式-门面模式","date":"2022-02-07T12:44:25.697Z","updated":"2022-03-19T16:15:12.385Z","comments":false,"path":"2022/02/07/设计模式-门面模式/","link":"","permalink":"http://example.com/2022/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"门面模式也叫外观设计模式，门面模式主要作用是可以屏蔽底层子系统的调用，降低使用者的难度。由门面来负责整合底层子系统的调用。该模式对外会有一个统一的接口，外部应用程序不用关心内部子系统的具体细节，这样可以降低程序的复杂度，提高了程序的可维护性。门面模式是迪米特法则的一个典型应用。门面模式在生活中一个很典型的例子就是基金 基金相当于就是一个门面, 买基金的人相当于是客户端，基金中包含的各种股票、债券等相当于一个个的子系统。客户并不需要了解各种基金中包含的这些股票和债券。 一 结构门面(Facade)模式主要包含以下角色: 门面(Facade)角色 为各个子系统提供一个共同的接口 子系统(Sub System)角色 实现系统的部分功能，客户可以通过门面来访问它 二 门面模式的优缺点优点: 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类 对客户端屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加的容易 缺点 门面模式不符合开闭原则，子系统如果有变更或者扩展 门面也需要相应的变更 三 门面模式的通用写法1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Client &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.doA(); facade.doB(); facade.doC(); &#125;&#125;class SubStemA&#123; public void doA()&#123; System.out.println(&quot;do A&quot;); &#125;&#125;class SubStemB&#123; public void doB()&#123; System.out.println(&quot;do B&quot;); &#125;&#125;class SubStemC&#123; public void doC()&#123; System.out.println(&quot;do C&quot;); &#125;&#125;class Facade &#123; private SubStemA a = new SubStemA(); private SubStemB b = new SubStemB(); private SubStemC c = new SubStemC(); public void doA()&#123; this.a.doA(); &#125; public void doB()&#123; this.b.doB(); &#125; public void doC()&#123; this.c.doC(); &#125;&#125; 四 门面模式案例小明的爷爷已经60岁了，一个人在家生活，每次都需要打开灯，打开电视，打开空调，睡觉前需要关闭灯，关闭电视，关闭空调，操作起来比较麻烦，所以小明给爷爷买了智能音箱，通过语音来控制这些家电的开启和关闭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class AirCondition &#123; public void on() &#123; System.out.println(&quot;空调开了&quot;); &#125; public void off() &#123; System.out.println(&quot;空调关了&quot;); &#125;&#125;public class Light &#123; public void on() &#123; System.out.println(&quot;灯开了&quot;); &#125; public void off() &#123; System.out.println(&quot;灯关了&quot;); &#125;&#125;public class TV &#123; public void on() &#123; System.out.println(&quot;电视开了&quot;); &#125; public void off() &#123; System.out.println(&quot;电视关了&quot;); &#125;&#125;public class SmartApplicationFacade &#123; private Light light = new Light(); private TV tv = new TV(); private AirCondition airCondition = new AirCondition(); public void say(String message) &#123; if (message.contains(&quot;打开电灯&quot;)) &#123; light.on(); return; &#125; if (message.contains(&quot;打开电视&quot;)) &#123; tv.on(); return; &#125; if (message.contains(&quot;打开空调&quot;)) &#123; airCondition.on(); return; &#125; if (message.contains(&quot;打开所有家电&quot;)) &#123; on(); return; &#125; if (message.contains(&quot;关闭电灯&quot;)) &#123; light.off(); return; &#125; if (message.contains(&quot;关闭电视&quot;)) &#123; tv.off(); return; &#125; if (message.contains(&quot;关闭空调&quot;)) &#123; airCondition.off(); return; &#125; if (message.contains(&quot;关闭所有家电&quot;)) &#123; off(); return; &#125; System.out.println(&quot;我听不懂你在说什么&quot;); &#125; private void on()&#123; this.airCondition.on(); this.tv.on(); this.light.on(); &#125; private void off()&#123; this.airCondition.off(); this.tv.off(); this.light.off(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; SmartApplicationFacade facade = new SmartApplicationFacade(); facade.say(&quot;打开所有家电&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"UML","slug":"设计模式-UML","date":"2022-01-31T08:19:09.025Z","updated":"2022-03-19T16:12:04.943Z","comments":false,"path":"2022/01/31/设计模式-UML/","link":"","permalink":"http://example.com/2022/01/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML/","excerpt":"","text":"一 UML图中的六种关系UML将事物之间的联系归纳为6种 分别是 关联关系、聚合关系、组合关系、泛化关系、实现关系、依赖关系 关联关系 关联关系 是对象之间的一种引用关系，表示一个类和另一个类之间的联系。关联关系有单向的也有双向的，在UML类图中 单向关联用一个带箭头的实线表示，双向关联用没有箭头的实线来表示 (一个类A的成员变量包含了另一个类B 则该A与B之间是关联关系 类A与类B在同一个层次) 聚合关系 聚合关系其实也是关联关系的一种 即它也满足 (一个类A的成员变量包含了另一个类B) 聚合关系与关联关系最大的区别是 类A与类B不是同一个层次 这是一个逻辑上的概念 代码中无法呈现。成员是整体的一部分，成员也可以脱离整体而存在。在UML类图中，用带空心菱形的实线来表示聚合关系，菱形指向整体。 组合关系 组合关系首先也是关联关系的一种 同时也是聚合关系的一种 即它满足(一个类A的成员变量包含了另一个类B 且 A 与 B不是同一个层次) 它与聚合关系最大的区别是聚合关系中类B是可以单独存在的 而组合关系中类B不能单独存在(能否单独存在 也是一个逻辑上的概念 代码无法区分) 在UML类图中，用带实心菱形的实线来表示组合关系，菱形指向整体 下图中 大脑是身体的一个组成部分 且大脑 不能脱离身体而存在 泛化关系 泛化关系表示的就是类与类之间的继承关系，在UML类图中，用带空心三角箭头的实线来表示泛化关系，箭头从子类指向父类 依赖关系 依赖关系通常表现为一个类(A)的某个方法的参数或者方法中的局部变量使用了另外一个类的对象，注意关联关系讲的是成员变量 而 依赖关系讲的是 局部变量或者方法参数。在UML类图中，依赖关系用带箭头的虚线表示，箭头从使用类指向被依赖的类 实现关系 实现关系就是接口和实现类之间的关系，在UML类图中，用带空心三角箭头的虚线来表示实现关系，箭头从实现类指向接口。 二 时序图时序图是用来描述对象之间消息的发送顺序，横轴表示对象，纵轴表示时间，消息(行为的说明)在各个对象之间横向传递，按照时间顺序排列。时序图的组成元素主要包括 角色(Actor)、对象(Object)、生命线(Lifeline)、控制焦点和消息。 角色 时序图的角色 可以是人、机器、其他系统、子系统 对象 可以理解为执行的主体 他可以是java中的对象 也可以是某个组件、平台、机构等等 消息 消息有同步调用、异步调用、方法返回 同步调用 用实心箭头实线来表示 方法返回 用空心箭头虚线来表示 异步调用 用空心箭头实线来表示 时序图还有一个很重要的概念就是组合片段，组合片段是用来解决交互执行的条件和方式，它允许在时序图中直接表示某段逻辑，时序图的组合片段一共有13种 常用的有如下几种 抉择(Alt) 相当于if else的逻辑 选项(Opt) 仅当提供的条件为真时才执行片段。 相当于只有一条迹线的alt 循环(Loop) 片段可以执行多次，并且防护指示迭代的基础 并行(Par) 每个片段并行运行 时序图常用图例 同步调用 方法返回 异步调用 抉择 选项 选项就是一个单次的Alt 相当于没有else的Alt 满足条件就进来 不满足条件 不做任何处理 走后续的流程 循环","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"代理","slug":"设计模式-代理模式","date":"2022-01-26T14:49:18.927Z","updated":"2022-03-19T16:14:42.448Z","comments":false,"path":"2022/01/26/设计模式-代理模式/","link":"","permalink":"http://example.com/2022/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式主要是在用户端与目标对象中间 产生一个代理对象，通过代理对象来保护目标对象或者对目标对象的功能进行增强。 一 静态代理通用写法所谓静态代理 就是代理类是固定存在的(在编译期就已经生成了的) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//目标对象需要被代理的接口public interface ISubject &#123; //目标对象(被代理对象)核心方法 void execute(String request);&#125;//目标对象public class RealSubject implements ISubject &#123; @Override public void execute(String request) &#123; System.out.println(&quot;目标对象执行request请求&quot;); &#125;&#125;//代理对象public class Proxy implements ISubject&#123; private ISubject target; //静态代理的第二种写法就是将目标对象直接在代理类中实例化 这样可以避免客户端直接访问真实对象 private Proxy(ISubject target)&#123; this.target = target; &#125; public static Proxy getInstance(ISubject subject) &#123; return new Proxy(subject); &#125; @Override public void execute(String request) &#123; before(target); target.execute(request); //目标对象执行execute方法 after(target); &#125; private void before(ISubject subject) &#123; System.out.println(&quot;前置处理&quot;); &#125; private void after(ISubject subject) &#123; System.out.println(&quot;后置处理&quot;); &#125;&#125;//测试public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = Proxy.getInstance(new RealSubject()); proxy.execute(&quot;测试&quot;); &#125;&#125; 二 JDK动态代理示例动态代理是指代理类是在运行期动态生成的 JDK动态代理核心是要创建一个代理类(代理类必须实现InvocationHandler接口) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//要代理的接口public interface IPerson &#123; //相亲 void findLove(String name);&#125;//真实对象public class Person implements IPerson &#123; private String name; public Person(String name)&#123; this.name = name; &#125; @Override public void findLove(String miss) &#123; System.out.println(name + &quot;和&quot; + miss + &quot;相亲&quot;); &#125;&#125;//通用的代理类public class Proxy implements InvocationHandler &#123; private Object target; private Proxy(Object target) &#123; this.target = target; &#125; //这里对jdk动态代理做了一点变动 本来是应该放在场景内中去使用的 被抽离道理代理类中 public static Object getInstance(Object target, Class&lt;?&gt;[] interfaces) &#123; Proxy proxy = new Proxy(target); return java.lang.reflect.Proxy.newProxyInstance(target。getClass().getClassLoader(), interfaces, proxy); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); after(); return result; &#125; public void before() &#123; System.out.println(&quot;前置处理&quot;); &#125; public void after()&#123; System.out.println(&quot;后置处理&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; IPerson person = (IPerson) Proxy.getInstance(new Person(&quot;张三&quot;), new Class[]&#123;IPerson.class&#125;); person.findLove(&quot;李四&quot;); &#125;&#125; 三 Cglib动态代理导入cglib依赖 123456&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Person &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void findLove(String miss) &#123; System.out.println(name + &quot;和&quot; + miss + &quot;相亲&quot;); &#125;&#125;public class Proxy implements MethodInterceptor &#123; public Person getPerson() &#123; //Enhancer 类似于JDK动态代理的Proxy类 它负责创建代理类 Enhancer enhancer = new Enhancer(); //设置代理类的父类(就是真实/目标对象) enhancer.setSuperclass(Person.class); //设置回调函数 这个类似于JDK动态代理的InvocationHandler接口的实现 enhancer.setCallback(this); return (Person)enhancer.create(); &#125; /** * * @param o 这个参数是Cglib代理类的实例 类似于JDK的InvocationHandler接口的proxy参数 * @param method method为正在被调用的方法 * @param args args为方法参数 * @param proxy proxy 为生成的代理类对方法的代理引用 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; before(); proxy.invokeSuper(o, args); after(); return null; &#125; private void before()&#123; System.out.println(&quot;执行前置处理&quot;); &#125; private void after()&#123; System.out.println(&quot;执行后置处理&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); Person person = proxy.getPerson(); person.setName(&quot;李四&quot;); person.findLove(&quot;张三&quot;); &#125;&#125; 四 三种代理的对比在JDK1.6、JDK1.7、JDK1.8逐步对JDK进行动态代理优化之后，在调用次数较少的情况下, JDK代理的效率比Cglib效率高，当大量调用的时候,JDK1.6、JDK1.7的效率比Cglib效率低。但是JDK1.8的时候，JDK代理效率高于Cglib代理，所以如果有接口使用JDK动态代理，没有接口用Cglib代理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"建造者","slug":"设计模式-建造者模式","date":"2022-01-25T15:44:06.884Z","updated":"2022-03-19T16:14:20.960Z","comments":false,"path":"2022/01/25/设计模式-建造者模式/","link":"","permalink":"http://example.com/2022/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式和工厂模式很像，建造者模式主要偏重于创建复杂对象，它一般被设计为链式调用，一般会在复杂对象中创建一个builder的静态内部类，同时提供一个build方法 示例如下 建造者模式还有一个重要的作用是控制对象变量设值的顺序 在某些需要控制对象属性构建的顺序的场景下比较适用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//测试类public class Client &#123; public static void main(String[] args) &#123; Course.CourseBuilder builder = new Course.CourseBuilder(); Course course = builder.addName(&quot;java&quot;).addNote(new Note(&quot;java笔记&quot;)).addVideo(new Video(&quot;java视频&quot;)).build(); System.out.println(course); &#125;&#125;@Data@ToStringclass Course &#123; private String courseName; private Note note; private Video video; private Course()&#123; &#125; //在建造者模式中builder类一般设计为静态内部类 public static class CourseBuilder &#123; Course course = new Course(); //builder类被设计为允许链式调用 public CourseBuilder addName(String name)&#123; course.setCourseName(name); return this; &#125; public CourseBuilder addNote(Note note)&#123; course.setNote(note); return this; &#125; public CourseBuilder addVideo(Video video) &#123; course.setVideo(video); return this; &#125; public Course build() &#123; return course; &#125; &#125;&#125;@Data@AllArgsConstructor@ToStringclass Note &#123; private String name;&#125;@Data@AllArgsConstructor@ToStringclass Video &#123; private String name;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","slug":"设计模式-原型模式","date":"2022-01-25T13:59:39.849Z","updated":"2022-03-19T16:15:34.739Z","comments":false,"path":"2022/01/25/设计模式-原型模式/","link":"","permalink":"http://example.com/2022/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型设计模式的本质其实就是以系统中已存在的一个对象为原型 复制出若干的相同的对象 原型模式复制的对象是基于二进制流来复制的，不会经过构造器，所以其效率比直接new对象要高。 涉及到对象的克隆就不得不说Object的clonalbe接口 实现该接口 则可以进行浅克隆 浅克隆对引用对象无效(它只会复制引用对象的地址) 而java中进行深克隆有两种办法 一种是对引用对象单独进行复制(这个要求引用对象本身也实现了clonealbe接口 且引用对象中没有引用对象了) 第二种则是通过序列化的方式来实现深克隆 一 原型模式(浅克隆)12345678910111213141516171819202122232425262728293031323334353637public class Prototype &#123; public static void main(String[] args) throws Exception&#123; List&lt;String&gt; hobbies = new ArrayList&lt;&gt;(); hobbies.add(&quot;打篮球&quot;); hobbies.add(&quot;打乒乓&quot;); A a = new A(&quot;张三&quot;, hobbies); System.out.println(a); A a2 = a.clone(); a2.getHobbies().add(&quot;打羽毛球&quot;); System.out.println(a2); //a2的hobbies有3个元素 System.out.println(a); //a的hobbies也有3个元素 &#125;&#125;@Data@AllArgsConstructorclass A implements Cloneable&#123; private String name; private List&lt;String&gt; hobbies; //原型模式的核心方法clone @Override public A clone() throws CloneNotSupportedException &#123; return (A)super.clone(); &#125; @Override public String toString() &#123; return &quot;A&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, hobbies=&quot; + hobbies + &#x27;&#125;&#x27;; &#125;&#125; 二原型模式(深克隆)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Prototype &#123; public static void main(String[] args) throws Exception&#123; List&lt;String&gt; hobbies = new ArrayList&lt;&gt;(); hobbies.add(&quot;打篮球&quot;); hobbies.add(&quot;打乒乓&quot;); A a = new A(&quot;张三&quot;, hobbies); System.out.println(a); A a2 = a.copy(); a2.getHobbies().add(&quot;打羽毛球&quot;); System.out.println(a2); System.out.println(a); &#125;&#125;@Data@AllArgsConstructorclass A implements Serializable &#123; private static final long serialVersionUID = -7362917628271346772L; private String name; private List&lt;String&gt; hobbies; public A copy() throws Exception&#123; ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try &#123; bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); return (A)ois.readObject(); &#125;finally &#123; if(ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125; @Override public String toString() &#123; return &quot;A&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, hobbies=&quot; + hobbies + &#x27;&#125;&#x27;; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"抽象工厂","slug":"设计模式-抽象工厂","date":"2022-01-23T15:17:16.828Z","updated":"2022-03-19T16:13:38.912Z","comments":false,"path":"2022/01/23/设计模式-抽象工厂/","link":"","permalink":"http://example.com/2022/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","excerpt":"","text":"抽象工厂可以看做是工厂方法的集合 工厂方法中 一个工厂只能生产一种产品 而抽象工厂中 一个具体的工厂则可以生产多个产品 所谓的产品可以理解为一个接口 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//抽象工厂public interface Course &#123; Note getNote(); //如果抽象工厂中 只包含一个产品(接口)的创建 那么它就是工厂方法 Video getVideo();&#125;//抽象产品Apublic interface Note &#123; void note();&#125;//抽象产品Bpublic interface Video &#123; void play();&#125;//A产品族public class JavaCourse implements Course&#123; @Override public Note getNote() &#123; return new JavaNote(); &#125; @Override public Video getVideo() &#123; return new JavaVideo(); &#125;&#125;//B产品族public class PythonCourse implements Course&#123; @Override public Note getNote() &#123; return new PythonNote(); &#125; @Override public Video getVideo() &#123; return new PythonVideo(); &#125;&#125;//A产品族中的A产品public class JavaNote implements Note&#123; @Override public void note() &#123; System.out.println(&quot;java课堂笔记&quot;); &#125;&#125;//A产品族中的B产品public class JavaVideo implements Video&#123; @Override public void play() &#123; System.out.println(&quot;java课堂视频&quot;); &#125;&#125;//B产品族中的A产品public class PythonNote implements Note&#123; @Override public void note() &#123; System.out.println(&quot;python课堂笔记&quot;); &#125;&#125;//B产品族中的B产品public class PythonVideo implements Video&#123; @Override public void play() &#123; System.out.println(&quot;python课堂视频&quot;); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; JavaCourse javaCourse = new JavaCourse(); javaCourse.getVideo().play(); javaCourse.getNote().note(); PythonCourse pythonCourse = new PythonCourse(); pythonCourse.getNote().note(); pythonCourse.getVideo().play(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂方法","slug":"设计模式-工厂方法","date":"2022-01-23T09:43:37.149Z","updated":"2022-03-19T16:13:15.291Z","comments":false,"path":"2022/01/23/设计模式-工厂方法/","link":"","permalink":"http://example.com/2022/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/","excerpt":"","text":"工厂方法模式区别于简单工厂，最主要的区别是简单工厂只有一个工厂类，而在工厂方法中，会有一个抽象的工厂(接口/抽象类) 同时会有若干个具体的工厂 但是抽象的产品只会有一个。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//抽象的工厂接口public interface IFactory &#123; IProduct createProduct();&#125;//抽象的产品接口public interface IProduct &#123; void productInfo();&#125;//产品Apublic class ProductA implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//产品Bpublic class ProductB implements IProduct&#123; @Override public void productInfo() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//工厂Apublic class FactoryA implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductA(); &#125;&#125;//工厂Bpublic class FactoryB implements IFactory&#123; @Override public IProduct createProduct() &#123; return new ProductB(); &#125;&#125;//这个可以理解为工厂的工厂 实际它不算在工厂方法设计模式中public class FactoryHelper &#123; private static final Map&lt;Class&lt;? extends IFactory&gt;, IFactory&gt; factories = new ConcurrentHashMap&lt;&gt;(); static &#123; registry(FactoryA.class, new FactoryA()); registry(FactoryB.class, new FactoryB()); &#125; public static IFactory getFactory(Class&lt;? extends IFactory&gt; clazz)&#123; return factories.get(clazz); &#125; public static void registry(Class&lt;? extends IFactory&gt; clazz, IFactory factory) &#123; factories.put(clazz, factory); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; IProduct productA = FactoryHelper.getFactory(FactoryA.class).createProduct(); productA.productInfo(); IProduct productB = FactoryHelper.getFactory(FactoryB.class).createProduct(); productB.productInfo(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计原则","slug":"设计模式-设计原则","date":"2022-01-22T13:40:18.206Z","updated":"2022-03-19T16:12:35.274Z","comments":false,"path":"2022/01/22/设计模式-设计原则/","link":"","permalink":"http://example.com/2022/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","excerpt":"","text":"开闭原则 是指一个软件实体 如类、模块、函数应该对扩展开放，对修改关闭。 依赖倒置原则 是指代码之间的发生依赖的时候 应该依赖其抽象(接口) 这样可以降低类与类之间的耦合性，提高系统稳定性 单一职责原则 是指一个类只能拥有一个变动的因素 也就是一个类只负责一个职责 单一职责其实就是告诉我们 类和方法都要设计的足够的小 接口隔离原则 一个类对另一个类的依赖应该建立在最小接口上；建立单一的接口 不要建立过于庞大的接口 迪米特法则 又叫最少知道原则 是指一个对象应该尽量降低与其他类的耦合；迪米特法则其实也是告诉我们要依赖最小接口 而不是实现 里氏替换原则 它强调的是对父类与子类的一个约束 简单来说就是在声明变量(成员变量、局部变量、方法参数)的时候 应该要用父类引用指向子类对象 里氏替换原则要求 1、子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法 2、子类可以增加自己特有的方法，3、子类在重载父类方法的时候 方法的参数要比父类更宽松 4、当子类实现父类方法的时候 方法的返回要比父类更加的严格。 合成复用原则 强调的是我们应该尽量减少通过继承的方式来进行代码的复用 更多的应该通过聚合或者组合的形式来进行代码复用","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"简单工厂","slug":"设计模式-简单工厂","date":"2022-01-05T13:37:32.895Z","updated":"2022-03-22T13:15:48.482Z","comments":false,"path":"2022/01/05/设计模式-简单工厂/","link":"","permalink":"http://example.com/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/","excerpt":"","text":"简单工厂区别于其他工厂最主要的特征就是有一个具体的工厂类 下面是简单工厂的类图 工厂主要是为了灵活的控制生产过程 可以对对象的创建赋予权限 不同的权限获取不同的对象 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//产品接口public interface Product &#123; void display();&#125;//具体产品Apublic class ProductA implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品A&quot;); &#125;&#125;//具体产品Bpublic class ProductB implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品B&quot;); &#125;&#125;//具体产品Cpublic class ProductC implements Product &#123; @Override public void display() &#123; System.out.println(&quot;我是产品C&quot;); &#125;&#125;//简单工厂public class Factory &#123; private Factory() &#123; &#125; public static Factory getInstance() &#123; return Inner.instance; &#125; public Product createProduct(Class&lt;? extends Product&gt; clazz) throws Exception&#123; if (clazz == null) &#123; return null; &#125; Product product = clazz.newInstance(); //此处省略若干创建对象时的所需要的操作 因为一般工厂模式创建对象都是创建复杂对象 return product; &#125; private static class Inner &#123; private static final Factory instance = new Factory(); &#125;&#125;//测试类public class FactoryTest &#123; public static void main(String[] args) throws Exception &#123; Factory factory = Factory.getInstance(); Product product = factory.createProduct(ProductA.class); product.display(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"tk.mybatis集成多数据源","slug":"FAQ-tk.mybatis集成多数据源","date":"2021-12-30T06:37:52.813Z","updated":"2022-03-19T16:22:44.653Z","comments":false,"path":"2021/12/30/FAQ-tk.mybatis集成多数据源/","link":"","permalink":"http://example.com/2021/12/30/FAQ-tk.mybatis%E9%9B%86%E6%88%90%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/","excerpt":"","text":"pom 依赖123456789101112131415161718 &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--分页可以不要--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 配置类主数据源 12345678910111213141516171819202122232425262728293031323334353637383940414243@Configuration@MapperScan(basePackages = &#123;&quot;com.xxx.dao.gmp&quot;&#125;, sqlSessionTemplateRef = &quot;druidSqlSessionTemplate&quot;,markerInterface = BaseMapper.class)public class DataSourceConfig &#123; @Bean @Primary @ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;) public DataSourceProperties druidDataSourceProperties() &#123; return new DataSourceProperties(); &#125; @Bean @Primary public DataSource druidDataSource(@Qualifier(&quot;druidDataSourceProperties&quot;) DataSourceProperties druidDataSourceProperties) &#123; return druidDataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean @Primary public DataSourceTransactionManager druidTransactionManager(@Qualifier(&quot;druidDataSource&quot;) DataSource druidDataSource) &#123; return new DataSourceTransactionManager(druidDataSource); &#125; @Bean @Primary public SqlSessionTemplate druidSqlSessionTemplate(@Qualifier(&quot;druidSqlSessionFactory&quot;) SqlSessionFactory druidSqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(druidSqlSessionFactory); &#125; @Bean @Primary public SqlSessionFactory druidSqlSessionFactory(@Qualifier(&quot;druidDataSource&quot;) DataSource druidDataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); bean.setDataSource(druidDataSource); bean.setConfiguration(configuration); //手动指定mapp.xml的位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/gmp/*Mapper.xml&quot;)); return bean.getObject(); &#125;&#125; 第二数据源 1234567891011121314151617181920212223242526272829303132333435363738@Configuration@MapperScan(basePackages = &#123;&quot;com.xxx.dao.cmd&quot;&#125;, sqlSessionTemplateRef = &quot;cmdSqlSessionTemplate&quot;,markerInterface = BaseMapper.class)public class CMDDataSourceConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource.cmd&quot;) public DataSourceProperties cmdDataSourceProperties() &#123; return new DataSourceProperties(); &#125; @Bean public DataSource cmdDataSource(@Qualifier(&quot;cmdDataSourceProperties&quot;) DataSourceProperties cmdDataSourceProperties) &#123; return cmdDataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean public DataSourceTransactionManager cmdTransactionManager(@Qualifier(&quot;cmdDataSource&quot;) DataSource cmdDataSource) &#123; return new DataSourceTransactionManager(cmdDataSource); &#125; @Bean public SqlSessionTemplate cmdSqlSessionTemplate(@Qualifier(&quot;cmdSqlSessionFactory&quot;) SqlSessionFactory cmdSqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(cmdSqlSessionFactory); &#125; @Bean public SqlSessionFactory cmdSqlSessionFactory(@Qualifier(&quot;cmdDataSource&quot;) DataSource cmdDataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); bean.setDataSource(cmdDataSource); bean.setConfiguration(configuration); //手动指定mapp.xml的位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/cmd/*Mapper.xml&quot;)); return bean.getObject(); &#125;&#125; mapper 12345import com.gzhc365.arch.gmp.po.CMDServerInfo;import tk.mybatis.mapper.common.Mapper;public interface CMDServerInfoDAO extends Mapper&lt;CMDServerInfo&gt; &#123;&#125; 12345import com.gzhc365.arch.gmp.po.Application;import tk.mybatis.mapper.common.Mapper;public interface ApplicationDAO extends Mapper&lt;Application&gt; &#123;&#125; 配置 1234567891011#主数据源配置spring.datasource.druid.url = jdbc:mysql://xxx:3306/xxdb?allowPublicKeyRetrieval=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=truespring.datasource.druid.username = xxxspring.datasource.druid.password = xxxspring.datasource.druid.driver-class-name = com.mysql.jdbc.Driver#第二数据源配置spring.datasource.cmd.url = jdbc:mysql://xxx:3306/yyDb?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.cmd.username = yyyspring.datasource.cmd.password = yyyspring.datasource.cmd.driver-class-name = com.mysql.jdbc.Driver 多数据源的配置主要是相关配置类和properties配置文件的配置","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"SpringBoot配置文件属性自动提示","slug":"SpringBoot-配置文件属性自动提示","date":"2021-12-30T06:24:09.936Z","updated":"2022-03-19T16:27:29.319Z","comments":false,"path":"2021/12/30/SpringBoot-配置文件属性自动提示/","link":"","permalink":"http://example.com/2021/12/30/SpringBoot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA/","excerpt":"","text":"spring-boot-configuration-processor的作用 当我们再springboot的配置文件如application.properties 或者 application.yaml文件去填充配置的时候 会发现springboot配置文件会自动提示，但是我们自己自定义的一些配置无法提示。如图 要使得我们自定义的配置也能达到这样的效果(自动提示) 需要借助spring-boot-configuration-processor 这个jar 同时需要配和使用@ConfigurationProperties注解来实现 spring-boot-configuration-processor的作用是生成配置的元数据信息，即在classes目录下的META-INF目录下生成spring-configuration-metadata.json文件，从而告诉spring这个jar包中有哪些自定义的配置 还可以在resources目录下手动添加META-INF/additional-spring-configuration-metadata.json文件，这个文件是手动添加的，用于对spring-configuration-metadata.json进行补充，编译后会合并到spring-configuration-metadata.json中 示例 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt; 配置好之后一定要先编译 不然是不会生效的(执行maven的package或者install命令) 效果如下 自定义的配置 hc.custom.xx 博客链接 1https://www.cnblogs.com/tonglin0325/p/5344129.html","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"maven依赖冲突如何解决","slug":"FAQ-maven依赖冲突解决方案","date":"2021-12-30T03:39:39.989Z","updated":"2022-03-19T16:19:24.626Z","comments":false,"path":"2021/12/30/FAQ-maven依赖冲突解决方案/","link":"","permalink":"http://example.com/2021/12/30/FAQ-maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"问题启动时项目时报错如下 1NoClassDefFoundError org/mybatis/logging/LoggerFactory 明明已经集成了mybatis相关依赖 还报找不到类定义 检查完pom之后 确认依赖没问题以后 可以借助idea的maven helper插件 查看下当前的mybatis依赖是否有冲突 解决办法 利用maven helper插件排除多余的依赖 重新更新maven依赖(reimport ) 即可","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"策略模式","slug":"设计模式-策略","date":"2021-12-19T12:00:24.342Z","updated":"2022-03-26T03:21:59.634Z","comments":false,"path":"2021/12/19/设计模式-策略/","link":"","permalink":"http://example.com/2021/12/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/","excerpt":"","text":"策略模式 可以用来替代if else这种逻辑判断 核心是抽象出来一个公共的策略接口 下面的示例是一个利用策略模式 简单实现的一个计算器 一 策略接口123public interface Executor &#123; Number execute(Number p1, Number p2);&#125; 二 策略实现1234567891011121314public class AddExecutor implements Executor &#123; @Override public Number execute(Number p1, Number p2) &#123; return p1.doubleValue() + p2.doubleValue(); &#125;&#125;public class SubExecutor implements Executor &#123; @Override public Number execute(Number p1, Number p2) &#123; return p1.doubleValue() - p2.doubleValue(); &#125;&#125; 三 策略的容器Calculator 类主要是提供一个或者一些方法来应用策略 123456public class Calculator &#123; public static Number calculate(Number a, Number b, Executor executor) &#123; return executor.execute(a, b); &#125;&#125; 四 测试12345678public class StrategyTest &#123; public static void main(String[] args) &#123; Number result = Calculator.calculate(1, 2, new AddExecutor()); Number result2 = Calculator.calculate(1, 2, new SubExecutor()); System.out.println(result); System.out.println(result2); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例","slug":"设计模式-单例","date":"2021-12-19T08:02:05.637Z","updated":"2022-03-19T16:13:59.539Z","comments":false,"path":"2021/12/19/设计模式-单例/","link":"","permalink":"http://example.com/2021/12/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/","excerpt":"","text":"单例模式的核心点是构造器私有化 并提供一个全局访问点 一 饿汉式123456789101112public class Singleton01 &#123; private static final Singleton01 instance = new Singleton01(); private Singleton01() &#123; &#125; public static Singleton01 getInstance() &#123; return instance; &#125;&#125; 二 懒汉式 双重检测锁的实现12345678910111213141516171819public class Singleton02 &#123; private static volatile Singleton02 instance; private Singleton02 ()&#123; &#125; public static Singleton02 getInstance()&#123; if (instance == null) &#123; synchronized (Singleton02.class) &#123; if (instance == null) &#123; instance = new Singleton02(); &#125; &#125; &#125; return instance; &#125;&#125; 三 懒汉式 静态内部类实现1234567891011121314public class Singleton03 &#123; private Singleton03() &#123; &#125; public static Singleton03 getInstance()&#123; return Singleton03Holder.instance; &#125; private static class Singleton03Holder &#123; static Singleton03 instance = new Singleton03(); &#125;&#125; 四 枚举实现单例java规范规定 枚举类是没有构造方法 所以这种写法可以防止通过java反射 利用构造器去创建对象 上面的三种方式都无法防止 但是枚举单例可以 12345678public enum Singleton04 &#123; INSTANCE; //其他业务方法 public void sayHello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 枚举单例序列化测试 1234567891011121314151617181920212223242526272829303132333435363738//枚举默认是实现了序列化接口的 不需要单独的实现序列化接口了public enum Singleton &#123; INSTANCE;&#125;public class Client &#123; public static void main(String[] args) throws Exception&#123; String path = &quot;/Users/liliang/code/test/comon-test/src/main/java/com/liliang/test/test/Singleton02.java&quot;; FileOutputStream fos = null; ObjectOutputStream oos = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fos = new FileOutputStream(path); oos = new ObjectOutputStream(fos); oos.writeObject(Singleton.INSTANCE); fis = new FileInputStream(path); ois = new ObjectInputStream(fis); Object object = ois.readObject(); System.out.println(object.hashCode()); //测试结果 hashcode 与 下面的hashcode是一样的 System.out.println(Singleton.INSTANCE.hashCode()); &#125;finally &#123; //文件流的关闭顺序 后用先关 如果用了处理流 则只需要关闭处理流就行了 节点流不需要关闭。 if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125;&#125; 五 通用防止序列化破坏单例的解决办法上述的的单例实现方式除了枚举 都不能再单例类实现序列化接口后 还保证单例 要想在单例类实现序列化接口后还能保证单例 需要增加一个readResolve()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Singleton implements Serializable &#123; private static final long serialVersionUID = 7518189569602396628L; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return Inner.instance; &#125; //必须要加readResolve方法 方法名和返回值都不能错 private Object readResolve() &#123; return Inner.instance; &#125; private static class Inner&#123; private static final Singleton instance = new Singleton(); &#125;&#125;public class Client &#123; public static void main(String[] args) throws Exception&#123; String path = &quot;/Users/liliang/code/test/comon-test/src/main/java/com/liliang/test/test/Singleton02.txt&quot;; FileOutputStream fos = null; ObjectOutputStream oos = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fos = new FileOutputStream(path); oos = new ObjectOutputStream(fos); oos.writeObject(Singleton.getInstance()); fis = new FileInputStream(path); ois = new ObjectInputStream(fis); Object object = ois.readObject(); System.out.println(object.hashCode()); System.out.println(Singleton.getInstance().hashCode()); &#125;finally &#123; //文件流的关闭顺序 后用先关 如果用了处理流 则只需要关闭处理流就行了 节点流不需要关闭。 if (ois != null) &#123; ois.close(); &#125; if (oos != null) &#123; oos.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"easyexcel使用报错","slug":"FAQ-easyexcel使用报错","date":"2021-11-23T10:32:48.552Z","updated":"2022-03-19T16:20:40.804Z","comments":false,"path":"2021/11/23/FAQ-easyexcel使用报错/","link":"","permalink":"http://example.com/2021/11/23/FAQ-easyexcel%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99/","excerpt":"","text":"报错信息 1easyexcel The maximum length of cell contents (text) is 32,767 characters 使用easyexcel向excel中写内容出现了单元格大小不能超过32,767的限制，这是因为excel 2007限制单个cell不能超过32767个字符 解决办法 重写poi包下SpreadsheetVersion类在自己的项目文件夹下创建org.apache.poi.ss.SpreadsheetVersion类，复制poi中的该类源码，excel2007中的最后一个值改为int类型最大值。重试导出问题解决。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * @author liliang * @date 2021/11/23 **/public enum SpreadsheetVersion &#123; /** * Excel97 format aka BIFF8 * &lt;ul&gt; * &lt;li&gt;The total number of available rows is 64k (2^16)&lt;/li&gt; * &lt;li&gt;The total number of available columns is 256 (2^8)&lt;/li&gt; * &lt;li&gt;The maximum number of arguments to a function is 30&lt;/li&gt; * &lt;li&gt;Number of conditional format conditions on a cell is 3&lt;/li&gt; * &lt;li&gt;Number of cell styles is 4000&lt;/li&gt; * &lt;li&gt;Length of text cell contents is 32767&lt;/li&gt; * &lt;/ul&gt; */ EXCEL97(0x10000, 0x0100, 30, 3, 4000, 32767), /** * Excel2007 * * &lt;ul&gt; * &lt;li&gt;The total number of available rows is 1M (2^20)&lt;/li&gt; * &lt;li&gt;The total number of available columns is 16K (2^14)&lt;/li&gt; * &lt;li&gt;The maximum number of arguments to a function is 255&lt;/li&gt; * &lt;li&gt;Number of conditional format conditions on a cell is unlimited * (actually limited by available memory in Excel)&lt;/li&gt; * &lt;li&gt;Number of cell styles is 64000&lt;/li&gt; * &lt;li&gt;Length of text cell contents is 32767&lt;/li&gt; * &lt;ul&gt; */ EXCEL2007(Integer.MAX_VALUE, Integer.MAX_VALUE, 255, Integer.MAX_VALUE, 64000, Integer.MAX_VALUE); private final int _maxRows; private final int _maxColumns; private final int _maxFunctionArgs; private final int _maxCondFormats; private final int _maxCellStyles; private final int _maxTextLength; private SpreadsheetVersion(int maxRows, int maxColumns, int maxFunctionArgs, int maxCondFormats, int maxCellStyles, int maxText) &#123; _maxRows = maxRows; _maxColumns = maxColumns; _maxFunctionArgs = maxFunctionArgs; _maxCondFormats = maxCondFormats; _maxCellStyles = maxCellStyles; _maxTextLength = maxText; &#125; /** * @return the maximum number of usable rows in each spreadsheet */ public int getMaxRows() &#123; return _maxRows; &#125; /** * @return the last (maximum) valid row index, equals to &lt;code&gt; getMaxRows() - 1 &lt;/code&gt; */ public int getLastRowIndex() &#123; return _maxRows - 1; &#125; /** * @return the maximum number of usable columns in each spreadsheet */ public int getMaxColumns() &#123; return _maxColumns; &#125; /** * @return the last (maximum) valid column index, equals to &lt;code&gt; getMaxColumns() - 1 &lt;/code&gt; */ public int getLastColumnIndex() &#123; return _maxColumns - 1; &#125; /** * @return the maximum number arguments that can be passed to a multi-arg function (e.g. COUNTIF) */ public int getMaxFunctionArgs() &#123; return _maxFunctionArgs; &#125; /** * @return the maximum number of conditional format conditions on a cell */ public int getMaxConditionalFormats() &#123; return _maxCondFormats; &#125; /** * @return the maximum number of cell styles per spreadsheet */ public int getMaxCellStyles() &#123; return _maxCellStyles; &#125; /** * * @return the last valid column index in a ALPHA-26 representation * (&lt;code&gt;IV&lt;/code&gt; or &lt;code&gt;XFD&lt;/code&gt;). */ public String getLastColumnName() &#123; return CellReference.convertNumToColString(getLastColumnIndex()); &#125; /** * @return the maximum length of a text cell */ public int getMaxTextLength() &#123; return _maxTextLength; &#125;&#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"RestTemplate最佳实践","slug":"FAQ-RestTemplate最佳实践","date":"2021-11-17T13:41:35.214Z","updated":"2022-03-19T16:21:18.253Z","comments":false,"path":"2021/11/17/FAQ-RestTemplate最佳实践/","link":"","permalink":"http://example.com/2021/11/17/FAQ-RestTemplate%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"一 介绍RestTemplate 是Spring提供的一个用于http访问的工具模板 二 依赖使用restTemplate需要导入如下pom依赖 1234567891011&lt;!--restTemplate启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--根据需要导入httpcomponents--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.10&lt;/version&gt;&lt;/dependency&gt; 三 restTemplate配置在使用restTemplate之前 还需要简单的对restTemplate进行配置 配置类如下 123456789101112131415161718@Data@Configuration@ConfigurationProperties(prefix = &quot;xx.xx.xx&quot;)public class RestTemplateConfig &#123; private Long connectionTimeout = 1000L; private Long readTimeout = 1000L; @Bean //将RestTemplate装配为bean public RestTemplate restTemplate(RestTemplateBuilder builder) &#123; return builder .requestFactory(HttpComponentsClientHttpRequestFactory.class) .setConnectTimeout(Duration.ofMillis(connectionTimeout)) //设置http的链接超时时间 .setReadTimeout(Duration.ofMillis(readTimeout)) //设置http的响应超时时间 .build(); &#125;&#125; 四 使用restTemplate12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@RestControllerpublic class TestController &#123; @Autowired private RestTemplate restTemplate; /** * 获取nacos中指定dataId的配置信息 **/ @RequestMapping(path = &quot;/getConfig&quot;, method = RequestMethod.GET) public String getConfig(HttpServletRequest request) &#123; //获取nacos的accessToken String accessToken = getAccessToken(); accessToken = String.valueOf(JSON.parseObject(accessToken, Map.class).get(&quot;accessToken&quot;)); String url = &quot;http://xxxx/nacos/v1/cs/configs?dataId=&#123;dataId&#125;&amp;group=&#123;group&#125;&amp;tenant=&#123;tenant&#125;&amp;accessToken=&#123;accessToken&#125;&amp;namespaceId=&#123;namespaceId&#125;&quot;; Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); paramMap.put(&quot;dataId&quot;,&quot;xxx&quot;); paramMap.put(&quot;group&quot;,&quot;DEFAULT_GROUP&quot;); paramMap.put(&quot;tenant&quot;,&quot;xx&quot;); paramMap.put(&quot;accessToken&quot;, accessToken); paramMap.put(&quot;namespaceId&quot;,&quot;xxx&quot;); //设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(null, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class, paramMap); return response.getBody(); &#125; /** * 获取nacos的accessToken **/ private String getAccessToken() &#123; String url = &quot;http://xxx/nacos/v1/auth/login&quot;; MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;(); paramMap.add(&quot;username&quot;,&quot;nacos&quot;); paramMap.add(&quot;password&quot;,&quot;nacos&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); //请求类型为表单 HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(paramMap, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody(); &#125;&#125; 五 发送POST请求 使用RestTemplate post请求的时候主要可以通过三种方式实现 调用postForObject方法 调用postEntity方法 调用exchange方法 postForObject和postForEntity方法的区别主要在于可以在postForEntity方法中设置header的属性，当需要指定header的属性值的时候，使用postForEntity方法。exchange方法和postForEntity类似，但是更灵活，exchange还可以调用get、put、delete请求。 ContentType是表单 当ContentType的类型为表单类型时(content-type=application/x-www-form-urlencoded等)post请求的body不能是json也不能是map必须是MultiValueMap类型 1234567891011121314private String getAccessToken() &#123; String url = &quot;http://xxx/nacos/v1/auth/login&quot;; //因为ContentType是表单 所以用MultiValueMap去对表单进行设值 MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;(); paramMap.add(&quot;username&quot;,&quot;nacos&quot;); paramMap.add(&quot;password&quot;,&quot;nacos&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); //请求类型为表单 HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(paramMap, headers); ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody();&#125; ContentType是JSON 当ContentType是json的时候 就没有这么麻烦了 可以直接填充json格式的参数作为body 12345678910111213@RequestMapping(path = &quot;/test&quot;, method = RequestMethod.GET) public String test() &#123; String url = &quot;https://xxx/web/message/view/unread&quot;; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;coupon&quot;, true); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); //设值contentType是application/json headers.add(&quot;Cookie&quot;, &quot;xxx&quot;); //添加cookie HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(JSON.toJSONString(paramMap), headers); //这里body被转换成了json ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.POST, entity, String.class); return response.getBody(); &#125; 六 发送GET请求restTemplate发送GET请求如果需要带参数 必须在url上填充占位符 示例如下 12345678910111213141516171819202122232425/** * 获取nacos中指定dataId的配置信息 **/ @RequestMapping(path = &quot;/getConfig&quot;, method = RequestMethod.GET) public String getConfig(HttpServletRequest request) &#123; //获取nacos的accessToken String accessToken = getAccessToken(); accessToken = String.valueOf(JSON.parseObject(accessToken, Map.class).get(&quot;accessToken&quot;)); String url = &quot;http://xxxx/nacos/v1/cs/configs?dataId=&#123;dataId&#125;&amp;group=&#123;group&#125;&amp;tenant=&#123;tenant&#125;&amp;accessToken=&#123;accessToken&#125;&amp;namespaceId=&#123;namespaceId&#125;&quot;; //注意这里url中的&#123;xx&#125;都是占位符 Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); //这里用map而不用MultiValueMap paramMap.put(&quot;dataId&quot;,&quot;xxx&quot;); paramMap.put(&quot;group&quot;,&quot;DEFAULT_GROUP&quot;); paramMap.put(&quot;tenant&quot;,&quot;xx&quot;); paramMap.put(&quot;accessToken&quot;, accessToken); paramMap.put(&quot;namespaceId&quot;,&quot;xxx&quot;); //设置请求头 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(null, headers); //注意get请求时 这里填充的是null ResponseEntity&lt;String&gt; response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class, paramMap); return response.getBody(); &#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"Spring BeanPostProcessor最佳实践","slug":"FAQ-Spring BeanPostProcessor最佳实践","date":"2021-11-10T13:53:16.193Z","updated":"2022-03-19T16:21:53.408Z","comments":false,"path":"2021/11/10/FAQ-Spring BeanPostProcessor最佳实践/","link":"","permalink":"http://example.com/2021/11/10/FAQ-Spring%20BeanPostProcessor%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"BeanPostProcessor接口的作用是在Spring bean 实例化完成后(执行完initializeBean)之后，初始化之前(执行bean的初始化方法)对Bean添加一些自定义的处理逻辑。也就是说执行beanProcessor方法是在bean实例化之后 此时bean的属性值都已经被赋值好了。另外需要注意的是 beanProcessor的实现类一定要被Spring托管才能生效。 一、BeanPostProcessor示例 实体类 12345678910111213141516171819202122232425262728293031323334@Component@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public class DataSourceProperty &#123; private String userName; private String password; /** * 通过@PostConstruct来标记这个init方法为bean的初始化方法 **/ @PostConstruct private void init() &#123; //这条语句会在 beanprocessor的postProcessBeforeInitialization方法执行之后执行 2 System.out.println(&quot;执行初始化方法&quot;); &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 配置 12spring.datasource.username=testspring.datasource.password=12345678 自定义的BeanPostProcessor实现类 1234567891011121314151617181920212223242526272829303132333435363738//这个类一定要被spring容器托管(也就是要能够被spring识别为一个bean) postProcessBeforeInitialization 和 //postProcessAfterInitialization才会生效@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; /** * bean实例化前处理 * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof DataSourceProperty) &#123; //这条语句是最先打印的 1 DataSourceProperty 此时它的两个属性是已经被赋值了的 System.out.println(&quot;dataSourceProperty 初始化前执行 dataSourceProperty&quot; ); &#125; return bean; &#125; /** * bean实例化后处理 * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof DataSourceProperty) &#123; //这条语句是最后打印的 System.out.println(&quot;dataSourceProperty 初始后执行&quot; ); &#125; return bean; &#125;&#125; 结果 二、为什么BeanPostProcessor必须被Spring托管才能生效 关于这一点可以查看源码 第一步 当Spring容器启动时 会先执行AbstractApplicationContext类的refresh方法 通过该方法去初始化我们的Spring容器 源码如下 1234567891011121314151617181920212223public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123; @Override public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //省略前面若干方法 prepareBeanFactory(beanFactory); try &#123; //此处省略若干方法 // 向Spring容器注册beanProstProcessor registerBeanPostProcessors(beanFactory); beanPostProcess.end(); //此处省略若干方法 完成Spring容器刷新工作 finishRefresh(); &#125;catch (BeansException ex) &#123; //此处省略 &#125;finally &#123; //此处生路 &#125; &#125; &#125;&#125; 第二步 从第一步 我们知道了当Spring容器在执行refresh方法的时候 会向容器中注册beanProcessor 下面接着看registerBeanPostProcessors(beanFactory)方法的逻辑 该方法的真正实现是在PostProcessorRegistrationDelegate类中 12345678final class PostProcessorRegistrationDelegate &#123; public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; //核心方法 从beanFactory中获取容器中所有实现了BeanPostProcessor接口的bean的名称 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); //此后省略若干方法 &#125;&#125; 第三步 beanFactory.getBeanNamesForType() 这个方法真正的实现是在DefaultListableBeanFactory中 12345678910111213public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123; @Override public String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit) &#123; if (!isConfigurationFrozen() || type == null || !allowEagerInit) &#123; //真正获取beanPostProcessor的名称的方法 return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit); &#125; //此处省略若干方法 return resolvedBeanNames; &#125;&#125; 第四步 123456789101112131415161718192021public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123; private String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); // 它会遍历Spring容器的beanDefinitionNames for (String beanName : this.beanDefinitionNames) &#123; //此处省略若干方法 //如果类型是指定的类型 则将这个bean的名称加入到list中 //对于BeanPostProcessor来说 此时type就是BeanPostProcessor boolean matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit); //此处省略若干方法 if (matchFound) &#123; result.add(beanName); &#125; //此处省略若干方法 &#125; return StringUtils.toStringArray(result); &#125;&#125; 可以发现它最终还是需要通过遍历Spring容器中所有的beanName才能够将这个bean注册为BeanProcessor 如果这个BeanPostProcessor的实现类都没有被Spring托管 也就不可能被注册为beanProcessor 这也就是为什么beanProcessor的实现类 必须被spring托管才能生效。 三、BeanPostProcessor执行的流程 12345678910111213141516//第一步 容器刷新1、AbstractApplicationContext.refresh()//第二步 完成beanFactory初始化2、AbstractApplicationContext.finishBeanFactoryInitialization(beanFactory); //第三步 默认的beanFactory开始预实例化单例bean3、DefaultListableBeanFactory.preInstantiateSingletons();//第四步 开始根据bean的名称获取bean4、AbstractBeanFactory.getBean(String name);//第五步 执行doCreateBean方法 开始创建bean5、AbstractAutowireCapableBeanFactory.doCreateBean()//第六步 对bean进行初始化AbstractAutowireCapableBeanFactory.initializeBean() //第七步 开始遍历beanProcessor 执行beanProcessor的postProcessBeforeInitialization方法AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization();//第八步 执行beanPostProcessor的后置方法AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(); initializeBean源码 12345678910111213141516171819202122232425protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; //此处省略若干方法 Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //执行beanPostProcessor的前置方法 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //执行bean的初始化方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; //执行beanPostProcessor的后置方法 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; applyBeanPostProcessorsBeforeInitialization源码 123456789101112131415@Override public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; //遍历beanPostProcessor 执行前置方法 for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result; &#125; applyBeanPostProcessorsAfterInitialization源码 1234567891011121314@Override public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessAfterInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result; &#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"ConfigurationProperties注解配置复杂类型","slug":"FAQ-@ConfigurationProperties如何配置复杂类型","date":"2021-11-06T13:50:51.478Z","updated":"2022-03-19T16:20:02.508Z","comments":false,"path":"2021/11/06/FAQ-@ConfigurationProperties如何配置复杂类型/","link":"","permalink":"http://example.com/2021/11/06/FAQ-@ConfigurationProperties%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"@ConfigurationProperties 注解可以以前缀的形式统一注入某个前缀的参数 如下面的示例 示例 12345678910#数据源spring.datasource.druid.write.url=jdbc:mysql://localhost:3306/jpaspring.datasource.druid.write.username=rootspring.datasource.druid.write.password=1spring.datasource.druid.write.driver-class-name=com.mysql.jdbc.Driverspring.datasource.druid.read.url=jdbc:mysql://localhost:3306/jpaspring.datasource.druid.read.username=rootspring.datasource.druid.read.password=1spring.datasource.druid.read.driver-class-name=com.mysql.jdbc.Driver 123456789101112131415161718192021222324@Configurationpublic class DruidDataSourceConfig &#123; /** * DataSource 配置 * @return */ @ConfigurationProperties(prefix = &quot;spring.datasource.druid.read&quot;) @Bean(name = &quot;readDruidDataSource&quot;) public DataSource readDruidDataSource() &#123; return new DruidDataSource(); &#125; /** * DataSource 配置 * @return */ @ConfigurationProperties(prefix = &quot;spring.datasource.druid.write&quot;) @Bean(name = &quot;writeDruidDataSource&quot;) @Primary public DataSource writeDruidDataSource() &#123; return new DruidDataSource(); &#125;&#125; 可以看到示例中的配置其实是有两个前缀 spring.datasource.druid.read、spring.datasource.druid.write 如果需要用一个配置类去接收应该怎么去做？可以参考下面的示例 解决方案 下面的配置实现了将read和write两个不同前缀的配置放在了一个配置类中进行注入 核心思想就是利用了内部类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * @ConfigurationProperties 注解必须配合@Component、@Bean、@Configuration注解一起使用 * 也就是说@ConfigurationProperties注解的类 必须被spring托管 * @date 2021/11/06 **/@Component@ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;)public class DataSourceProperties &#123; //write内部类 用于配置前缀为spring.datasource.druid.write的配置 private Write write = new Write(); //read内部类 用于配置前缀为spring.datasource.druid.read的配置 private Read read = new Read(); public Write getWrite() &#123; return write; &#125; public void setWrite(Write write) &#123; this.write = write; &#125; public Read getRead() &#123; return read; &#125; public void setRead(Read read) &#123; this.read = read; &#125; public class Write &#123; private String url; private String username; private String password; private String driverClassName; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; &#125; public class Read &#123; private String url; private String username; private String password; private String driverClassName; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; &#125;&#125;","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]},{"title":"log4j不打印异常栈","slug":"FAQ-log4j不打印异常栈","date":"2021-11-05T07:17:45.378Z","updated":"2022-03-19T16:18:52.164Z","comments":false,"path":"2021/11/05/FAQ-log4j不打印异常栈/","link":"","permalink":"http://example.com/2021/11/05/FAQ-log4j%E4%B8%8D%E6%89%93%E5%8D%B0%E5%BC%82%E5%B8%B8%E6%A0%88/","excerpt":"","text":"​最近在线上系统的错误日志中发现了一个现象 : 代码里用log4j打印系统运行时异常堆栈信息，在错误日志中无法看到堆栈信息，只有异常信息。后来发现这个是jdk的一个优化。JVM 为了性能会做优化，如果频繁的抛出某个异常，会重新编译，不再打印异常堆栈。解决这个问题也比较简单，如果不想每次都去查前面的 log 去看堆栈，只要在启动参数加上 -XX:-OmitStackTraceInFastThrow，就可以禁用该优化，强制打印异常堆栈。这样可能会导致，log 文件过大，不过产线上今天之前的 log 文件都会被压缩，所以感觉问题也不大。","categories":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"}],"tags":[{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"高并发","slug":"高并发","permalink":"http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/categories/FAQ/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/categories/SpringBoot/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"高并发","slug":"高并发","permalink":"http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"FAQ","slug":"FAQ","permalink":"http://example.com/tags/FAQ/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"XXL-JOB","slug":"XXL-JOB","permalink":"http://example.com/tags/XXL-JOB/"}]}